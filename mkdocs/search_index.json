{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to our Documentation!\n\n\nThe micro:bit runtime, also known as the micro:bit DAL (Device Abstraction Layer), is\nessentially a small, lightweight operating system that controls every aspect of\nthe BBC micro:bit.\n\n\nThe runtime is built on a platform called \nmbed\n, provided by ARM,\nwhich provides a common abstraction layer for many ARM based devices.\n\n\nThis resource supplies an abstract overview of the key elements of the runtime,\nincluding the general concepts used by the runtime, and the best practices for\nprogramming the micro:bit when programming at the C/C++ layer.\n\n\nInstalling\n\n\nIf you want to write code for the micro:bit at the C/C++ layer, then you will need\nto install \nYotta\n. Detailed instructions on how to install\nand get our basic project building with Yotta can be found \nhere\n.\n\n\nLayout\n\n\nThe remainder of the page will discuss the general layout of the documentation on\nthis site.\n\n\nMember documentation is generated using \ndoxygen\n,\nwhich is translated into markdown for use by \nmkdocs\n.\n\n\nuBit\n\n\nuBit, a condensed name for micro:bit,  presents our common abstraction\nused by Microsoft Blocks, Microsoft TouchDevelop and CodeKingdoms Javascript.\n\n\nIt is broken down by classes, which are instantiated and attached to the uBit object\nat runtime.\n\n\nEach document provides a brief overview of the class, MessageBus IDs and possible events\nthat could be generated by that class. It also lists the member functions that can\nexecuted by the user to perform various actions with the micro:bit.\n\n\nThe uBit object looks like this:\n\n\n\n\nuBit {\n\n   \n.i2c\n,\n\n   \n.serial\n,\n\n   \n.MessageBus\n,\n\n   \n.buttonA\n,\n\n   \n.buttonB\n,\n\n   \n.buttonAB\n,\n\n   \n.display\n,\n\n   \n.accelerometer\n,\n\n   \n.compass\n,\n\n   \n.thermometer\n,\n\n   \n.io\n,\n\n   \n.ble\n,\n\n   \n.BLEManager\n,\n\n   \n.radio\n,\n\n   }\n\n\n\n\nData Types\n\n\nThe 'Data Types' drop down lists the various different structures used to hold,\npass, and evaluate data used in the runtime.\n\n\n\n\nMicroBitImage\n - This data type is used in the runtime when interacting\nwith various components, in particular the display. It contains bit map information\nand supports various manipulations of this information.\n\n\nMicroBitEvent\n - Events are used throughout the runtime to pass messages\nbetween components or between the system and the user.\n\n\nManagedString\n - Strings are used when interacting with buffers containing\ntext intended for any one of our interfaces that support ManagedString, namely the display.\nThis data type supports many operations on the buffer wrapped by this type. It also, most\nimportantly, manages the memory allocation for the user, and maintains a count of the references\npointing to an instance of this type.\n\n\n\n\nBLE\n\n\nThe ability to communicate is an important aspect of an IOT device. There are a number of ways\nto communicate with a micro:bit from another device, Bluetooth Low Energy (BLE) is one of them.\n\n\nThe documentation covered in this section outlines important elements required to communicate\nwith a micro:bit over BLE, including documentation around the pairing process, and the specification\nof the default micro:bit profile.\n\n\nExtras\n\n\nThis navigation list commonly covers classes that are hidden or wrapped by other elements of the runtime\nto simplify APIs for other languages that target the runtime.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#welcome-to-our-documentation", 
            "text": "The micro:bit runtime, also known as the micro:bit DAL (Device Abstraction Layer), is\nessentially a small, lightweight operating system that controls every aspect of\nthe BBC micro:bit.  The runtime is built on a platform called  mbed , provided by ARM,\nwhich provides a common abstraction layer for many ARM based devices.  This resource supplies an abstract overview of the key elements of the runtime,\nincluding the general concepts used by the runtime, and the best practices for\nprogramming the micro:bit when programming at the C/C++ layer.", 
            "title": "Welcome to our Documentation!"
        }, 
        {
            "location": "/#installing", 
            "text": "If you want to write code for the micro:bit at the C/C++ layer, then you will need\nto install  Yotta . Detailed instructions on how to install\nand get our basic project building with Yotta can be found  here .", 
            "title": "Installing"
        }, 
        {
            "location": "/#layout", 
            "text": "The remainder of the page will discuss the general layout of the documentation on\nthis site.  Member documentation is generated using  doxygen ,\nwhich is translated into markdown for use by  mkdocs .", 
            "title": "Layout"
        }, 
        {
            "location": "/#ubit", 
            "text": "uBit, a condensed name for micro:bit,  presents our common abstraction\nused by Microsoft Blocks, Microsoft TouchDevelop and CodeKingdoms Javascript.  It is broken down by classes, which are instantiated and attached to the uBit object\nat runtime.  Each document provides a brief overview of the class, MessageBus IDs and possible events\nthat could be generated by that class. It also lists the member functions that can\nexecuted by the user to perform various actions with the micro:bit.  The uBit object looks like this:   uBit { \n    .i2c , \n    .serial , \n    .MessageBus , \n    .buttonA , \n    .buttonB , \n    .buttonAB , \n    .display , \n    .accelerometer , \n    .compass , \n    .thermometer , \n    .io , \n    .ble , \n    .BLEManager , \n    .radio , \n   }", 
            "title": "uBit"
        }, 
        {
            "location": "/#data-types", 
            "text": "The 'Data Types' drop down lists the various different structures used to hold,\npass, and evaluate data used in the runtime.   MicroBitImage  - This data type is used in the runtime when interacting\nwith various components, in particular the display. It contains bit map information\nand supports various manipulations of this information.  MicroBitEvent  - Events are used throughout the runtime to pass messages\nbetween components or between the system and the user.  ManagedString  - Strings are used when interacting with buffers containing\ntext intended for any one of our interfaces that support ManagedString, namely the display.\nThis data type supports many operations on the buffer wrapped by this type. It also, most\nimportantly, manages the memory allocation for the user, and maintains a count of the references\npointing to an instance of this type.", 
            "title": "Data Types"
        }, 
        {
            "location": "/#ble", 
            "text": "The ability to communicate is an important aspect of an IOT device. There are a number of ways\nto communicate with a micro:bit from another device, Bluetooth Low Energy (BLE) is one of them.  The documentation covered in this section outlines important elements required to communicate\nwith a micro:bit over BLE, including documentation around the pairing process, and the specification\nof the default micro:bit profile.", 
            "title": "BLE"
        }, 
        {
            "location": "/#extras", 
            "text": "This navigation list commonly covers classes that are hidden or wrapped by other elements of the runtime\nto simplify APIs for other languages that target the runtime.", 
            "title": "Extras"
        }, 
        {
            "location": "/installing-yotta/", 
            "text": "Building a project for the micro:bit using yotta\n\n\nThe micro:bit DAL is built on top of \nmbed\n and hence uses \nyotta\n as an offline build system.\n\n\nIf you'd like to use the mbed online IDE instead, you can find instructions at \nthe mbed Developer site\n\n\nWhen using \nyotta\n to build micro:bit projects there are currently two supported toolchains:\n\n\n\n\nGCC\n\n\nARMCC\n\n\n\n\n1. Install yotta and dependencies\n\n\nThe first step is to get \nyotta\n and its dependencies onto your machine, to do this follow the install guide \nhere\n\n\nFor the micro:bit targets you currently still need the srecord tools, which can be installed on \nUbuntu\n using\n\n\nsudo apt-get install srecord\n\n\n\n\nOn \nMac OS X\n you can use brew (\nbrew install srecord\n), or you can install it manually from \nhere\n if you are on \nWindows\n. srecord is used to create the final binaries for the micro:bit so is an essential dependency.\n\n\n2. Fetch the example project\n\n\ngit clone https://github.com/lancaster-university/microbit\ncd microbit #The following instructions assume you're in the example directory\n\n\n\n\n3. Set your yotta target\n\n\nA \nyotta\n target contains the information required by \nyotta\n in order to build a project for a specific combination of hardware. This includes the type of compiler. The microbit projects can build with both \narmcc\n and \ngcc\n, but as it gets installed with the \nyotta\n installer, we'll use \ngcc\n by default and choose a micro:bit specific target that knows about the hardware on the board.\n\n\nYou can use either \nyotta\n or \nyt\n, which is far easier to type!\n\n\nyt target bbc-microbit-classic-gcc\n\n\n\n\nThe 'classic' part of this target name referes to the fact that the micro:bit uses \"mbed Classic\" (see https://developer.mbed.org/) which is the version of mbed before mbed OS. It is also possible to use mbed OS on the micro:bit (see \nhere\n) but the DAL has not yet been ported to use mbed OS.\n\n\nYou only need to set the target once per project. All future \nyotta\n commands will use this target information (for example, when resolving dependencies).\n\n\n4. Build the project\n\n\nyt build\n\n\n\n\n5. Flash your micro:bit\n\n\nThe final step is to check your hex works.\n\n\nThe \nyotta build\n command will place files in \n/build/\nTARGET_NAME\n/source\n. The file you will need to flash will be microbit-combined.hex. Simply drag and drop the hex.\n\n\nIn the case of our example, using \nbbc-microbit-classic-gcc\n we could flash the micro:bit (assuming it is plugged in and mounted at \n/media/MICROBIT\n) as follows:\n\n\ncp ./build/bbc-microbit-classic-gcc/source/microbit-combined.hex /media/MICROBIT\n\n\n\n\nThe expected result will be that the micro:bit will scroll \nBELLO! :)\n on its display.\n\n\n\n\nNote\n\n\nNote that if you'd like to copy the file from the command line, you can use the following command in any \nyotta\n project to do so, though it assumes you have only one micro:bit plugged in:\n\n\ncp build/$(yt --plain target | head -n 1 | cut -f 1 -d' ')/source/$(yt --plain ls | head -n 1 | cut -f 1 -d' ')-combined.hex /media/MICROBIT/", 
            "title": "Offline Development"
        }, 
        {
            "location": "/installing-yotta/#building-a-project-for-the-microbit-using-yotta", 
            "text": "The micro:bit DAL is built on top of  mbed  and hence uses  yotta  as an offline build system.  If you'd like to use the mbed online IDE instead, you can find instructions at  the mbed Developer site  When using  yotta  to build micro:bit projects there are currently two supported toolchains:   GCC  ARMCC", 
            "title": "Building a project for the micro:bit using yotta"
        }, 
        {
            "location": "/installing-yotta/#1-install-yotta-and-dependencies", 
            "text": "The first step is to get  yotta  and its dependencies onto your machine, to do this follow the install guide  here  For the micro:bit targets you currently still need the srecord tools, which can be installed on  Ubuntu  using  sudo apt-get install srecord  On  Mac OS X  you can use brew ( brew install srecord ), or you can install it manually from  here  if you are on  Windows . srecord is used to create the final binaries for the micro:bit so is an essential dependency.", 
            "title": "1. Install yotta and dependencies"
        }, 
        {
            "location": "/installing-yotta/#2-fetch-the-example-project", 
            "text": "git clone https://github.com/lancaster-university/microbit\ncd microbit #The following instructions assume you're in the example directory", 
            "title": "2. Fetch the example project"
        }, 
        {
            "location": "/installing-yotta/#3-set-your-yotta-target", 
            "text": "A  yotta  target contains the information required by  yotta  in order to build a project for a specific combination of hardware. This includes the type of compiler. The microbit projects can build with both  armcc  and  gcc , but as it gets installed with the  yotta  installer, we'll use  gcc  by default and choose a micro:bit specific target that knows about the hardware on the board.  You can use either  yotta  or  yt , which is far easier to type!  yt target bbc-microbit-classic-gcc  The 'classic' part of this target name referes to the fact that the micro:bit uses \"mbed Classic\" (see https://developer.mbed.org/) which is the version of mbed before mbed OS. It is also possible to use mbed OS on the micro:bit (see  here ) but the DAL has not yet been ported to use mbed OS.  You only need to set the target once per project. All future  yotta  commands will use this target information (for example, when resolving dependencies).", 
            "title": "3. Set your yotta target"
        }, 
        {
            "location": "/installing-yotta/#4-build-the-project", 
            "text": "yt build", 
            "title": "4. Build the project"
        }, 
        {
            "location": "/installing-yotta/#5-flash-your-microbit", 
            "text": "The final step is to check your hex works.  The  yotta build  command will place files in  /build/ TARGET_NAME /source . The file you will need to flash will be microbit-combined.hex. Simply drag and drop the hex.  In the case of our example, using  bbc-microbit-classic-gcc  we could flash the micro:bit (assuming it is plugged in and mounted at  /media/MICROBIT ) as follows:  cp ./build/bbc-microbit-classic-gcc/source/microbit-combined.hex /media/MICROBIT  The expected result will be that the micro:bit will scroll  BELLO! :)  on its display.   Note  Note that if you'd like to copy the file from the command line, you can use the following command in any  yotta  project to do so, though it assumes you have only one micro:bit plugged in:  cp build/$(yt --plain target | head -n 1 | cut -f 1 -d' ')/source/$(yt --plain ls | head -n 1 | cut -f 1 -d' ')-combined.hex /media/MICROBIT/", 
            "title": "5. Flash your micro:bit"
        }, 
        {
            "location": "/concepts/", 
            "text": "Responsiveness\n\n\nFrom the very conception of the micro:bit it has always been regarded as\na reactive system. The primary users are between the ages 11 and 12 so it's very\nimportant that the micro:bit is seen to react in a timely manner. Any delay or lack\nof responsiveness can be the difference between frustration and enthusiasm.\n\n\nThe design of the software therefore lends itself to an event driven model.\n\n\nMessage Bus\n\n\nThe \nMicroBitMessageBus\n is the core mechanism that enables\nthe reactivity exhibited by the micro:bit. The \nMicroBitMessageBus\n\nconsumes \nMicroBitEvent\ns and delivers these events asynchronously\nto listeners created with a call to \nuBit.MessageBus.listen\n.\n\n\nThe \nMicroBitMessageBus\n has many purposes:\n\n\n\n\nIt provides an abstraction that is platform independent.\n\n\nIt provides a mechanism to decouple user and system code.\n\n\nIt supplies a common, high level eventing abstraction across many different hardware and software\n  components.\n\n\nIt supports extensibility for new components that are introduced via I/O pins.\n\n\nIt optimises event/data distribution through aggregation, saving energy in the\n  process.\n\n\n\n\nEvents\n\n\nFor nearly every core component of the runtime, events are used as a mechanism\nto signal a specific 'thing' has occurred. In the runtime, this is exposed as a\n\nMicroBitEvent\n.\n\n\nUser or system code can then listen for when these events occur on the shared Message Bus\nand perform specific actions as a result.\n\n\nWhen a \nMicroBitEvent\n is created, it is placed\nonto the shared Message Bus. Any listeners listening to the ID and Value specified\nin a \nMicroBitEvent\n will be executed depending\non the \nMicroBitEventLaunchMode\n.\n\n\nAnother important usage of events is to escape interrupt context. \nMicroBitEvent\ns\ncan be created and queued in interrupt context. Listeners are then executed outside interrupt context,\nwhich means that allocation of memory in the user written handlers is entirely safe.\n\n\nBelow are two equivalent examples of this mechanism in operation, using the native C++\ncalls, and the Microsoft Blocks environment.\n\n\nC++ Example\n\n\nvoid onButtonA(MicroBitEvent e)\n{\n    uBit.display.print('A');\n}\n\nuBit.MessageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n\n\n\n\nBlocks Example\n\n\n\n\nListeners\n\n\nListeners have been briefly covered before, and they are primarily used as a decoupling\nmechanism for the runtime.\n\n\nListeners transform the traditional concept of:\n\n\nif (this)\n    do that\n\n\n\n\nInto:\n\n\non (this):\n    do that\n\n\n\n\nOf course, the prior is still possible in the runtime.\n\n\nListeners are either executed in the idle fiber, or in their own fiber (created by the MessageBus),\nunless explicitly indicated otherwise in the \nMicroBitEvent\n\nthat is placed onto the \nMicroBitMessageBus\n.\n\n\n\n\nNote\n\n\nThis is achieved through changing the \nMicroBitEventLaunchMode\n\nwhen constructing the \nMicroBitEvent\n\n\n\n\nThere are a number of different variations of \nlisten\n applicable to the shared \nMicroBitMessageBus\n.\nThis means as well as the ability to call standard functions, member functions can also be\ncalled on the reception of an event from the \nMicroBitMessageBus\n.\n\n\nThere also exists a form of reflection for the \nMicroBitMessageBus\n.\nEach time a listener is created, and successfully added, an event is created, with\nthe ID of the \nMicroBitMessageBus\n, and the id of the newly\nadded listener. This is used in the runtime to provide lazy instantiation for\ncomponents that are not always fully utilised by users.\n\n\nConcurrency\n\n\nScheduler\n\n\nFibers", 
            "title": "Concepts"
        }, 
        {
            "location": "/concepts/#responsiveness", 
            "text": "From the very conception of the micro:bit it has always been regarded as\na reactive system. The primary users are between the ages 11 and 12 so it's very\nimportant that the micro:bit is seen to react in a timely manner. Any delay or lack\nof responsiveness can be the difference between frustration and enthusiasm.  The design of the software therefore lends itself to an event driven model.", 
            "title": "Responsiveness"
        }, 
        {
            "location": "/concepts/#message-bus", 
            "text": "The  MicroBitMessageBus  is the core mechanism that enables\nthe reactivity exhibited by the micro:bit. The  MicroBitMessageBus \nconsumes  MicroBitEvent s and delivers these events asynchronously\nto listeners created with a call to  uBit.MessageBus.listen .  The  MicroBitMessageBus  has many purposes:   It provides an abstraction that is platform independent.  It provides a mechanism to decouple user and system code.  It supplies a common, high level eventing abstraction across many different hardware and software\n  components.  It supports extensibility for new components that are introduced via I/O pins.  It optimises event/data distribution through aggregation, saving energy in the\n  process.", 
            "title": "Message Bus"
        }, 
        {
            "location": "/concepts/#events", 
            "text": "For nearly every core component of the runtime, events are used as a mechanism\nto signal a specific 'thing' has occurred. In the runtime, this is exposed as a MicroBitEvent .  User or system code can then listen for when these events occur on the shared Message Bus\nand perform specific actions as a result.  When a  MicroBitEvent  is created, it is placed\nonto the shared Message Bus. Any listeners listening to the ID and Value specified\nin a  MicroBitEvent  will be executed depending\non the  MicroBitEventLaunchMode .  Another important usage of events is to escape interrupt context.  MicroBitEvent s\ncan be created and queued in interrupt context. Listeners are then executed outside interrupt context,\nwhich means that allocation of memory in the user written handlers is entirely safe.  Below are two equivalent examples of this mechanism in operation, using the native C++\ncalls, and the Microsoft Blocks environment.", 
            "title": "Events"
        }, 
        {
            "location": "/concepts/#c-example", 
            "text": "void onButtonA(MicroBitEvent e)\n{\n    uBit.display.print('A');\n}\n\nuBit.MessageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);", 
            "title": "C++ Example"
        }, 
        {
            "location": "/concepts/#blocks-example", 
            "text": "", 
            "title": "Blocks Example"
        }, 
        {
            "location": "/concepts/#listeners", 
            "text": "Listeners have been briefly covered before, and they are primarily used as a decoupling\nmechanism for the runtime.  Listeners transform the traditional concept of:  if (this)\n    do that  Into:  on (this):\n    do that  Of course, the prior is still possible in the runtime.  Listeners are either executed in the idle fiber, or in their own fiber (created by the MessageBus),\nunless explicitly indicated otherwise in the  MicroBitEvent \nthat is placed onto the  MicroBitMessageBus .   Note  This is achieved through changing the  MicroBitEventLaunchMode \nwhen constructing the  MicroBitEvent   There are a number of different variations of  listen  applicable to the shared  MicroBitMessageBus .\nThis means as well as the ability to call standard functions, member functions can also be\ncalled on the reception of an event from the  MicroBitMessageBus .  There also exists a form of reflection for the  MicroBitMessageBus .\nEach time a listener is created, and successfully added, an event is created, with\nthe ID of the  MicroBitMessageBus , and the id of the newly\nadded listener. This is used in the runtime to provide lazy instantiation for\ncomponents that are not always fully utilised by users.", 
            "title": "Listeners"
        }, 
        {
            "location": "/concepts/#concurrency", 
            "text": "", 
            "title": "Concurrency"
        }, 
        {
            "location": "/concepts/#scheduler", 
            "text": "", 
            "title": "Scheduler"
        }, 
        {
            "location": "/concepts/#fibers", 
            "text": "", 
            "title": "Fibers"
        }, 
        {
            "location": "/device/", 
            "text": "", 
            "title": "The Device"
        }, 
        {
            "location": "/ubit/", 
            "text": "uBit\n\n\nOverview\n\n\nuBit is the global singleton provided by the runtime and is an instance of the\nMicroBit class.\n\n\nThe MicroBit class has a number of member variables, that operate as device drivers\nto control the various features of the micro:bit.\n\n\n\n\nuBit {\n\n   \n.i2c\n,\n\n   \n.serial\n,\n\n   \n.MessageBus\n,\n\n   \n.buttonA\n,\n\n   \n.buttonB\n,\n\n   \n.buttonAB\n,\n\n   \n.display\n,\n\n   \n.accelerometer\n,\n\n   \n.compass\n,\n\n   \n.thermometer\n,\n\n   \n.io\n,\n\n   \n.ble\n,\n\n   \n.BLEManager\n,\n\n   \n.radio\n,\n\n   }\n\n\n\n\nFor example, if we needed to scroll some text across the display, we simply would\nwrite the following:\n\n\nuBit.display.scroll(\nHELLO!\n);\n\n\n\n\nSimilarly, if we wanted to send some text over serial, we could write the following\ncode:\n\n\nfor(int i = 3; i \n 0; i--)\n{\n    uBit.serial.printf(\n%d...\n, i);\n    uBit.sleep(1000);\n}\n\nuBit.serial.sendString(\nCode!\n);\n\n\n\n\nuBit also provides a number of utility functions that allow the plug and play\nof additional components that developers may create. These are namely \naddSystemComponent()\n\nand \naddIdleComponent()\n. \nRead more about how to plug your own device drivers into the runtime.\n\n\nThe runtime also contains a scheduler, which uses lightweight threads (called fibers)\nto control the rate of execution.\n\n\nTo place the current fiber into a power efficient \nsleep\n write the following:\n\n\n// where X is an integer in milliseconds for the amount of time you would like to sleep for.\nuBit.sleep(X);\n\n\n\n\nRead more about the scheduler.\n\n\nMessage Bus ID\n\n\n\n\nNone\n\n\n\n\nMessage Bus Events\n\n\n\n\nNone\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBit()\n\n\nDescription\n\n\nConstructor. Create a representation of a  MicroBit MicroBitMessageBus\n\n\nExample\n\n\n uBit.systemTicker; //the Ticker callback that performs routines like updating the display.\n uBit.MessageBus; //The message bus where events are fired.\n uBit.display; //The display object for the LED matrix.\n uBit.buttonA; //The buttonA object for button a.\n uBit.buttonB; //The buttonB object for button b.\n uBit.resetButton; //The resetButton used for soft resets.\n uBit.accelerometer; //The object that represents the inbuilt accelerometer\n uBit.compass; //The object that represents the inbuilt compass(magnetometer)\n uBit.io.P*; //Where P* is P0 to P16, P19 \n P20 on the edge connector\n\n\n\n\n\ninit\n\n\n\n\nvoid\n init()\n\n\nDescription\n\n\nPost constructor initialisation method. After  main()\n\n\nExample\n\n\n uBit.init();\n\n\n\n\n\ngetName\n\n\n\n\nManagedString\n getName()\n\n\nDescription\n\n\nReturn the friendly name for this device.\n\n\nReturns\n\n\nA string representing the friendly name of this device.\n\n\ngetSerial\n\n\n\n\nManagedString\n getSerial()\n\n\nDescription\n\n\nReturn the serial number of this device.\n\n\nReturns\n\n\nA string representing the serial number of this device.\n\n\nreset\n\n\n\n\nvoid\n reset()\n\n\nDescription\n\n\nWill reset the micro:bit when called.\n\n\nExample\n\n\n uBit.reset();\n\n\n\n\n\nsleep\n\n\n\n\nint\n sleep( \nint\n milliseconds)\n\n\nDescription\n\n\nDelay for the given amount of time. If the scheduler is running, this will deschedule the current fiber and perform a power efficent, concurrent sleep operation. If the scheduler is disabled or we're running in an interrupt context, this will revert to a busy wait.\n\n\nParameters\n\n\n\n\nint\n \nmilliseconds\n - the amount of time, in ms, to wait for. This number cannot be negative.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER milliseconds is less than zero.\n\n\nExample\n\n\n uBit.sleep(20); //sleep for 20ms\n\n\n\n\n\n\n\nNote\n\n\nValues of 6 and below tend to lose resolution - do you really need to sleep for this short amount of time?\n\n\n\n\nseedRandom\n\n\n\n\nvoid\n seedRandom()\n\n\nDescription\n\n\nSeed the pseudo random number generator using the hardware generator.\n\n\nExample\n\n\n uBit.seedRandom();\n\n\n\n\n\n\n\nvoid\n seedRandom( \nuint32_t\n seed)\n\n\nDescription\n\n\nSeed the pseudo random number generator using the given value.\n\n\nParameters\n\n\n\n\nuint32_t\n \nseed\n - The 32-bit value to seed the generator with.\n\n\n\n\nExample\n\n\n uBit.seedRandom(0x12345678);\n\n\n\n\n\nrandom\n\n\n\n\nint\n random( \nint\n max)\n\n\nDescription\n\n\nGenerate a random number in the given range. We use the NRF51822 in built random number generator here TODO: Determine if we want to, given its relatively high power consumption!\n\n\nParameters\n\n\n\n\nint\n \nmax\n - the upper range to generate a number for. This number cannot be negative\n\n\n\n\nReturns\n\n\nA random, natural number between 0 and the max-1. Or MICROBIT_INVALID_PARAMETER if max is \n= 0.\n\n\nExample\n\n\n uBit.random(200); //a number between 0 and 199\n\n\n\n\n\nsystemTasks\n\n\n\n\nvoid\n systemTasks()\n\n\nDescription\n\n\nSystem tasks to be executed by the idle thread when the Micro:Bit isn't busy or when data needs to be read.\n\n\naddSystemComponent\n\n\n\n\nint\n addSystemComponent( \nMicroBitComponent  *\n component)\n\n\nDescription\n\n\nadd a component to the array of system components which invocate the systemTick member function during a systemTick\n\n\nParameters\n\n\n\n\nMicroBitComponent  \n \ncomponent* - The component to add.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success. MICROBIT_NO_RESOURCES is returned if further components cannot be supported.\n\n\n\n\nNote\n\n\nthis will be converted into a dynamic list of components\n\n\n\n\nremoveSystemComponent\n\n\n\n\nint\n removeSystemComponent( \nMicroBitComponent  *\n component)\n\n\nDescription\n\n\nremove a component from the array of system components\n\n\nParameters\n\n\n\n\nMicroBitComponent  \n \ncomponent* - The component to remove.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success. MICROBIT_INVALID_PARAMETER is returned if the given component has not been previous added.\n\n\n\n\nNote\n\n\nthis will be converted into a dynamic list of components\n\n\n\n\naddIdleComponent\n\n\n\n\nint\n addIdleComponent( \nMicroBitComponent  *\n component)\n\n\nDescription\n\n\nadd a component to the array of of idle thread components. isIdleCallbackNeeded is polled during a systemTick to determine if the idle thread should jump to the front of the queue\n\n\nParameters\n\n\n\n\nMicroBitComponent  \n \ncomponent* - The component to add.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success. MICROBIT_NO_RESOURCES is returned if further components cannot be supported.\n\n\n\n\nNote\n\n\nthis will be converted into a dynamic list of components\n\n\n\n\nremoveIdleComponent\n\n\n\n\nint\n removeIdleComponent( \nMicroBitComponent  *\n component)\n\n\nDescription\n\n\nremove a component from the array of idle thread components\n\n\nParameters\n\n\n\n\nMicroBitComponent  \n \ncomponent* - The component to remove.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success. MICROBIT_INVALID_PARAMETER is returned if the given component has not been previous added.\n\n\n\n\nNote\n\n\nthis will be converted into a dynamic list of components\n\n\n\n\nsetTickPeriod\n\n\n\n\nint\n setTickPeriod( \nint\n speedMs)\n\n\nParameters\n\n\n\n\nint\n \nspeedMs\n\n\n\n\ngetTickPeriod\n\n\n\n\nint\n getTickPeriod()\n\n\nsystemTime\n\n\n\n\nunsigned long\n systemTime()\n\n\nDescription\n\n\nDetermine the time since this  MicroBit\n\n\nReturns\n\n\nThe time since the last reset, in milliseconds. This will result in overflow after 1.6 months. TODO: handle overflow case.\n\n\nsystemVersion\n\n\n\n\nconst char *\n systemVersion()\n\n\nDescription\n\n\nDetermine the version of the micro:bit runtime currently in use.\n\n\nReturns\n\n\nA textual description of the currentlt executing micro:bit runtime. TODO: handle overflow case.\n\n\npanic\n\n\n\n\nvoid\n panic()\n\n\nDescription\n\n\nTriggers a microbit panic where an infinite loop will occur swapping between the panicFace and statusCode if provided.\n\n\n\nvoid\n panic( \nint\n statusCode)\n\n\nDescription\n\n\nTriggers a microbit panic where an infinite loop will occur swapping between the panicFace and statusCode if provided.\n\n\nParameters\n\n\n\n\nint\n \nstatusCode\n - the status code of the associated error. Status codes must be in the range 0-255.", 
            "title": "uBit"
        }, 
        {
            "location": "/ubit/#ubit", 
            "text": "", 
            "title": "uBit"
        }, 
        {
            "location": "/ubit/#overview", 
            "text": "uBit is the global singleton provided by the runtime and is an instance of the\nMicroBit class.  The MicroBit class has a number of member variables, that operate as device drivers\nto control the various features of the micro:bit.   uBit { \n    .i2c , \n    .serial , \n    .MessageBus , \n    .buttonA , \n    .buttonB , \n    .buttonAB , \n    .display , \n    .accelerometer , \n    .compass , \n    .thermometer , \n    .io , \n    .ble , \n    .BLEManager , \n    .radio , \n   }   For example, if we needed to scroll some text across the display, we simply would\nwrite the following:  uBit.display.scroll( HELLO! );  Similarly, if we wanted to send some text over serial, we could write the following\ncode:  for(int i = 3; i   0; i--)\n{\n    uBit.serial.printf( %d... , i);\n    uBit.sleep(1000);\n}\n\nuBit.serial.sendString( Code! );  uBit also provides a number of utility functions that allow the plug and play\nof additional components that developers may create. These are namely  addSystemComponent() \nand  addIdleComponent() .  Read more about how to plug your own device drivers into the runtime.  The runtime also contains a scheduler, which uses lightweight threads (called fibers)\nto control the rate of execution.  To place the current fiber into a power efficient  sleep  write the following:  // where X is an integer in milliseconds for the amount of time you would like to sleep for.\nuBit.sleep(X);  Read more about the scheduler.", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/#message-bus-id", 
            "text": "None", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/#message-bus-events", 
            "text": "None", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/#microbit", 
            "text": "", 
            "title": "MicroBit()"
        }, 
        {
            "location": "/ubit/#description", 
            "text": "Constructor. Create a representation of a  MicroBit MicroBitMessageBus", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#example", 
            "text": "uBit.systemTicker; //the Ticker callback that performs routines like updating the display.\n uBit.MessageBus; //The message bus where events are fired.\n uBit.display; //The display object for the LED matrix.\n uBit.buttonA; //The buttonA object for button a.\n uBit.buttonB; //The buttonB object for button b.\n uBit.resetButton; //The resetButton used for soft resets.\n uBit.accelerometer; //The object that represents the inbuilt accelerometer\n uBit.compass; //The object that represents the inbuilt compass(magnetometer)\n uBit.io.P*; //Where P* is P0 to P16, P19   P20 on the edge connector", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#init", 
            "text": "", 
            "title": "init"
        }, 
        {
            "location": "/ubit/#void-init", 
            "text": "", 
            "title": "void init()"
        }, 
        {
            "location": "/ubit/#description_1", 
            "text": "Post constructor initialisation method. After  main()", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#example_1", 
            "text": "uBit.init();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#getname", 
            "text": "", 
            "title": "getName"
        }, 
        {
            "location": "/ubit/#managedstring-getname", 
            "text": "", 
            "title": "ManagedString getName()"
        }, 
        {
            "location": "/ubit/#description_2", 
            "text": "Return the friendly name for this device.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#returns", 
            "text": "A string representing the friendly name of this device.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#getserial", 
            "text": "", 
            "title": "getSerial"
        }, 
        {
            "location": "/ubit/#managedstring-getserial", 
            "text": "", 
            "title": "ManagedString getSerial()"
        }, 
        {
            "location": "/ubit/#description_3", 
            "text": "Return the serial number of this device.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#returns_1", 
            "text": "A string representing the serial number of this device.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#reset", 
            "text": "", 
            "title": "reset"
        }, 
        {
            "location": "/ubit/#void-reset", 
            "text": "", 
            "title": "void reset()"
        }, 
        {
            "location": "/ubit/#description_4", 
            "text": "Will reset the micro:bit when called.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#example_2", 
            "text": "uBit.reset();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#sleep", 
            "text": "", 
            "title": "sleep"
        }, 
        {
            "location": "/ubit/#int-sleep-int-milliseconds", 
            "text": "", 
            "title": "int sleep( int milliseconds)"
        }, 
        {
            "location": "/ubit/#description_5", 
            "text": "Delay for the given amount of time. If the scheduler is running, this will deschedule the current fiber and perform a power efficent, concurrent sleep operation. If the scheduler is disabled or we're running in an interrupt context, this will revert to a busy wait.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters", 
            "text": "int   milliseconds  - the amount of time, in ms, to wait for. This number cannot be negative.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#returns_2", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER milliseconds is less than zero.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#example_3", 
            "text": "uBit.sleep(20); //sleep for 20ms   Note  Values of 6 and below tend to lose resolution - do you really need to sleep for this short amount of time?", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#seedrandom", 
            "text": "", 
            "title": "seedRandom"
        }, 
        {
            "location": "/ubit/#void-seedrandom", 
            "text": "", 
            "title": "void seedRandom()"
        }, 
        {
            "location": "/ubit/#description_6", 
            "text": "Seed the pseudo random number generator using the hardware generator.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#example_4", 
            "text": "uBit.seedRandom();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#void-seedrandom-uint32_t-seed", 
            "text": "", 
            "title": "void seedRandom( uint32_t seed)"
        }, 
        {
            "location": "/ubit/#description_7", 
            "text": "Seed the pseudo random number generator using the given value.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_1", 
            "text": "uint32_t   seed  - The 32-bit value to seed the generator with.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#example_5", 
            "text": "uBit.seedRandom(0x12345678);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#random", 
            "text": "", 
            "title": "random"
        }, 
        {
            "location": "/ubit/#int-random-int-max", 
            "text": "", 
            "title": "int random( int max)"
        }, 
        {
            "location": "/ubit/#description_8", 
            "text": "Generate a random number in the given range. We use the NRF51822 in built random number generator here TODO: Determine if we want to, given its relatively high power consumption!", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_2", 
            "text": "int   max  - the upper range to generate a number for. This number cannot be negative", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#returns_3", 
            "text": "A random, natural number between 0 and the max-1. Or MICROBIT_INVALID_PARAMETER if max is  = 0.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#example_6", 
            "text": "uBit.random(200); //a number between 0 and 199", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#systemtasks", 
            "text": "", 
            "title": "systemTasks"
        }, 
        {
            "location": "/ubit/#void-systemtasks", 
            "text": "", 
            "title": "void systemTasks()"
        }, 
        {
            "location": "/ubit/#description_9", 
            "text": "System tasks to be executed by the idle thread when the Micro:Bit isn't busy or when data needs to be read.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#addsystemcomponent", 
            "text": "", 
            "title": "addSystemComponent"
        }, 
        {
            "location": "/ubit/#int-addsystemcomponent-microbitcomponent-component", 
            "text": "", 
            "title": "int addSystemComponent( MicroBitComponent  * component)"
        }, 
        {
            "location": "/ubit/#description_10", 
            "text": "add a component to the array of system components which invocate the systemTick member function during a systemTick", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_3", 
            "text": "MicroBitComponent     component* - The component to add.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#returns_4", 
            "text": "MICROBIT_OK on success. MICROBIT_NO_RESOURCES is returned if further components cannot be supported.   Note  this will be converted into a dynamic list of components", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#removesystemcomponent", 
            "text": "", 
            "title": "removeSystemComponent"
        }, 
        {
            "location": "/ubit/#int-removesystemcomponent-microbitcomponent-component", 
            "text": "", 
            "title": "int removeSystemComponent( MicroBitComponent  * component)"
        }, 
        {
            "location": "/ubit/#description_11", 
            "text": "remove a component from the array of system components", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_4", 
            "text": "MicroBitComponent     component* - The component to remove.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#returns_5", 
            "text": "MICROBIT_OK on success. MICROBIT_INVALID_PARAMETER is returned if the given component has not been previous added.   Note  this will be converted into a dynamic list of components", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#addidlecomponent", 
            "text": "", 
            "title": "addIdleComponent"
        }, 
        {
            "location": "/ubit/#int-addidlecomponent-microbitcomponent-component", 
            "text": "", 
            "title": "int addIdleComponent( MicroBitComponent  * component)"
        }, 
        {
            "location": "/ubit/#description_12", 
            "text": "add a component to the array of of idle thread components. isIdleCallbackNeeded is polled during a systemTick to determine if the idle thread should jump to the front of the queue", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_5", 
            "text": "MicroBitComponent     component* - The component to add.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#returns_6", 
            "text": "MICROBIT_OK on success. MICROBIT_NO_RESOURCES is returned if further components cannot be supported.   Note  this will be converted into a dynamic list of components", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#removeidlecomponent", 
            "text": "", 
            "title": "removeIdleComponent"
        }, 
        {
            "location": "/ubit/#int-removeidlecomponent-microbitcomponent-component", 
            "text": "", 
            "title": "int removeIdleComponent( MicroBitComponent  * component)"
        }, 
        {
            "location": "/ubit/#description_13", 
            "text": "remove a component from the array of idle thread components", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_6", 
            "text": "MicroBitComponent     component* - The component to remove.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#returns_7", 
            "text": "MICROBIT_OK on success. MICROBIT_INVALID_PARAMETER is returned if the given component has not been previous added.   Note  this will be converted into a dynamic list of components", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#settickperiod", 
            "text": "", 
            "title": "setTickPeriod"
        }, 
        {
            "location": "/ubit/#int-settickperiod-int-speedms", 
            "text": "", 
            "title": "int setTickPeriod( int speedMs)"
        }, 
        {
            "location": "/ubit/#parameters_7", 
            "text": "int   speedMs", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#gettickperiod", 
            "text": "", 
            "title": "getTickPeriod"
        }, 
        {
            "location": "/ubit/#int-gettickperiod", 
            "text": "", 
            "title": "int getTickPeriod()"
        }, 
        {
            "location": "/ubit/#systemtime", 
            "text": "", 
            "title": "systemTime"
        }, 
        {
            "location": "/ubit/#unsigned-long-systemtime", 
            "text": "", 
            "title": "unsigned long systemTime()"
        }, 
        {
            "location": "/ubit/#description_14", 
            "text": "Determine the time since this  MicroBit", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#returns_8", 
            "text": "The time since the last reset, in milliseconds. This will result in overflow after 1.6 months. TODO: handle overflow case.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#systemversion", 
            "text": "", 
            "title": "systemVersion"
        }, 
        {
            "location": "/ubit/#const-char-systemversion", 
            "text": "", 
            "title": "const char * systemVersion()"
        }, 
        {
            "location": "/ubit/#description_15", 
            "text": "Determine the version of the micro:bit runtime currently in use.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#returns_9", 
            "text": "A textual description of the currentlt executing micro:bit runtime. TODO: handle overflow case.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#panic", 
            "text": "", 
            "title": "panic"
        }, 
        {
            "location": "/ubit/#void-panic", 
            "text": "", 
            "title": "void panic()"
        }, 
        {
            "location": "/ubit/#description_16", 
            "text": "Triggers a microbit panic where an infinite loop will occur swapping between the panicFace and statusCode if provided.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#void-panic-int-statuscode", 
            "text": "", 
            "title": "void panic( int statusCode)"
        }, 
        {
            "location": "/ubit/#description_17", 
            "text": "Triggers a microbit panic where an infinite loop will occur swapping between the panicFace and statusCode if provided.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_8", 
            "text": "int   statusCode  - the status code of the associated error. Status codes must be in the range 0-255.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/i2c/", 
            "text": "uBit.i2c\n\n\nOverview\n\n\ni2c is a very common, widely used protocol for communicating with other devices\nover a wire. i2c uses a very simple addressing scheme to access these other\ndevices.\n\n\nOnboard the micro:bit itself there are two components which use i2c bus as a communication\nmechanism, the \naccelerometer\n and the \ncompass\n.\n\n\nAs well as being used internally, the i2c bus is exposed on two edge connector\npins, P19 and P20. This means other accessories that use i2c to communicate\ncan be used in conjunction with the micro:bit.\n\n\nMessage Bus ID\n\n\n\n\nNone.\n\n\n\n\nMessage Bus Events\n\n\n\n\nNone.\n\n\n\n\nAPI", 
            "title": "i2c"
        }, 
        {
            "location": "/ubit/i2c/#ubiti2c", 
            "text": "", 
            "title": "uBit.i2c"
        }, 
        {
            "location": "/ubit/i2c/#overview", 
            "text": "i2c is a very common, widely used protocol for communicating with other devices\nover a wire. i2c uses a very simple addressing scheme to access these other\ndevices.  Onboard the micro:bit itself there are two components which use i2c bus as a communication\nmechanism, the  accelerometer  and the  compass .  As well as being used internally, the i2c bus is exposed on two edge connector\npins, P19 and P20. This means other accessories that use i2c to communicate\ncan be used in conjunction with the micro:bit.", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/i2c/#message-bus-id", 
            "text": "None.", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/i2c/#message-bus-events", 
            "text": "None.", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/i2c/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/storage/", 
            "text": "uBit.storage\n\n\nOverview\n\n\nMessage Bus ID\n\n\n\n\nNone.\n\n\n\n\nMessage Bus Events\n\n\n\n\nNone.\n\n\n\n\nAPI", 
            "title": "storage"
        }, 
        {
            "location": "/ubit/storage/#ubitstorage", 
            "text": "", 
            "title": "uBit.storage"
        }, 
        {
            "location": "/ubit/storage/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/storage/#message-bus-id", 
            "text": "None.", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/storage/#message-bus-events", 
            "text": "None.", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/storage/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/serial/", 
            "text": "uBit.serial\n\n\nOverview\n\n\nMessage Bus ID\n\n\nMessage Bus Events\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitSerial( \nPinName\n tx,  \nPinName\n rx)\n\n\nDescription\n\n\nConstructor. Create an instance of  MicroBitSerial MicroBitSerial\n\n\nParameters\n\n\n\n\nPinName\n \ntx\n\n\nPinName\n \nrx\n\n\n\n\nExample\n\n\n MicroBitSerial serial(USBTX, USBRX); \n\n\n\n\n\n\n\nNote\n\n\nthe default baud rate is 115200 \n\n\n\n\nsendString\n\n\n\n\nvoid\n sendString( \nManagedString\n s)\n\n\nDescription\n\n\nSends a managed string over serial.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - the  ManagedString  to send\n\n\n\n\nExample\n\n\n uBit.serial.printString(\nabc123\n); \n\n\n\n\n\nreadString\n\n\n\n\nManagedString\n readString()\n\n\nDescription\n\n\nReads a  ManagedString\n\n\nExample\n\n\n uBit.serial.readString(); \n\n\n\n\n\n\n\nNote\n\n\nthis member function will wait until either the buffer is full, or a\n\n is received \n\n\n\n\n\n\nManagedString\n readString( \nint\n len)\n\n\nDescription\n\n\nReads a  ManagedString\n\n\nParameters\n\n\n\n\nint\n \nlen\n - the buffer size for the string, default is defined by MICROBIT_SERIAL_BUFFER_SIZE\n\n\n\n\nExample\n\n\n uBit.serial.readString(); \n\n\n\n\n\n\n\nNote\n\n\nthis member function will wait until either the buffer is full, or a\n\n is received \n\n\n\n\nsendImage\n\n\n\n\nvoid\n sendImage( \nMicroBitImage\n i)\n\n\nDescription\n\n\nSends a  MicroBitImage\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - the instance of  MicroBitImage  you would like to send.\n\n\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n uBit.serial.sendImage(i); \n\n\n\n\n\nreadImage\n\n\n\n\nMicroBitImage\n readImage( \nint\n width,  \nint\n height)\n\n\nDescription\n\n\nReads a  MicroBitImage\n\n\nParameters\n\n\n\n\nint\n \nwidth\n\n\nint\n \nheight\n\n\n\n\nReturns\n\n\na  MicroBitImage  with the format described over serial\n\n\nExample\n\n\n MicroBitImage i = uBit.serial.readImage(2,2); \n\n\n\n\n\n\n\nNote\n\n\nthis will finish once the dimensions are met.\n\n\n\n\nsendDisplayState\n\n\n\n\nvoid\n sendDisplayState()\n\n\nDescription\n\n\nSends the current pixel values, byte-per-pixel, over serial\n\n\nExample\n\n\n uBit.serial.sendDisplayState(); \n\n\n\n\n\nreadDisplayState\n\n\n\n\nvoid\n readDisplayState()\n\n\nDescription\n\n\nReads pixel values, byte-per-pixel, from serial, and sets the display.\n\n\nExample\n\n\n uBit.serial.readDisplayState();", 
            "title": "serial"
        }, 
        {
            "location": "/ubit/serial/#ubitserial", 
            "text": "", 
            "title": "uBit.serial"
        }, 
        {
            "location": "/ubit/serial/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/serial/#message-bus-id", 
            "text": "", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/serial/#message-bus-events", 
            "text": "", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/serial/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/serial/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/serial/#microbitserial-pinname-tx-pinname-rx", 
            "text": "", 
            "title": "MicroBitSerial( PinName tx,  PinName rx)"
        }, 
        {
            "location": "/ubit/serial/#description", 
            "text": "Constructor. Create an instance of  MicroBitSerial MicroBitSerial", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters", 
            "text": "PinName   tx  PinName   rx", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#example", 
            "text": "MicroBitSerial serial(USBTX, USBRX);    Note  the default baud rate is 115200", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/serial/#sendstring", 
            "text": "", 
            "title": "sendString"
        }, 
        {
            "location": "/ubit/serial/#void-sendstring-managedstring-s", 
            "text": "", 
            "title": "void sendString( ManagedString s)"
        }, 
        {
            "location": "/ubit/serial/#description_1", 
            "text": "Sends a managed string over serial.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_1", 
            "text": "ManagedString   s  - the  ManagedString  to send", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#example_1", 
            "text": "uBit.serial.printString( abc123 );", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/serial/#readstring", 
            "text": "", 
            "title": "readString"
        }, 
        {
            "location": "/ubit/serial/#managedstring-readstring", 
            "text": "", 
            "title": "ManagedString readString()"
        }, 
        {
            "location": "/ubit/serial/#description_2", 
            "text": "Reads a  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#example_2", 
            "text": "uBit.serial.readString();    Note  this member function will wait until either the buffer is full, or a \n is received", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/serial/#managedstring-readstring-int-len", 
            "text": "", 
            "title": "ManagedString readString( int len)"
        }, 
        {
            "location": "/ubit/serial/#description_3", 
            "text": "Reads a  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_2", 
            "text": "int   len  - the buffer size for the string, default is defined by MICROBIT_SERIAL_BUFFER_SIZE", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#example_3", 
            "text": "uBit.serial.readString();    Note  this member function will wait until either the buffer is full, or a \n is received", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/serial/#sendimage", 
            "text": "", 
            "title": "sendImage"
        }, 
        {
            "location": "/ubit/serial/#void-sendimage-microbitimage-i", 
            "text": "", 
            "title": "void sendImage( MicroBitImage i)"
        }, 
        {
            "location": "/ubit/serial/#description_4", 
            "text": "Sends a  MicroBitImage", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_3", 
            "text": "MicroBitImage   i  - the instance of  MicroBitImage  you would like to send.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#example_4", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n uBit.serial.sendImage(i);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/serial/#readimage", 
            "text": "", 
            "title": "readImage"
        }, 
        {
            "location": "/ubit/serial/#microbitimage-readimage-int-width-int-height", 
            "text": "", 
            "title": "MicroBitImage readImage( int width,  int height)"
        }, 
        {
            "location": "/ubit/serial/#description_5", 
            "text": "Reads a  MicroBitImage", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_4", 
            "text": "int   width  int   height", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns", 
            "text": "a  MicroBitImage  with the format described over serial", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#example_5", 
            "text": "MicroBitImage i = uBit.serial.readImage(2,2);    Note  this will finish once the dimensions are met.", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/serial/#senddisplaystate", 
            "text": "", 
            "title": "sendDisplayState"
        }, 
        {
            "location": "/ubit/serial/#void-senddisplaystate", 
            "text": "", 
            "title": "void sendDisplayState()"
        }, 
        {
            "location": "/ubit/serial/#description_6", 
            "text": "Sends the current pixel values, byte-per-pixel, over serial", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#example_6", 
            "text": "uBit.serial.sendDisplayState();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/serial/#readdisplaystate", 
            "text": "", 
            "title": "readDisplayState"
        }, 
        {
            "location": "/ubit/serial/#void-readdisplaystate", 
            "text": "", 
            "title": "void readDisplayState()"
        }, 
        {
            "location": "/ubit/serial/#description_7", 
            "text": "Reads pixel values, byte-per-pixel, from serial, and sets the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#example_7", 
            "text": "uBit.serial.readDisplayState();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/messageBus/", 
            "text": "uBit.messageBus\n\n\nOverview\n\n\nMessage Bus ID\n\n\nMessage Bus Events\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitMessageBus()\n\n\nDescription\n\n\nDefault constructor. Anticipating only one MessageBus per device, as filtering is handled within the class.\n\n\nsend\n\n\n\n\nvoid\n send( \nMicroBitEvent\n evt)\n\n\nDescription\n\n\nQueues the given event to be sent to all registered recipients.\n\n\nParameters\n\n\n\n\nMicroBitEvent\n \nevt\n\n\n\n\nExample\n\n\n MicroBitEvent evt(id,MICROBIT_BUTTON_EVT_DOWN,ticks,false);\n evt.fire();\n //OR YOU CAN DO THIS...\n MicroBitEvent evt(id,MICROBIT_BUTTON_EVT_DOWN);\n\n\n\n\n\nprocess\n\n\n\n\nint\n process( \nMicroBitEvent  \n evt)\n\n\nDescription\n\n\nInternal function, used to deliver the given event to all relevant recipients. Normally, this is called once an event has been removed from the event queue.\n\n\nParameters\n\n\n\n\nMicroBitEvent  \n \nevt\n - The event to send.\n\n\n\n\nReturns\n\n\n1 if all matching listeners were processed, 0 if further processing is required.\n\n\n\nint\n process( \nMicroBitEvent  \n evt,  \nbool\n urgent)\n\n\nDescription\n\n\nInternal function, used to deliver the given event to all relevant recipients. Normally, this is called once an event has been removed from the event queue.\n\n\nParameters\n\n\n\n\nMicroBitEvent  \n \nevt\n - The event to send.\n\n\nbool\n \nurgent\n - The type of listeners to process (optional). If set to true, only listeners defined as urgent and non-blocking will be processed otherwise, all other (standard) listeners will be processed.\n\n\n\n\nReturns\n\n\n1 if all matching listeners were processed, 0 if further processing is required.\n\n\nlisten\n\n\n\n\nint\n listen( \nint\n id,  \nint\n value,  \nvoid(*)( MicroBitEvent )\n handler)\n\n\nDescription\n\n\nRegister a listener function.\n\n\nParameters\n\n\n\n\nint\n \nid\n - The source of messages to listen for. Events sent from any other IDs will be filtered. Use MICROBIT_ID_ANY to receive events from all components.\n\n\nint\n \nvalue\n - The value of messages to listen for. Events with any other values will be filtered. Use MICROBIT_EVT_ANY to receive events of any value.\n\n\nvoid(\n)( MicroBitEvent )\n \nhandler* - The function to call when an event is received.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success MICROBIT_INVALID_PARAMETER\n\n\nExample\n\n\n void onButtonBClick()\n {\n //do something\n }\n uBit.MessageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonBClick); // call function when ever a click event is detected.\n\n\n\n\n\n\n\nint\n listen( \nint\n id,  \nint\n value,  \nvoid(*)( MicroBitEvent )\n handler,  \nuint16_t\n flags)\n\n\nDescription\n\n\nRegister a listener function.\n\n\nParameters\n\n\n\n\nint\n \nid\n - The source of messages to listen for. Events sent from any other IDs will be filtered. Use MICROBIT_ID_ANY to receive events from all components.\n\n\nint\n \nvalue\n - The value of messages to listen for. Events with any other values will be filtered. Use MICROBIT_EVT_ANY to receive events of any value.\n\n\nvoid(\n)( MicroBitEvent )\n \nhandler* - The function to call when an event is received.\n\n\nuint16_t\n \nflags\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success MICROBIT_INVALID_PARAMETER\n\n\nExample\n\n\n void onButtonBClick()\n {\n //do something\n }\n uBit.MessageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonBClick); // call function when ever a click event is detected.\n\n\n\n\n\n\n\nint\n listen( \nint\n id,  \nint\n value,  \nvoid(\n)( MicroBitEvent , void \n)\n handler,  \nvoid *\n arg)\n\n\nDescription\n\n\nRegister a listener function.\n\n\nParameters\n\n\n\n\nint\n \nid\n - The source of messages to listen for. Events sent from any other IDs will be filtered. Use MICROBIT_ID_ANY to receive events from all components.\n\n\nint\n \nvalue\n - The value of messages to listen for. Events with any other values will be filtered. Use MICROBIT_EVT_ANY to receive events of any value.\n\n\nvoid(\n)( MicroBitEvent , void \n)\n \nhandler\n\n\nvoid \n \narg*\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success MICROBIT_INVALID_PARAMETER\n\n\nExample\n\n\n void onButtonBClick(void *arg)\n {\n //do something\n }\n uBit.MessageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonBClick); // call function when ever a click event is detected.\n\n\n\n\n\n\n\nint\n listen( \nint\n id,  \nint\n value,  \nvoid(\n)( MicroBitEvent , void \n)\n handler,  \nvoid *\n arg,  \nuint16_t\n flags)\n\n\nDescription\n\n\nRegister a listener function.\n\n\nParameters\n\n\n\n\nint\n \nid\n - The source of messages to listen for. Events sent from any other IDs will be filtered. Use MICROBIT_ID_ANY to receive events from all components.\n\n\nint\n \nvalue\n - The value of messages to listen for. Events with any other values will be filtered. Use MICROBIT_EVT_ANY to receive events of any value.\n\n\nvoid(\n)( MicroBitEvent , void \n)\n \nhandler\n\n\nvoid \n \narg*\n\n\nuint16_t\n \nflags\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success MICROBIT_INVALID_PARAMETER\n\n\nExample\n\n\n void onButtonBClick(void *arg)\n {\n //do something\n }\n uBit.MessageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonBClick); // call function when ever a click event is detected.\n\n\n\n\n\n\n\nint\n listen( \ntypename T\n ,  \nuint16_t\n id,  \nuint16_t\n value,  \nT \n object,  \nvoid(T::\n)( MicroBitEvent )\n handler)\n\n\nDescription\n\n\nRegister a listener function.\n\n\nParameters\n\n\n\n\ntypename T\n **\n\n\nuint16_t\n \nid\n - The source of messages to listen for. Events sent from any other IDs will be filtered. Use MICROBIT_ID_ANY to receive events from all components.\n\n\nuint16_t\n \nvalue\n - The value of messages to listen for. Events with any other values will be filtered. Use MICROBIT_EVT_ANY to receive events of any value.\n\n\nT \n \nobject*\n\n\nvoid(T::\n)( MicroBitEvent )\n \nhandler*\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success MICROBIT_INVALID_PARAMETER\n\n\nExample\n\n\n void SomeClass::onButtonBClick()\n {\n //do something\n }\n\n SomeClass s = new SomeClass();\n uBit.MessageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, s, \nSomeClass::onButtonBClick);\n\n\n\n\n\n\n\nint\n listen( \ntypename T\n ,  \nuint16_t\n id,  \nuint16_t\n value,  \nT \n object,  \nvoid(T::\n)( MicroBitEvent )\n handler,  \nuint16_t\n flags)\n\n\nDescription\n\n\nRegister a listener function.\n\n\nParameters\n\n\n\n\ntypename T\n **\n\n\nuint16_t\n \nid\n - The source of messages to listen for. Events sent from any other IDs will be filtered. Use MICROBIT_ID_ANY to receive events from all components.\n\n\nuint16_t\n \nvalue\n - The value of messages to listen for. Events with any other values will be filtered. Use MICROBIT_EVT_ANY to receive events of any value.\n\n\nT \n \nobject*\n\n\nvoid(T::\n)( MicroBitEvent )\n \nhandler*\n\n\nuint16_t\n \nflags\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success MICROBIT_INVALID_PARAMETER\n\n\nExample\n\n\n void SomeClass::onButtonBClick()\n {\n //do something\n }\n\n SomeClass s = new SomeClass();\n uBit.MessageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, s, \nSomeClass::onButtonBClick);\n\n\n\n\n\nignore\n\n\n\n\nint\n ignore( \nint\n id,  \nint\n value,  \nvoid(*)( MicroBitEvent )\n handler)\n\n\nDescription\n\n\nUnregister a listener function. Listners are identified by the Event ID, Event VALUE and handler registered using  listen()\n\n\nParameters\n\n\n\n\nint\n \nid\n - The Event ID used to register the listener.\n\n\nint\n \nvalue\n - The Event VALUE used to register the listener.\n\n\nvoid(\n)( MicroBitEvent )\n \nhandler* - The function used to register the listener.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success MICROBIT_INVALID_PARAMETER\n\n\nExample\n\n\n void onButtonBClick()\n {\n //do something\n }\n\n uBit.MessageBus.ignore(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonBClick);\n\n\n\n\n\n\n\nint\n ignore( \nint\n id,  \nint\n value,  \nvoid(\n)( MicroBitEvent , void \n)\n handler)\n\n\nDescription\n\n\nUnregister a listener function. Listners are identified by the Event ID, Event VALUE and handler registered using  listen()\n\n\nParameters\n\n\n\n\nint\n \nid\n - The Event ID used to register the listener.\n\n\nint\n \nvalue\n - The Event VALUE used to register the listener.\n\n\nvoid(\n)( MicroBitEvent , void \n)\n \nhandler\n - The function used to register the listener.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success MICROBIT_INVALID_PARAMETER\n\n\nExample\n\n\n void onButtonBClick(void *arg)\n {\n //do something\n }\n\n uBit.MessageBus.ignore(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonBClick);\n\n\n\n\n\n\n\nint\n ignore( \ntypename T\n ,  \nuint16_t\n id,  \nuint16_t\n value,  \nT \n object,  \nvoid(T::\n)( MicroBitEvent )\n handler)\n\n\nDescription\n\n\nUnregister a listener function. Listners are identified by the Event ID, Event VALUE and handler registered using  listen()\n\n\nParameters\n\n\n\n\ntypename T\n **\n\n\nuint16_t\n \nid\n - The Event ID used to register the listener.\n\n\nuint16_t\n \nvalue\n - The Event VALUE used to register the listener.\n\n\nT \n \nobject*\n\n\nvoid(T::\n)( MicroBitEvent )\n \nhandler* - The function used to register the listener.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success MICROBIT_INVALID_PARAMETER\n\n\nExample\n\n\n void SomeClass::onButtonBClick()\n {\n //do something\n }\n\n SomeClass s = new SomeClass();\n uBit.MessageBus.ignore(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, s, \nSomeClass::onButtonBClick);\n\n\n\n\n\nelementAt\n\n\n\n\nMicroBitListener\n elementAt( \nint\n n)\n\n\nDescription\n\n\nReturns the microBitListener with the given position in our list.  MicroBitListener\n\n\nParameters\n\n\n\n\nint\n \nn\n - The position in the list to return.\n\n\n\n\nReturns\n\n\nthe  MicroBitListener  at postion n in the list, or NULL if the position is invalid.\n\n\n~MicroBitMessageBus\n\n\n\n\n~MicroBitMessageBus()\n\n\nDescription\n\n\nDestructor for  MicroBitMessageBus", 
            "title": "messageBus"
        }, 
        {
            "location": "/ubit/messageBus/#ubitmessagebus", 
            "text": "", 
            "title": "uBit.messageBus"
        }, 
        {
            "location": "/ubit/messageBus/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/messageBus/#message-bus-id", 
            "text": "", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/messageBus/#message-bus-events", 
            "text": "", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/messageBus/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/messageBus/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/messageBus/#microbitmessagebus", 
            "text": "", 
            "title": "MicroBitMessageBus()"
        }, 
        {
            "location": "/ubit/messageBus/#description", 
            "text": "Default constructor. Anticipating only one MessageBus per device, as filtering is handled within the class.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#send", 
            "text": "", 
            "title": "send"
        }, 
        {
            "location": "/ubit/messageBus/#void-send-microbitevent-evt", 
            "text": "", 
            "title": "void send( MicroBitEvent evt)"
        }, 
        {
            "location": "/ubit/messageBus/#description_1", 
            "text": "Queues the given event to be sent to all registered recipients.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters", 
            "text": "MicroBitEvent   evt", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#example", 
            "text": "MicroBitEvent evt(id,MICROBIT_BUTTON_EVT_DOWN,ticks,false);\n evt.fire();\n //OR YOU CAN DO THIS...\n MicroBitEvent evt(id,MICROBIT_BUTTON_EVT_DOWN);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/messageBus/#process", 
            "text": "", 
            "title": "process"
        }, 
        {
            "location": "/ubit/messageBus/#int-process-microbitevent-evt", 
            "text": "", 
            "title": "int process( MicroBitEvent  &amp; evt)"
        }, 
        {
            "location": "/ubit/messageBus/#description_2", 
            "text": "Internal function, used to deliver the given event to all relevant recipients. Normally, this is called once an event has been removed from the event queue.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_1", 
            "text": "MicroBitEvent     evt  - The event to send.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns", 
            "text": "1 if all matching listeners were processed, 0 if further processing is required.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#int-process-microbitevent-evt-bool-urgent", 
            "text": "", 
            "title": "int process( MicroBitEvent  &amp; evt,  bool urgent)"
        }, 
        {
            "location": "/ubit/messageBus/#description_3", 
            "text": "Internal function, used to deliver the given event to all relevant recipients. Normally, this is called once an event has been removed from the event queue.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_2", 
            "text": "MicroBitEvent     evt  - The event to send.  bool   urgent  - The type of listeners to process (optional). If set to true, only listeners defined as urgent and non-blocking will be processed otherwise, all other (standard) listeners will be processed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_1", 
            "text": "1 if all matching listeners were processed, 0 if further processing is required.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#listen", 
            "text": "", 
            "title": "listen"
        }, 
        {
            "location": "/ubit/messageBus/#int-listen-int-id-int-value-void-microbitevent-handler", 
            "text": "", 
            "title": "int listen( int id,  int value,  void(*)( MicroBitEvent ) handler)"
        }, 
        {
            "location": "/ubit/messageBus/#description_4", 
            "text": "Register a listener function.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_3", 
            "text": "int   id  - The source of messages to listen for. Events sent from any other IDs will be filtered. Use MICROBIT_ID_ANY to receive events from all components.  int   value  - The value of messages to listen for. Events with any other values will be filtered. Use MICROBIT_EVT_ANY to receive events of any value.  void( )( MicroBitEvent )   handler* - The function to call when an event is received.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_2", 
            "text": "MICROBIT_OK on success MICROBIT_INVALID_PARAMETER", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#example_1", 
            "text": "void onButtonBClick()\n {\n //do something\n }\n uBit.MessageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonBClick); // call function when ever a click event is detected.", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/messageBus/#int-listen-int-id-int-value-void-microbitevent-handler-uint16_t-flags", 
            "text": "", 
            "title": "int listen( int id,  int value,  void(*)( MicroBitEvent ) handler,  uint16_t flags)"
        }, 
        {
            "location": "/ubit/messageBus/#description_5", 
            "text": "Register a listener function.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_4", 
            "text": "int   id  - The source of messages to listen for. Events sent from any other IDs will be filtered. Use MICROBIT_ID_ANY to receive events from all components.  int   value  - The value of messages to listen for. Events with any other values will be filtered. Use MICROBIT_EVT_ANY to receive events of any value.  void( )( MicroBitEvent )   handler* - The function to call when an event is received.  uint16_t   flags", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_3", 
            "text": "MICROBIT_OK on success MICROBIT_INVALID_PARAMETER", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#example_2", 
            "text": "void onButtonBClick()\n {\n //do something\n }\n uBit.MessageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonBClick); // call function when ever a click event is detected.", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/messageBus/#int-listen-int-id-int-value-void-microbitevent-void-handler-void-arg", 
            "text": "", 
            "title": "int listen( int id,  int value,  void()( MicroBitEvent , void ) handler,  void * arg)"
        }, 
        {
            "location": "/ubit/messageBus/#description_6", 
            "text": "Register a listener function.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_5", 
            "text": "int   id  - The source of messages to listen for. Events sent from any other IDs will be filtered. Use MICROBIT_ID_ANY to receive events from all components.  int   value  - The value of messages to listen for. Events with any other values will be filtered. Use MICROBIT_EVT_ANY to receive events of any value.  void( )( MicroBitEvent , void  )   handler  void    arg*", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_4", 
            "text": "MICROBIT_OK on success MICROBIT_INVALID_PARAMETER", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#example_3", 
            "text": "void onButtonBClick(void *arg)\n {\n //do something\n }\n uBit.MessageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonBClick); // call function when ever a click event is detected.", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/messageBus/#int-listen-int-id-int-value-void-microbitevent-void-handler-void-arg-uint16_t-flags", 
            "text": "", 
            "title": "int listen( int id,  int value,  void()( MicroBitEvent , void ) handler,  void * arg,  uint16_t flags)"
        }, 
        {
            "location": "/ubit/messageBus/#description_7", 
            "text": "Register a listener function.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_6", 
            "text": "int   id  - The source of messages to listen for. Events sent from any other IDs will be filtered. Use MICROBIT_ID_ANY to receive events from all components.  int   value  - The value of messages to listen for. Events with any other values will be filtered. Use MICROBIT_EVT_ANY to receive events of any value.  void( )( MicroBitEvent , void  )   handler  void    arg*  uint16_t   flags", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_5", 
            "text": "MICROBIT_OK on success MICROBIT_INVALID_PARAMETER", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#example_4", 
            "text": "void onButtonBClick(void *arg)\n {\n //do something\n }\n uBit.MessageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonBClick); // call function when ever a click event is detected.", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/messageBus/#int-listen-typename-t-uint16_t-id-uint16_t-value-t-object-voidt-microbitevent-handler", 
            "text": "", 
            "title": "int listen( typename T ,  uint16_t id,  uint16_t value,  T  object,  void(T::)( MicroBitEvent ) handler)"
        }, 
        {
            "location": "/ubit/messageBus/#description_8", 
            "text": "Register a listener function.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_7", 
            "text": "typename T  **  uint16_t   id  - The source of messages to listen for. Events sent from any other IDs will be filtered. Use MICROBIT_ID_ANY to receive events from all components.  uint16_t   value  - The value of messages to listen for. Events with any other values will be filtered. Use MICROBIT_EVT_ANY to receive events of any value.  T    object*  void(T:: )( MicroBitEvent )   handler*", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_6", 
            "text": "MICROBIT_OK on success MICROBIT_INVALID_PARAMETER", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#example_5", 
            "text": "void SomeClass::onButtonBClick()\n {\n //do something\n }\n\n SomeClass s = new SomeClass();\n uBit.MessageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, s,  SomeClass::onButtonBClick);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/messageBus/#int-listen-typename-t-uint16_t-id-uint16_t-value-t-object-voidt-microbitevent-handler-uint16_t-flags", 
            "text": "", 
            "title": "int listen( typename T ,  uint16_t id,  uint16_t value,  T  object,  void(T::)( MicroBitEvent ) handler,  uint16_t flags)"
        }, 
        {
            "location": "/ubit/messageBus/#description_9", 
            "text": "Register a listener function.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_8", 
            "text": "typename T  **  uint16_t   id  - The source of messages to listen for. Events sent from any other IDs will be filtered. Use MICROBIT_ID_ANY to receive events from all components.  uint16_t   value  - The value of messages to listen for. Events with any other values will be filtered. Use MICROBIT_EVT_ANY to receive events of any value.  T    object*  void(T:: )( MicroBitEvent )   handler*  uint16_t   flags", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_7", 
            "text": "MICROBIT_OK on success MICROBIT_INVALID_PARAMETER", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#example_6", 
            "text": "void SomeClass::onButtonBClick()\n {\n //do something\n }\n\n SomeClass s = new SomeClass();\n uBit.MessageBus.listen(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, s,  SomeClass::onButtonBClick);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/messageBus/#ignore", 
            "text": "", 
            "title": "ignore"
        }, 
        {
            "location": "/ubit/messageBus/#int-ignore-int-id-int-value-void-microbitevent-handler", 
            "text": "", 
            "title": "int ignore( int id,  int value,  void(*)( MicroBitEvent ) handler)"
        }, 
        {
            "location": "/ubit/messageBus/#description_10", 
            "text": "Unregister a listener function. Listners are identified by the Event ID, Event VALUE and handler registered using  listen()", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_9", 
            "text": "int   id  - The Event ID used to register the listener.  int   value  - The Event VALUE used to register the listener.  void( )( MicroBitEvent )   handler* - The function used to register the listener.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_8", 
            "text": "MICROBIT_OK on success MICROBIT_INVALID_PARAMETER", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#example_7", 
            "text": "void onButtonBClick()\n {\n //do something\n }\n\n uBit.MessageBus.ignore(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonBClick);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/messageBus/#int-ignore-int-id-int-value-void-microbitevent-void-handler", 
            "text": "", 
            "title": "int ignore( int id,  int value,  void()( MicroBitEvent , void ) handler)"
        }, 
        {
            "location": "/ubit/messageBus/#description_11", 
            "text": "Unregister a listener function. Listners are identified by the Event ID, Event VALUE and handler registered using  listen()", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_10", 
            "text": "int   id  - The Event ID used to register the listener.  int   value  - The Event VALUE used to register the listener.  void( )( MicroBitEvent , void  )   handler  - The function used to register the listener.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_9", 
            "text": "MICROBIT_OK on success MICROBIT_INVALID_PARAMETER", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#example_8", 
            "text": "void onButtonBClick(void *arg)\n {\n //do something\n }\n\n uBit.MessageBus.ignore(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, onButtonBClick);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/messageBus/#int-ignore-typename-t-uint16_t-id-uint16_t-value-t-object-voidt-microbitevent-handler", 
            "text": "", 
            "title": "int ignore( typename T ,  uint16_t id,  uint16_t value,  T  object,  void(T::)( MicroBitEvent ) handler)"
        }, 
        {
            "location": "/ubit/messageBus/#description_12", 
            "text": "Unregister a listener function. Listners are identified by the Event ID, Event VALUE and handler registered using  listen()", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_11", 
            "text": "typename T  **  uint16_t   id  - The Event ID used to register the listener.  uint16_t   value  - The Event VALUE used to register the listener.  T    object*  void(T:: )( MicroBitEvent )   handler* - The function used to register the listener.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_10", 
            "text": "MICROBIT_OK on success MICROBIT_INVALID_PARAMETER", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#example_9", 
            "text": "void SomeClass::onButtonBClick()\n {\n //do something\n }\n\n SomeClass s = new SomeClass();\n uBit.MessageBus.ignore(MICROBIT_ID_BUTTON_B, MICROBIT_BUTTON_EVT_CLICK, s,  SomeClass::onButtonBClick);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/messageBus/#elementat", 
            "text": "", 
            "title": "elementAt"
        }, 
        {
            "location": "/ubit/messageBus/#microbitlistener-elementat-int-n", 
            "text": "", 
            "title": "MicroBitListener elementAt( int n)"
        }, 
        {
            "location": "/ubit/messageBus/#description_13", 
            "text": "Returns the microBitListener with the given position in our list.  MicroBitListener", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_12", 
            "text": "int   n  - The position in the list to return.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_11", 
            "text": "the  MicroBitListener  at postion n in the list, or NULL if the position is invalid.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#microbitmessagebus_1", 
            "text": "", 
            "title": "~MicroBitMessageBus"
        }, 
        {
            "location": "/ubit/messageBus/#microbitmessagebus_2", 
            "text": "", 
            "title": "~MicroBitMessageBus()"
        }, 
        {
            "location": "/ubit/messageBus/#description_14", 
            "text": "Destructor for  MicroBitMessageBus", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/button/", 
            "text": "uBit.button[A | B | AB]\n\n\nOverview\n\n\nMessage Bus ID\n\n\nMessage Bus Events\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitButton( \nuint16_t\n id,  \nPinName\n name)\n\n\nDescription\n\n\nConstructor. Create a pin representation with the given ID.  MicroBitButton\n\n\nParameters\n\n\n\n\nuint16_t\n \nid\n - the ID of the new  MicroBitButton  object. \n\n\nPinName\n \nname\n - the physical pin on the processor that this butotn is connected to. \n\n\n\n\nExample\n\n\n buttonA(MICROBIT_ID_BUTTON_A,MICROBIT_PIN_BUTTON_A); //a number between 0 and 200 inclusive \n\n\n\n\n\n\n\nMicroBitButton( \nuint16_t\n id,  \nPinName\n name,  \nMicroBitButtonEventConfiguration\n eventConfiguration)\n\n\nDescription\n\n\nConstructor. Create a pin representation with the given ID.  MicroBitButton\n\n\nParameters\n\n\n\n\nuint16_t\n \nid\n - the ID of the new  MicroBitButton  object. \n\n\nPinName\n \nname\n - the physical pin on the processor that this butotn is connected to. \n\n\nMicroBitButtonEventConfiguration\n \neventConfiguration\n\n\n\n\nExample\n\n\n buttonA(MICROBIT_ID_BUTTON_A,MICROBIT_PIN_BUTTON_A); //a number between 0 and 200 inclusive \n\n\n\n\n\n\n\nMicroBitButton( \nuint16_t\n id,  \nPinName\n name,  \nMicroBitButtonEventConfiguration\n eventConfiguration,  \nPinMode\n mode)\n\n\nDescription\n\n\nConstructor. Create a pin representation with the given ID.  MicroBitButton\n\n\nParameters\n\n\n\n\nuint16_t\n \nid\n - the ID of the new  MicroBitButton  object. \n\n\nPinName\n \nname\n - the physical pin on the processor that this butotn is connected to. \n\n\nMicroBitButtonEventConfiguration\n \neventConfiguration\n\n\nPinMode\n \nmode\n - the configuration of internal pullups/pulldowns, as define in the mbed PinMode class. PullNone by default.\n\n\n\n\nExample\n\n\n buttonA(MICROBIT_ID_BUTTON_A,MICROBIT_PIN_BUTTON_A); //a number between 0 and 200 inclusive \n\n\n\n\n\nisPressed\n\n\n\n\nint\n isPressed()\n\n\nDescription\n\n\nTests if this Button is currently pressed. \n\n\nReturns\n\n\n1 if this button is pressed, 0 otherwise.\n\n\nExample\n\n\n if(uBit.buttonA.isPressed()) \n print(\nPressed!\n); \n\n\n\n\n\nsetEventConfiguration\n\n\n\n\nvoid\n setEventConfiguration( \nMicroBitButtonEventConfiguration\n config)\n\n\nDescription\n\n\nChanges the event configuraiton of this button to the given value. All subsequent events generated by this button will then be informed by this configuraiton.\n\n\nParameters\n\n\n\n\nMicroBitButtonEventConfiguration\n \nconfig\n - The new configuration for this button. Legal values are MICROBIT_BUTTON_ALL_EVENTS or MICROBIT_BUTTON_SIMPLE_EVENTS.\n\n\n\n\nExample\n\n\n // Configure a button to generate all possible events. \n uBit.buttonA.setEventConfiguration(MICROBIT_BUTTON_ALL_EVENTS); \n\n // Configure a button to suppress MICROBIT_BUTTON_EVT_CLICK and MICROBIT_BUTTON_EVT_LONG_CLICK events. \n uBit.buttonA.setEventConfiguration(MICROBIT_BUTTON_SIMPLE_EVENTS); \n\n\n\n\n\n~MicroBitButton\n\n\n\n\n~MicroBitButton()\n\n\nDescription\n\n\nDestructor for  MicroBitButton", 
            "title": "button"
        }, 
        {
            "location": "/ubit/button/#ubitbuttona-b-ab", 
            "text": "", 
            "title": "uBit.button[A | B | AB]"
        }, 
        {
            "location": "/ubit/button/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/button/#message-bus-id", 
            "text": "", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/button/#message-bus-events", 
            "text": "", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/button/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/button/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/button/#microbitbutton-uint16_t-id-pinname-name", 
            "text": "", 
            "title": "MicroBitButton( uint16_t id,  PinName name)"
        }, 
        {
            "location": "/ubit/button/#description", 
            "text": "Constructor. Create a pin representation with the given ID.  MicroBitButton", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/button/#parameters", 
            "text": "uint16_t   id  - the ID of the new  MicroBitButton  object.   PinName   name  - the physical pin on the processor that this butotn is connected to.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/button/#example", 
            "text": "buttonA(MICROBIT_ID_BUTTON_A,MICROBIT_PIN_BUTTON_A); //a number between 0 and 200 inclusive", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/button/#microbitbutton-uint16_t-id-pinname-name-microbitbuttoneventconfiguration-eventconfiguration", 
            "text": "", 
            "title": "MicroBitButton( uint16_t id,  PinName name,  MicroBitButtonEventConfiguration eventConfiguration)"
        }, 
        {
            "location": "/ubit/button/#description_1", 
            "text": "Constructor. Create a pin representation with the given ID.  MicroBitButton", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/button/#parameters_1", 
            "text": "uint16_t   id  - the ID of the new  MicroBitButton  object.   PinName   name  - the physical pin on the processor that this butotn is connected to.   MicroBitButtonEventConfiguration   eventConfiguration", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/button/#example_1", 
            "text": "buttonA(MICROBIT_ID_BUTTON_A,MICROBIT_PIN_BUTTON_A); //a number between 0 and 200 inclusive", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/button/#microbitbutton-uint16_t-id-pinname-name-microbitbuttoneventconfiguration-eventconfiguration-pinmode-mode", 
            "text": "", 
            "title": "MicroBitButton( uint16_t id,  PinName name,  MicroBitButtonEventConfiguration eventConfiguration,  PinMode mode)"
        }, 
        {
            "location": "/ubit/button/#description_2", 
            "text": "Constructor. Create a pin representation with the given ID.  MicroBitButton", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/button/#parameters_2", 
            "text": "uint16_t   id  - the ID of the new  MicroBitButton  object.   PinName   name  - the physical pin on the processor that this butotn is connected to.   MicroBitButtonEventConfiguration   eventConfiguration  PinMode   mode  - the configuration of internal pullups/pulldowns, as define in the mbed PinMode class. PullNone by default.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/button/#example_2", 
            "text": "buttonA(MICROBIT_ID_BUTTON_A,MICROBIT_PIN_BUTTON_A); //a number between 0 and 200 inclusive", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/button/#ispressed", 
            "text": "", 
            "title": "isPressed"
        }, 
        {
            "location": "/ubit/button/#int-ispressed", 
            "text": "", 
            "title": "int isPressed()"
        }, 
        {
            "location": "/ubit/button/#description_3", 
            "text": "Tests if this Button is currently pressed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/button/#returns", 
            "text": "1 if this button is pressed, 0 otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/button/#example_3", 
            "text": "if(uBit.buttonA.isPressed()) \n print( Pressed! );", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/button/#seteventconfiguration", 
            "text": "", 
            "title": "setEventConfiguration"
        }, 
        {
            "location": "/ubit/button/#void-seteventconfiguration-microbitbuttoneventconfiguration-config", 
            "text": "", 
            "title": "void setEventConfiguration( MicroBitButtonEventConfiguration config)"
        }, 
        {
            "location": "/ubit/button/#description_4", 
            "text": "Changes the event configuraiton of this button to the given value. All subsequent events generated by this button will then be informed by this configuraiton.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/button/#parameters_3", 
            "text": "MicroBitButtonEventConfiguration   config  - The new configuration for this button. Legal values are MICROBIT_BUTTON_ALL_EVENTS or MICROBIT_BUTTON_SIMPLE_EVENTS.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/button/#example_4", 
            "text": "// Configure a button to generate all possible events. \n uBit.buttonA.setEventConfiguration(MICROBIT_BUTTON_ALL_EVENTS); \n\n // Configure a button to suppress MICROBIT_BUTTON_EVT_CLICK and MICROBIT_BUTTON_EVT_LONG_CLICK events. \n uBit.buttonA.setEventConfiguration(MICROBIT_BUTTON_SIMPLE_EVENTS);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/button/#microbitbutton", 
            "text": "", 
            "title": "~MicroBitButton"
        }, 
        {
            "location": "/ubit/button/#microbitbutton_1", 
            "text": "", 
            "title": "~MicroBitButton()"
        }, 
        {
            "location": "/ubit/button/#description_5", 
            "text": "Destructor for  MicroBitButton", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/", 
            "text": "uBit.display\n\n\nOverview\n\n\nMessage Bus ID\n\n\nMessage Bus Events\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitDisplay( \nuint16_t\n id,  \nuint8_t\n x,  \nuint8_t\n y)\n\n\nDescription\n\n\nConstructor. Create a representation of a display of a given size. The display is initially blank.\n\n\nParameters\n\n\n\n\nuint16_t\n \nid\n\n\nuint8_t\n \nx\n - the width of the display in pixels. \n\n\nuint8_t\n \ny\n - the height of the display in pixels.\n\n\n\n\nExample\n\n\n MicroBitDisplay display(MICROBIT_ID_DISPLAY, 5, 5), \n\n\n\n\n\nstopAnimation\n\n\n\n\nvoid\n stopAnimation()\n\n\nDescription\n\n\nStops any currently running animation, and any that are waiting to be displayed.\n\n\nprintAsync\n\n\n\n\nint\n printAsync( \nchar\n c)\n\n\nDescription\n\n\nPrints the given character to the display, if it is not in use.\n\n\nParameters\n\n\n\n\nchar\n \nc\n - The character to display. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY is the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n uBit.display.printAsync('p'); \n uBit.display.printAsync('p',100); \n\n\n\n\n\n\n\nint\n printAsync( \nchar\n c,  \nint\n delay)\n\n\nDescription\n\n\nPrints the given character to the display, if it is not in use.\n\n\nParameters\n\n\n\n\nchar\n \nc\n - The character to display. \n\n\nint\n \ndelay\n - Optional parameter - the time for which to show the character. Zero displays the character forever. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY is the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n uBit.display.printAsync('p'); \n uBit.display.printAsync('p',100); \n\n\n\n\n\n\n\nint\n printAsync( \nManagedString\n s)\n\n\nDescription\n\n\nPrints the given string to the display, one character at a time. Uses the given delay between characters. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n uBit.display.printAsync(\nabc123\n,400); \n\n\n\n\n\n\n\nint\n printAsync( \nManagedString\n s,  \nint\n delay)\n\n\nDescription\n\n\nPrints the given string to the display, one character at a time. Uses the given delay between characters. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display. \n\n\nint\n \ndelay\n - The time to delay between characters, in milliseconds. Must be \n 0. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n uBit.display.printAsync(\nabc123\n,400); \n\n\n\n\n\n\n\nint\n printAsync( \nMicroBitImage\n i,  \nint\n x,  \nint\n y,  \nint\n alpha)\n\n\nDescription\n\n\nPrints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display. \n\n\nint\n \nx\n - The horizontal position on the screen to display the image (default 0) \n\n\nint\n \ny\n - The vertical position on the screen to display the image (default 0) \n\n\nint\n \nalpha\n - Treats the brightness level '0' as transparent (default 0) \n\n\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n uBit.display.print(i,400); \n\n\n\n\n\n\n\nint\n printAsync( \nMicroBitImage\n i,  \nint\n x,  \nint\n y,  \nint\n alpha,  \nint\n delay)\n\n\nDescription\n\n\nPrints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display. \n\n\nint\n \nx\n - The horizontal position on the screen to display the image (default 0) \n\n\nint\n \ny\n - The vertical position on the screen to display the image (default 0) \n\n\nint\n \nalpha\n - Treats the brightness level '0' as transparent (default 0) \n\n\nint\n \ndelay\n - The time to delay between characters, in milliseconds. set to 0 to display forever. (default 0).\n\n\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n uBit.display.print(i,400); \n\n\n\n\n\nprint\n\n\n\n\nint\n print( \nchar\n c)\n\n\nDescription\n\n\nPrints the given character to the display.\n\n\nParameters\n\n\n\n\nchar\n \nc\n - The character to display. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n uBit.display.print('p'); \n\n\n\n\n\n\n\nint\n print( \nchar\n c,  \nint\n delay)\n\n\nDescription\n\n\nPrints the given character to the display.\n\n\nParameters\n\n\n\n\nchar\n \nc\n - The character to display. \n\n\nint\n \ndelay\n - The time to delay between characters, in milliseconds. Must be \n 0. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n uBit.display.print('p'); \n\n\n\n\n\n\n\nint\n print( \nManagedString\n s)\n\n\nDescription\n\n\nPrints the given string to the display, one character at a time. Uses the given delay between characters. Blocks the calling thread until all the text has been displayed.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n uBit.display.print(\nabc123\n,400); \n\n\n\n\n\n\n\nint\n print( \nManagedString\n s,  \nint\n delay)\n\n\nDescription\n\n\nPrints the given string to the display, one character at a time. Uses the given delay between characters. Blocks the calling thread until all the text has been displayed.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display. \n\n\nint\n \ndelay\n - The time to delay between characters, in milliseconds. Must be \n 0. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n uBit.display.print(\nabc123\n,400); \n\n\n\n\n\n\n\nint\n print( \nMicroBitImage\n i,  \nint\n x,  \nint\n y,  \nint\n alpha)\n\n\nDescription\n\n\nPrints the given image to the display. Blocks the calling thread until all the text has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display. \n\n\nint\n \nx\n\n\nint\n \ny\n\n\nint\n \nalpha\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n uBit.display.print(i,400); \n\n\n\n\n\n\n\nint\n print( \nMicroBitImage\n i,  \nint\n x,  \nint\n y,  \nint\n alpha,  \nint\n delay)\n\n\nDescription\n\n\nPrints the given image to the display. Blocks the calling thread until all the text has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display. \n\n\nint\n \nx\n\n\nint\n \ny\n\n\nint\n \nalpha\n\n\nint\n \ndelay\n - The time to display the image for, or zero to show the image forever. Must be \n= 0. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n uBit.display.print(i,400); \n\n\n\n\n\nscrollAsync\n\n\n\n\nint\n scrollAsync( \nManagedString\n s)\n\n\nDescription\n\n\nScrolls the given string to the display, from right to left. Uses the given delay between characters. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n uBit.display.scrollAsync(\nabc123\n,100); \n\n\n\n\n\n\n\nint\n scrollAsync( \nManagedString\n s,  \nint\n delay)\n\n\nDescription\n\n\nScrolls the given string to the display, from right to left. Uses the given delay between characters. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display. \n\n\nint\n \ndelay\n - The time to delay between each update to the display, in milliseconds. Must be \n 0. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n uBit.display.scrollAsync(\nabc123\n,100); \n\n\n\n\n\n\n\nint\n scrollAsync( \nMicroBitImage\n image)\n\n\nDescription\n\n\nScrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n uBit.display.scrollAsync(i,100,1); \n\n\n\n\n\n\n\nint\n scrollAsync( \nMicroBitImage\n image,  \nint\n delay)\n\n\nDescription\n\n\nScrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display. \n\n\nint\n \ndelay\n - The time to delay between each update to the display, in milliseconds. Must be \n 0. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n uBit.display.scrollAsync(i,100,1); \n\n\n\n\n\n\n\nint\n scrollAsync( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride)\n\n\nDescription\n\n\nScrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display. \n\n\nint\n \ndelay\n - The time to delay between each update to the display, in milliseconds. Must be \n 0. \n\n\nint\n \nstride\n - The number of pixels to move in each update. Default value is the screen width. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n uBit.display.scrollAsync(i,100,1); \n\n\n\n\n\nscroll\n\n\n\n\nint\n scroll( \nManagedString\n s)\n\n\nDescription\n\n\nScrolls the given string to the display, from right to left. Uses the given delay between characters. Blocks the calling thread until all the text has been displayed.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n uBit.display.scroll(\nabc123\n,100); \n\n\n\n\n\n\n\nint\n scroll( \nManagedString\n s,  \nint\n delay)\n\n\nDescription\n\n\nScrolls the given string to the display, from right to left. Uses the given delay between characters. Blocks the calling thread until all the text has been displayed.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display. \n\n\nint\n \ndelay\n - The time to delay between each update to the display, in milliseconds. Must be \n 0. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n uBit.display.scroll(\nabc123\n,100); \n\n\n\n\n\n\n\nint\n scroll( \nMicroBitImage\n image)\n\n\nDescription\n\n\nScrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n uBit.display.scroll(i,100,1); \n\n\n\n\n\n\n\nint\n scroll( \nMicroBitImage\n image,  \nint\n delay)\n\n\nDescription\n\n\nScrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display. \n\n\nint\n \ndelay\n - The time to delay between each update to the display, in milliseconds. Must be \n 0. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n uBit.display.scroll(i,100,1); \n\n\n\n\n\n\n\nint\n scroll( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride)\n\n\nDescription\n\n\nScrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display. \n\n\nint\n \ndelay\n - The time to delay between each update to the display, in milliseconds. Must be \n 0. \n\n\nint\n \nstride\n - The number of pixels to move in each update. Default value is the screen width. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n uBit.display.scroll(i,100,1); \n\n\n\n\n\nanimateAsync\n\n\n\n\nint\n animateAsync( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride)\n\n\nDescription\n\n\n\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display. \n\n\nint\n \ndelay\n - The time to delay between each update to the display, in milliseconds. Must be \n 0. \n\n\nint\n \nstride\n - The number of pixels to move in each update. Default value is the screen width. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n uBit.display.animateAsync(i,100,5); \n\n\n\n\n\n\n\nint\n animateAsync( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride,  \nint\n startingPosition)\n\n\nDescription\n\n\n\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display. \n\n\nint\n \ndelay\n - The time to delay between each update to the display, in milliseconds. Must be \n 0. \n\n\nint\n \nstride\n - The number of pixels to move in each update. Default value is the screen width. \n\n\nint\n \nstartingPosition\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n uBit.display.animateAsync(i,100,5); \n\n\n\n\n\nanimate\n\n\n\n\nint\n animate( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride)\n\n\nDescription\n\n\n\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display. \n\n\nint\n \ndelay\n - The time to delay between each update to the display, in milliseconds. Must be \n 0. \n\n\nint\n \nstride\n - The number of pixels to move in each update. Default value is the screen width. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n uBit.display.animate(i,100,5); \n\n\n\n\n\n\n\nint\n animate( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride,  \nint\n startingPosition)\n\n\nDescription\n\n\n\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display. \n\n\nint\n \ndelay\n - The time to delay between each update to the display, in milliseconds. Must be \n 0. \n\n\nint\n \nstride\n - The number of pixels to move in each update. Default value is the screen width. \n\n\nint\n \nstartingPosition\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n uBit.display.animate(i,100,5); \n\n\n\n\n\nsetBrightness\n\n\n\n\nint\n setBrightness( \nint\n b)\n\n\nDescription\n\n\nSets the display brightness to the specified level. \n\n\nParameters\n\n\n\n\nint\n \nb\n - The brightness to set the brightness to, in the range 0..255. \n\n\n\n\nReturns\n\n\nMICROBIT_OK, or MICROBIT_INVALID_PARAMETER\n\n\nExample\n\n\n uBit.display.setBrightness(255); //max brightness \n\n\n\n\n\nsetDisplayMode\n\n\n\n\nvoid\n setDisplayMode( \nDisplayMode\n mode)\n\n\nDescription\n\n\nSets the mode of the display. \n\n\nParameters\n\n\n\n\nDisplayMode\n \nmode\n - The mode to swap the display into. (can be either DISPLAY_MODE_GREYSCALE, DISPLAY_MODE_BLACK_AND_WHITE, DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE)\n\n\n\n\nExample\n\n\n uBit.display.setDisplayMode(DISPLAY_MODE_GREYSCALE); //per pixel brightness \n\n\n\n\n\ngetDisplayMode\n\n\n\n\nint\n getDisplayMode()\n\n\nDescription\n\n\nGets the mode of the display. \n\n\nReturns\n\n\nthe current mode of the display \n\n\ngetBrightness\n\n\n\n\nint\n getBrightness()\n\n\nDescription\n\n\nFetches the current brightness of this display. \n\n\nReturns\n\n\nthe brightness of this display, in the range 0..255.\n\n\nExample\n\n\n uBit.display.getBrightness(); //the current brightness \n\n\n\n\n\nrotateTo\n\n\n\n\nvoid\n rotateTo( \nDisplayRotation\n position)\n\n\nDescription\n\n\nRotates the display to the given position. Axis aligned values only.\n\n\nParameters\n\n\n\n\nDisplayRotation\n \nposition\n\n\n\n\nExample\n\n\n uBit.display.rotateTo(MICROBIT_DISPLAY_ROTATION_180); //rotates 180 degrees from original orientation \n\n\n\n\n\nenable\n\n\n\n\nvoid\n enable()\n\n\nDescription\n\n\nEnables the display, should only be called if the display is disabled.\n\n\nExample\n\n\n uBit.display.enable(); //reenables the display mechanics \n\n\n\n\n\ndisable\n\n\n\n\nvoid\n disable()\n\n\nDescription\n\n\nDisables the display, should only be called if the display is enabled. Display must be disabled to avoid MUXing of edge connector pins.\n\n\nExample\n\n\n uBit.display.disable(); //disables the display \n\n\n\n\n\nclear\n\n\n\n\nvoid\n clear()\n\n\nDescription\n\n\nClears the current image on the display. Simplifies the process, you can also use uBit.display.image.clear\n\n\nExample\n\n\n uBit.display.clear(); //clears the display \n\n\n\n\n\nerror\n\n\n\n\nvoid\n error( \nint\n statusCode)\n\n\nDescription\n\n\nDisplays \"=(\" and an accompanying status code infinitely. \n\n\nParameters\n\n\n\n\nint\n \nstatusCode\n - the appropriate status code - 0 means no code will be displayed. Status codes must be in the range 0-255.\n\n\n\n\nExample\n\n\n uBit.display.error(20); \n\n\n\n\n\nsetErrorTimeout\n\n\n\n\nvoid\n setErrorTimeout( \nint\n iterations)\n\n\nDescription\n\n\nDefines the length of time that the device will remain in a error state before resetting. \n\n\nParameters\n\n\n\n\nint\n \niterations\n - The number of times the error code will be displayed before resetting. Set to zero to remain in error state forever.\n\n\n\n\nExample\n\n\n uBit.display.setErrorTimeout(4); \n\n\n\n\n\nsetFont\n\n\n\n\nvoid\n setFont( \nMicroBitFont\n font)\n\n\nDescription\n\n\nUpdates the font property of this object with the new font. \n\n\nParameters\n\n\n\n\nMicroBitFont\n \nfont\n - the new font that will be used to render characters.. \n\n\n\n\ngetFont\n\n\n\n\nMicroBitFont\n getFont()\n\n\nDescription\n\n\nRetreives the font object used for rendering characters on the display. \n\n\nscreenShot\n\n\n\n\nMicroBitImage\n screenShot()\n\n\nDescription\n\n\nCaptures the bitmap currently being rendered on the display. \n\n\nreadLightLevel\n\n\n\n\nint\n readLightLevel()\n\n\nDescription\n\n\nConstructs an instance of a  MicroBitLightSensor\n\n\n\n\nNote\n\n\nthis will return 0 on the first call to this method, a light reading will be available after the display has activated the light sensor for the first time. \n\n\n\n\n~MicroBitDisplay\n\n\n\n\n~MicroBitDisplay()\n\n\nDescription\n\n\nDestructor for  MicroBitDisplay", 
            "title": "display"
        }, 
        {
            "location": "/ubit/display/#ubitdisplay", 
            "text": "", 
            "title": "uBit.display"
        }, 
        {
            "location": "/ubit/display/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/display/#message-bus-id", 
            "text": "", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/display/#message-bus-events", 
            "text": "", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/display/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/display/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/display/#microbitdisplay-uint16_t-id-uint8_t-x-uint8_t-y", 
            "text": "", 
            "title": "MicroBitDisplay( uint16_t id,  uint8_t x,  uint8_t y)"
        }, 
        {
            "location": "/ubit/display/#description", 
            "text": "Constructor. Create a representation of a display of a given size. The display is initially blank.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters", 
            "text": "uint16_t   id  uint8_t   x  - the width of the display in pixels.   uint8_t   y  - the height of the display in pixels.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example", 
            "text": "MicroBitDisplay display(MICROBIT_ID_DISPLAY, 5, 5),", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#stopanimation", 
            "text": "", 
            "title": "stopAnimation"
        }, 
        {
            "location": "/ubit/display/#void-stopanimation", 
            "text": "", 
            "title": "void stopAnimation()"
        }, 
        {
            "location": "/ubit/display/#description_1", 
            "text": "Stops any currently running animation, and any that are waiting to be displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#printasync", 
            "text": "", 
            "title": "printAsync"
        }, 
        {
            "location": "/ubit/display/#int-printasync-char-c", 
            "text": "", 
            "title": "int printAsync( char c)"
        }, 
        {
            "location": "/ubit/display/#description_2", 
            "text": "Prints the given character to the display, if it is not in use.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_1", 
            "text": "char   c  - The character to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns", 
            "text": "MICROBIT_OK, MICROBIT_BUSY is the screen is in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_1", 
            "text": "uBit.display.printAsync('p'); \n uBit.display.printAsync('p',100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printasync-char-c-int-delay", 
            "text": "", 
            "title": "int printAsync( char c,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_3", 
            "text": "Prints the given character to the display, if it is not in use.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_2", 
            "text": "char   c  - The character to display.   int   delay  - Optional parameter - the time for which to show the character. Zero displays the character forever.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_1", 
            "text": "MICROBIT_OK, MICROBIT_BUSY is the screen is in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_2", 
            "text": "uBit.display.printAsync('p'); \n uBit.display.printAsync('p',100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printasync-managedstring-s", 
            "text": "", 
            "title": "int printAsync( ManagedString s)"
        }, 
        {
            "location": "/ubit/display/#description_4", 
            "text": "Prints the given string to the display, one character at a time. Uses the given delay between characters. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_3", 
            "text": "ManagedString   s  - The string to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_2", 
            "text": "MICROBIT_OK, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_3", 
            "text": "uBit.display.printAsync( abc123 ,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printasync-managedstring-s-int-delay", 
            "text": "", 
            "title": "int printAsync( ManagedString s,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_5", 
            "text": "Prints the given string to the display, one character at a time. Uses the given delay between characters. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_4", 
            "text": "ManagedString   s  - The string to display.   int   delay  - The time to delay between characters, in milliseconds. Must be   0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_3", 
            "text": "MICROBIT_OK, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_4", 
            "text": "uBit.display.printAsync( abc123 ,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printasync-microbitimage-i-int-x-int-y-int-alpha", 
            "text": "", 
            "title": "int printAsync( MicroBitImage i,  int x,  int y,  int alpha)"
        }, 
        {
            "location": "/ubit/display/#description_6", 
            "text": "Prints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_5", 
            "text": "MicroBitImage   i  - The image to display.   int   x  - The horizontal position on the screen to display the image (default 0)   int   y  - The vertical position on the screen to display the image (default 0)   int   alpha  - Treats the brightness level '0' as transparent (default 0)", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_5", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n uBit.display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printasync-microbitimage-i-int-x-int-y-int-alpha-int-delay", 
            "text": "", 
            "title": "int printAsync( MicroBitImage i,  int x,  int y,  int alpha,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_7", 
            "text": "Prints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_6", 
            "text": "MicroBitImage   i  - The image to display.   int   x  - The horizontal position on the screen to display the image (default 0)   int   y  - The vertical position on the screen to display the image (default 0)   int   alpha  - Treats the brightness level '0' as transparent (default 0)   int   delay  - The time to delay between characters, in milliseconds. set to 0 to display forever. (default 0).", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_6", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n uBit.display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#print", 
            "text": "", 
            "title": "print"
        }, 
        {
            "location": "/ubit/display/#int-print-char-c", 
            "text": "", 
            "title": "int print( char c)"
        }, 
        {
            "location": "/ubit/display/#description_8", 
            "text": "Prints the given character to the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_7", 
            "text": "char   c  - The character to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_4", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_7", 
            "text": "uBit.display.print('p');", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-print-char-c-int-delay", 
            "text": "", 
            "title": "int print( char c,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_9", 
            "text": "Prints the given character to the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_8", 
            "text": "char   c  - The character to display.   int   delay  - The time to delay between characters, in milliseconds. Must be   0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_5", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_8", 
            "text": "uBit.display.print('p');", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-print-managedstring-s", 
            "text": "", 
            "title": "int print( ManagedString s)"
        }, 
        {
            "location": "/ubit/display/#description_10", 
            "text": "Prints the given string to the display, one character at a time. Uses the given delay between characters. Blocks the calling thread until all the text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_9", 
            "text": "ManagedString   s  - The string to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_6", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_9", 
            "text": "uBit.display.print( abc123 ,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-print-managedstring-s-int-delay", 
            "text": "", 
            "title": "int print( ManagedString s,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_11", 
            "text": "Prints the given string to the display, one character at a time. Uses the given delay between characters. Blocks the calling thread until all the text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_10", 
            "text": "ManagedString   s  - The string to display.   int   delay  - The time to delay between characters, in milliseconds. Must be   0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_7", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_10", 
            "text": "uBit.display.print( abc123 ,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-print-microbitimage-i-int-x-int-y-int-alpha", 
            "text": "", 
            "title": "int print( MicroBitImage i,  int x,  int y,  int alpha)"
        }, 
        {
            "location": "/ubit/display/#description_12", 
            "text": "Prints the given image to the display. Blocks the calling thread until all the text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_11", 
            "text": "MicroBitImage   i  - The image to display.   int   x  int   y  int   alpha", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_8", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_11", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n uBit.display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-print-microbitimage-i-int-x-int-y-int-alpha-int-delay", 
            "text": "", 
            "title": "int print( MicroBitImage i,  int x,  int y,  int alpha,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_13", 
            "text": "Prints the given image to the display. Blocks the calling thread until all the text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_12", 
            "text": "MicroBitImage   i  - The image to display.   int   x  int   y  int   alpha  int   delay  - The time to display the image for, or zero to show the image forever. Must be  = 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_9", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_12", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n uBit.display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#scrollasync", 
            "text": "", 
            "title": "scrollAsync"
        }, 
        {
            "location": "/ubit/display/#int-scrollasync-managedstring-s", 
            "text": "", 
            "title": "int scrollAsync( ManagedString s)"
        }, 
        {
            "location": "/ubit/display/#description_14", 
            "text": "Scrolls the given string to the display, from right to left. Uses the given delay between characters. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_13", 
            "text": "ManagedString   s  - The string to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_10", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_13", 
            "text": "uBit.display.scrollAsync( abc123 ,100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scrollasync-managedstring-s-int-delay", 
            "text": "", 
            "title": "int scrollAsync( ManagedString s,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_15", 
            "text": "Scrolls the given string to the display, from right to left. Uses the given delay between characters. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_14", 
            "text": "ManagedString   s  - The string to display.   int   delay  - The time to delay between each update to the display, in milliseconds. Must be   0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_11", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_14", 
            "text": "uBit.display.scrollAsync( abc123 ,100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scrollasync-microbitimage-image", 
            "text": "", 
            "title": "int scrollAsync( MicroBitImage image)"
        }, 
        {
            "location": "/ubit/display/#description_16", 
            "text": "Scrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_15", 
            "text": "MicroBitImage   image  - The image to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_12", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_15", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n uBit.display.scrollAsync(i,100,1);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scrollasync-microbitimage-image-int-delay", 
            "text": "", 
            "title": "int scrollAsync( MicroBitImage image,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_17", 
            "text": "Scrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_16", 
            "text": "MicroBitImage   image  - The image to display.   int   delay  - The time to delay between each update to the display, in milliseconds. Must be   0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_13", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_16", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n uBit.display.scrollAsync(i,100,1);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scrollasync-microbitimage-image-int-delay-int-stride", 
            "text": "", 
            "title": "int scrollAsync( MicroBitImage image,  int delay,  int stride)"
        }, 
        {
            "location": "/ubit/display/#description_18", 
            "text": "Scrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_17", 
            "text": "MicroBitImage   image  - The image to display.   int   delay  - The time to delay between each update to the display, in milliseconds. Must be   0.   int   stride  - The number of pixels to move in each update. Default value is the screen width.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_14", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_17", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n uBit.display.scrollAsync(i,100,1);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#scroll", 
            "text": "", 
            "title": "scroll"
        }, 
        {
            "location": "/ubit/display/#int-scroll-managedstring-s", 
            "text": "", 
            "title": "int scroll( ManagedString s)"
        }, 
        {
            "location": "/ubit/display/#description_19", 
            "text": "Scrolls the given string to the display, from right to left. Uses the given delay between characters. Blocks the calling thread until all the text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_18", 
            "text": "ManagedString   s  - The string to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_15", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_18", 
            "text": "uBit.display.scroll( abc123 ,100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scroll-managedstring-s-int-delay", 
            "text": "", 
            "title": "int scroll( ManagedString s,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_20", 
            "text": "Scrolls the given string to the display, from right to left. Uses the given delay between characters. Blocks the calling thread until all the text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_19", 
            "text": "ManagedString   s  - The string to display.   int   delay  - The time to delay between each update to the display, in milliseconds. Must be   0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_16", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_19", 
            "text": "uBit.display.scroll( abc123 ,100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scroll-microbitimage-image", 
            "text": "", 
            "title": "int scroll( MicroBitImage image)"
        }, 
        {
            "location": "/ubit/display/#description_21", 
            "text": "Scrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_20", 
            "text": "MicroBitImage   image  - The image to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_17", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_20", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n uBit.display.scroll(i,100,1);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scroll-microbitimage-image-int-delay", 
            "text": "", 
            "title": "int scroll( MicroBitImage image,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_22", 
            "text": "Scrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_21", 
            "text": "MicroBitImage   image  - The image to display.   int   delay  - The time to delay between each update to the display, in milliseconds. Must be   0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_18", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_21", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n uBit.display.scroll(i,100,1);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scroll-microbitimage-image-int-delay-int-stride", 
            "text": "", 
            "title": "int scroll( MicroBitImage image,  int delay,  int stride)"
        }, 
        {
            "location": "/ubit/display/#description_23", 
            "text": "Scrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_22", 
            "text": "MicroBitImage   image  - The image to display.   int   delay  - The time to delay between each update to the display, in milliseconds. Must be   0.   int   stride  - The number of pixels to move in each update. Default value is the screen width.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_19", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_22", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n uBit.display.scroll(i,100,1);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#animateasync", 
            "text": "", 
            "title": "animateAsync"
        }, 
        {
            "location": "/ubit/display/#int-animateasync-microbitimage-image-int-delay-int-stride", 
            "text": "", 
            "title": "int animateAsync( MicroBitImage image,  int delay,  int stride)"
        }, 
        {
            "location": "/ubit/display/#description_24", 
            "text": "\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_23", 
            "text": "MicroBitImage   image  - The image to display.   int   delay  - The time to delay between each update to the display, in milliseconds. Must be   0.   int   stride  - The number of pixels to move in each update. Default value is the screen width.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_20", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_23", 
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n uBit.display.animateAsync(i,100,5);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-animateasync-microbitimage-image-int-delay-int-stride-int-startingposition", 
            "text": "", 
            "title": "int animateAsync( MicroBitImage image,  int delay,  int stride,  int startingPosition)"
        }, 
        {
            "location": "/ubit/display/#description_25", 
            "text": "\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_24", 
            "text": "MicroBitImage   image  - The image to display.   int   delay  - The time to delay between each update to the display, in milliseconds. Must be   0.   int   stride  - The number of pixels to move in each update. Default value is the screen width.   int   startingPosition", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_21", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_24", 
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n uBit.display.animateAsync(i,100,5);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#animate", 
            "text": "", 
            "title": "animate"
        }, 
        {
            "location": "/ubit/display/#int-animate-microbitimage-image-int-delay-int-stride", 
            "text": "", 
            "title": "int animate( MicroBitImage image,  int delay,  int stride)"
        }, 
        {
            "location": "/ubit/display/#description_26", 
            "text": "\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_25", 
            "text": "MicroBitImage   image  - The image to display.   int   delay  - The time to delay between each update to the display, in milliseconds. Must be   0.   int   stride  - The number of pixels to move in each update. Default value is the screen width.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_22", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_25", 
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n uBit.display.animate(i,100,5);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-animate-microbitimage-image-int-delay-int-stride-int-startingposition", 
            "text": "", 
            "title": "int animate( MicroBitImage image,  int delay,  int stride,  int startingPosition)"
        }, 
        {
            "location": "/ubit/display/#description_27", 
            "text": "\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_26", 
            "text": "MicroBitImage   image  - The image to display.   int   delay  - The time to delay between each update to the display, in milliseconds. Must be   0.   int   stride  - The number of pixels to move in each update. Default value is the screen width.   int   startingPosition", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_23", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_26", 
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n uBit.display.animate(i,100,5);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#setbrightness", 
            "text": "", 
            "title": "setBrightness"
        }, 
        {
            "location": "/ubit/display/#int-setbrightness-int-b", 
            "text": "", 
            "title": "int setBrightness( int b)"
        }, 
        {
            "location": "/ubit/display/#description_28", 
            "text": "Sets the display brightness to the specified level.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_27", 
            "text": "int   b  - The brightness to set the brightness to, in the range 0..255.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_24", 
            "text": "MICROBIT_OK, or MICROBIT_INVALID_PARAMETER", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_27", 
            "text": "uBit.display.setBrightness(255); //max brightness", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#setdisplaymode", 
            "text": "", 
            "title": "setDisplayMode"
        }, 
        {
            "location": "/ubit/display/#void-setdisplaymode-displaymode-mode", 
            "text": "", 
            "title": "void setDisplayMode( DisplayMode mode)"
        }, 
        {
            "location": "/ubit/display/#description_29", 
            "text": "Sets the mode of the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_28", 
            "text": "DisplayMode   mode  - The mode to swap the display into. (can be either DISPLAY_MODE_GREYSCALE, DISPLAY_MODE_BLACK_AND_WHITE, DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE)", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_28", 
            "text": "uBit.display.setDisplayMode(DISPLAY_MODE_GREYSCALE); //per pixel brightness", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#getdisplaymode", 
            "text": "", 
            "title": "getDisplayMode"
        }, 
        {
            "location": "/ubit/display/#int-getdisplaymode", 
            "text": "", 
            "title": "int getDisplayMode()"
        }, 
        {
            "location": "/ubit/display/#description_30", 
            "text": "Gets the mode of the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#returns_25", 
            "text": "the current mode of the display", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#getbrightness", 
            "text": "", 
            "title": "getBrightness"
        }, 
        {
            "location": "/ubit/display/#int-getbrightness", 
            "text": "", 
            "title": "int getBrightness()"
        }, 
        {
            "location": "/ubit/display/#description_31", 
            "text": "Fetches the current brightness of this display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#returns_26", 
            "text": "the brightness of this display, in the range 0..255.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_29", 
            "text": "uBit.display.getBrightness(); //the current brightness", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#rotateto", 
            "text": "", 
            "title": "rotateTo"
        }, 
        {
            "location": "/ubit/display/#void-rotateto-displayrotation-position", 
            "text": "", 
            "title": "void rotateTo( DisplayRotation position)"
        }, 
        {
            "location": "/ubit/display/#description_32", 
            "text": "Rotates the display to the given position. Axis aligned values only.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_29", 
            "text": "DisplayRotation   position", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_30", 
            "text": "uBit.display.rotateTo(MICROBIT_DISPLAY_ROTATION_180); //rotates 180 degrees from original orientation", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#enable", 
            "text": "", 
            "title": "enable"
        }, 
        {
            "location": "/ubit/display/#void-enable", 
            "text": "", 
            "title": "void enable()"
        }, 
        {
            "location": "/ubit/display/#description_33", 
            "text": "Enables the display, should only be called if the display is disabled.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#example_31", 
            "text": "uBit.display.enable(); //reenables the display mechanics", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#disable", 
            "text": "", 
            "title": "disable"
        }, 
        {
            "location": "/ubit/display/#void-disable", 
            "text": "", 
            "title": "void disable()"
        }, 
        {
            "location": "/ubit/display/#description_34", 
            "text": "Disables the display, should only be called if the display is enabled. Display must be disabled to avoid MUXing of edge connector pins.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#example_32", 
            "text": "uBit.display.disable(); //disables the display", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#clear", 
            "text": "", 
            "title": "clear"
        }, 
        {
            "location": "/ubit/display/#void-clear", 
            "text": "", 
            "title": "void clear()"
        }, 
        {
            "location": "/ubit/display/#description_35", 
            "text": "Clears the current image on the display. Simplifies the process, you can also use uBit.display.image.clear", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#example_33", 
            "text": "uBit.display.clear(); //clears the display", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#error", 
            "text": "", 
            "title": "error"
        }, 
        {
            "location": "/ubit/display/#void-error-int-statuscode", 
            "text": "", 
            "title": "void error( int statusCode)"
        }, 
        {
            "location": "/ubit/display/#description_36", 
            "text": "Displays \"=(\" and an accompanying status code infinitely.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_30", 
            "text": "int   statusCode  - the appropriate status code - 0 means no code will be displayed. Status codes must be in the range 0-255.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_34", 
            "text": "uBit.display.error(20);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#seterrortimeout", 
            "text": "", 
            "title": "setErrorTimeout"
        }, 
        {
            "location": "/ubit/display/#void-seterrortimeout-int-iterations", 
            "text": "", 
            "title": "void setErrorTimeout( int iterations)"
        }, 
        {
            "location": "/ubit/display/#description_37", 
            "text": "Defines the length of time that the device will remain in a error state before resetting.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_31", 
            "text": "int   iterations  - The number of times the error code will be displayed before resetting. Set to zero to remain in error state forever.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_35", 
            "text": "uBit.display.setErrorTimeout(4);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#setfont", 
            "text": "", 
            "title": "setFont"
        }, 
        {
            "location": "/ubit/display/#void-setfont-microbitfont-font", 
            "text": "", 
            "title": "void setFont( MicroBitFont font)"
        }, 
        {
            "location": "/ubit/display/#description_38", 
            "text": "Updates the font property of this object with the new font.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_32", 
            "text": "MicroBitFont   font  - the new font that will be used to render characters..", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#getfont", 
            "text": "", 
            "title": "getFont"
        }, 
        {
            "location": "/ubit/display/#microbitfont-getfont", 
            "text": "", 
            "title": "MicroBitFont getFont()"
        }, 
        {
            "location": "/ubit/display/#description_39", 
            "text": "Retreives the font object used for rendering characters on the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#screenshot", 
            "text": "", 
            "title": "screenShot"
        }, 
        {
            "location": "/ubit/display/#microbitimage-screenshot", 
            "text": "", 
            "title": "MicroBitImage screenShot()"
        }, 
        {
            "location": "/ubit/display/#description_40", 
            "text": "Captures the bitmap currently being rendered on the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#readlightlevel", 
            "text": "", 
            "title": "readLightLevel"
        }, 
        {
            "location": "/ubit/display/#int-readlightlevel", 
            "text": "", 
            "title": "int readLightLevel()"
        }, 
        {
            "location": "/ubit/display/#description_41", 
            "text": "Constructs an instance of a  MicroBitLightSensor   Note  this will return 0 on the first call to this method, a light reading will be available after the display has activated the light sensor for the first time.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#microbitdisplay", 
            "text": "", 
            "title": "~MicroBitDisplay"
        }, 
        {
            "location": "/ubit/display/#microbitdisplay_1", 
            "text": "", 
            "title": "~MicroBitDisplay()"
        }, 
        {
            "location": "/ubit/display/#description_42", 
            "text": "Destructor for  MicroBitDisplay", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/", 
            "text": "uBit.accelerometer\n\n\nOverview\n\n\nOnboard the micro:bit is an accelerometer. The accelerometer is linked to the\n\ni2c\n bus, which is used to read data from the accelerometer.\n\n\nWhen using the standard uBit presentation, the accelerometer is continuously updated\nin the background using an idle thread, which is executed whenever the micro:bit\nhas no other tasks to perform..\n\n\nIf there is no scheduler running, the values are synchronously read on \nget[X,Y,Z]()\n\ncalls. Additionally, if you would like to drive accelerometer updates manually \nupdateSample()\n\ncan be used.\n\n\nThe micro:bit uses the \nNXP MMA8653 accelerometer\n.\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_ACCELEROMETER\n\n\n4\n\n\n\n\n\n\n\n\nMessage Bus Events\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_TILT_UP\n\n\n1\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_TILT_DOWN\n\n\n2\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_TILT_LEFT\n\n\n3\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_TILT_RIGHT\n\n\n4\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_FACE_UP\n\n\n5\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_FACE_DOWN\n\n\n6\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_FREEFALL\n\n\n7\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_3G\n\n\n8\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_6G\n\n\n9\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_8G\n\n\n10\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_SHAKE\n\n\n11\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitAccelerometer( \nuint16_t\n id,  \nuint16_t\n address)\n\n\nDescription\n\n\nConstructor. Create an accelerometer representation with the given ID.\n\n\nParameters\n\n\n\n\nuint16_t\n \nid\n - the ID of the new object.\n\n\nuint16_t\n \naddress\n - the default base address of the accelerometer.\n\n\n\n\nExample\n\n\n accelerometer(MICROBIT_ID_ACCELEROMETER, MMA8653_DEFAULT_ADDR)\n\n\n\n\n\nconfigure\n\n\n\n\nint\n configure()\n\n\nDescription\n\n\nConfigures the accelerometer for G range and sample rate defined in this object. The nearest values are chosen to those defined that are supported by the hardware. The instance variables are then updated to reflect reality.\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if the accelerometer could not be configured.\n\n\nupdate\n\n\n\n\nint\n update()\n\n\nDescription\n\n\nReads the acceleration data from the accelerometer, and stores it in our buffer. This is called by the tick() member function, if the interrupt is set.\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR is the read request fails.\n\n\nsetPeriod\n\n\n\n\nint\n setPeriod( \nint\n period)\n\n\nDescription\n\n\nAttempts to set the sample rate of the accelerometer to the specified value (in ms). n.b. the requested rate may not be possible on the hardware. In this case, the nearest lower rate is chosen.\n\n\nParameters\n\n\n\n\nint\n \nperiod\n - the requested time between samples, in milliseconds.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR is the request fails.\n\n\ngetPeriod\n\n\n\n\nint\n getPeriod()\n\n\nDescription\n\n\nReads the currently configured sample rate of the accelerometer.\n\n\nReturns\n\n\nThe time between samples, in milliseconds.\n\n\nsetRange\n\n\n\n\nint\n setRange( \nint\n range)\n\n\nDescription\n\n\nAttempts to set the sample range of the accelerometer to the specified value (in g). n.b. the requested range may not be possible on the hardware. In this case, the nearest lower rate is chosen.\n\n\nParameters\n\n\n\n\nint\n \nrange\n - The requested sample range of samples, in g.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR is the request fails.\n\n\ngetRange\n\n\n\n\nint\n getRange()\n\n\nDescription\n\n\nReads the currently configured sample range of the accelerometer.\n\n\nReturns\n\n\nThe sample range, in g.\n\n\nwhoAmI\n\n\n\n\nint\n whoAmI()\n\n\nDescription\n\n\nAttempts to determine the 8 bit ID from the accelerometer.\n\n\nReturns\n\n\nthe 8 bit ID returned by the accelerometer, or MICROBIT_I2C_ERROR if the request fails.\n\n\nExample\n\n\n uBit.accelerometer.whoAmI();\n\n\n\n\n\ngetX\n\n\n\n\nint\n getX()\n\n\nDescription\n\n\nReads the X axis value of the latest update from the accelerometer.\n\n\nReturns\n\n\nThe force measured in the X axis, in milli-g.\n\n\nExample\n\n\n uBit.accelerometer.getX();\n\n\n\n\n\n\n\nint\n getX( \nMicroBitCoordinateSystem\n system)\n\n\nDescription\n\n\nReads the X axis value of the latest update from the accelerometer.\n\n\nParameters\n\n\n\n\nMicroBitCoordinateSystem\n \nsystem\n - The coordinate system to use. By default, a simple cartesian system is provided.\n\n\n\n\nReturns\n\n\nThe force measured in the X axis, in milli-g.\n\n\nExample\n\n\n uBit.accelerometer.getX();\n\n\n\n\n\ngetY\n\n\n\n\nint\n getY()\n\n\nDescription\n\n\nReads the Y axis value of the latest update from the accelerometer.\n\n\nReturns\n\n\nThe force measured in the Y axis, in milli-g.\n\n\nExample\n\n\n uBit.accelerometer.getY();\n\n\n\n\n\n\n\nint\n getY( \nMicroBitCoordinateSystem\n system)\n\n\nDescription\n\n\nReads the Y axis value of the latest update from the accelerometer.\n\n\nParameters\n\n\n\n\nMicroBitCoordinateSystem\n \nsystem\n - The coordinate system to use. By default, a simple cartesian system is provided.\n\n\n\n\nReturns\n\n\nThe force measured in the Y axis, in milli-g.\n\n\nExample\n\n\n uBit.accelerometer.getY();\n\n\n\n\n\ngetZ\n\n\n\n\nint\n getZ()\n\n\nDescription\n\n\nReads the Z axis value of the latest update from the accelerometer.\n\n\nReturns\n\n\nThe force measured in the Z axis, in milli-g.\n\n\nExample\n\n\n uBit.accelerometer.getZ();\n\n\n\n\n\n\n\nint\n getZ( \nMicroBitCoordinateSystem\n system)\n\n\nDescription\n\n\nReads the Z axis value of the latest update from the accelerometer.\n\n\nParameters\n\n\n\n\nMicroBitCoordinateSystem\n \nsystem\n - The coordinate system to use. By default, a simple cartesian system is provided.\n\n\n\n\nReturns\n\n\nThe force measured in the Z axis, in milli-g.\n\n\nExample\n\n\n uBit.accelerometer.getZ();\n\n\n\n\n\ngetPitch\n\n\n\n\nint\n getPitch()\n\n\nDescription\n\n\nProvides a rotation compensated pitch of the device, based on the latest update from the accelerometer.\n\n\nReturns\n\n\nThe pitch of the device, in degrees.\n\n\nExample\n\n\n uBit.accelerometer.getPitch();\n\n\n\n\n\ngetPitchRadians\n\n\n\n\nfloat\n getPitchRadians()\n\n\ngetRoll\n\n\n\n\nint\n getRoll()\n\n\nDescription\n\n\nProvides a rotation compensated roll of the device, based on the latest update from the accelerometer.\n\n\nReturns\n\n\nThe roll of the device, in degrees.\n\n\nExample\n\n\n uBit.accelerometer.getRoll();\n\n\n\n\n\ngetRollRadians\n\n\n\n\nfloat\n getRollRadians()\n\n\ngetGesture\n\n\n\n\nBasicGesture\n getGesture()\n\n\nDescription\n\n\nReads the last recorded gesture detected.\n\n\nReturns\n\n\nThe last gesture detected.\n\n\nExample\n\n\n if (uBit.accelerometer.getGesture() == SHAKE)\n\n\n\n\n\nisIdleCallbackNeeded\n\n\n\n\nint\n isIdleCallbackNeeded()\n\n\nDescription\n\n\nReturns 0 or 1. 1 indicates data is waiting to be read, zero means data is not ready to be read.\n\n\n~MicroBitAccelerometer\n\n\n\n\n~MicroBitAccelerometer()\n\n\nDescription\n\n\nDestructor for  MicroBitButton", 
            "title": "accelerometer"
        }, 
        {
            "location": "/ubit/accelerometer/#ubitaccelerometer", 
            "text": "", 
            "title": "uBit.accelerometer"
        }, 
        {
            "location": "/ubit/accelerometer/#overview", 
            "text": "Onboard the micro:bit is an accelerometer. The accelerometer is linked to the i2c  bus, which is used to read data from the accelerometer.  When using the standard uBit presentation, the accelerometer is continuously updated\nin the background using an idle thread, which is executed whenever the micro:bit\nhas no other tasks to perform..  If there is no scheduler running, the values are synchronously read on  get[X,Y,Z]() \ncalls. Additionally, if you would like to drive accelerometer updates manually  updateSample() \ncan be used.  The micro:bit uses the  NXP MMA8653 accelerometer .", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/accelerometer/#message-bus-id", 
            "text": "Constant  Value      MICROBIT_ID_ACCELEROMETER  4", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/accelerometer/#message-bus-events", 
            "text": "Constant  Value      MICROBIT_ACCELEROMETER_EVT_TILT_UP  1    MICROBIT_ACCELEROMETER_EVT_TILT_DOWN  2    MICROBIT_ACCELEROMETER_EVT_TILT_LEFT  3    MICROBIT_ACCELEROMETER_EVT_TILT_RIGHT  4    MICROBIT_ACCELEROMETER_EVT_FACE_UP  5    MICROBIT_ACCELEROMETER_EVT_FACE_DOWN  6    MICROBIT_ACCELEROMETER_EVT_FREEFALL  7    MICROBIT_ACCELEROMETER_EVT_3G  8    MICROBIT_ACCELEROMETER_EVT_6G  9    MICROBIT_ACCELEROMETER_EVT_8G  10    MICROBIT_ACCELEROMETER_EVT_SHAKE  11", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/accelerometer/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/accelerometer/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/accelerometer/#microbitaccelerometer-uint16_t-id-uint16_t-address", 
            "text": "", 
            "title": "MicroBitAccelerometer( uint16_t id,  uint16_t address)"
        }, 
        {
            "location": "/ubit/accelerometer/#description", 
            "text": "Constructor. Create an accelerometer representation with the given ID.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters", 
            "text": "uint16_t   id  - the ID of the new object.  uint16_t   address  - the default base address of the accelerometer.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#example", 
            "text": "accelerometer(MICROBIT_ID_ACCELEROMETER, MMA8653_DEFAULT_ADDR)", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#configure", 
            "text": "", 
            "title": "configure"
        }, 
        {
            "location": "/ubit/accelerometer/#int-configure", 
            "text": "", 
            "title": "int configure()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_1", 
            "text": "Configures the accelerometer for G range and sample rate defined in this object. The nearest values are chosen to those defined that are supported by the hardware. The instance variables are then updated to reflect reality.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns", 
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if the accelerometer could not be configured.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#update", 
            "text": "", 
            "title": "update"
        }, 
        {
            "location": "/ubit/accelerometer/#int-update", 
            "text": "", 
            "title": "int update()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_2", 
            "text": "Reads the acceleration data from the accelerometer, and stores it in our buffer. This is called by the tick() member function, if the interrupt is set.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_1", 
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR is the read request fails.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#setperiod", 
            "text": "", 
            "title": "setPeriod"
        }, 
        {
            "location": "/ubit/accelerometer/#int-setperiod-int-period", 
            "text": "", 
            "title": "int setPeriod( int period)"
        }, 
        {
            "location": "/ubit/accelerometer/#description_3", 
            "text": "Attempts to set the sample rate of the accelerometer to the specified value (in ms). n.b. the requested rate may not be possible on the hardware. In this case, the nearest lower rate is chosen.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters_1", 
            "text": "int   period  - the requested time between samples, in milliseconds.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_2", 
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR is the request fails.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#getperiod", 
            "text": "", 
            "title": "getPeriod"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getperiod", 
            "text": "", 
            "title": "int getPeriod()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_4", 
            "text": "Reads the currently configured sample rate of the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_3", 
            "text": "The time between samples, in milliseconds.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#setrange", 
            "text": "", 
            "title": "setRange"
        }, 
        {
            "location": "/ubit/accelerometer/#int-setrange-int-range", 
            "text": "", 
            "title": "int setRange( int range)"
        }, 
        {
            "location": "/ubit/accelerometer/#description_5", 
            "text": "Attempts to set the sample range of the accelerometer to the specified value (in g). n.b. the requested range may not be possible on the hardware. In this case, the nearest lower rate is chosen.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters_2", 
            "text": "int   range  - The requested sample range of samples, in g.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_4", 
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR is the request fails.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#getrange", 
            "text": "", 
            "title": "getRange"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getrange", 
            "text": "", 
            "title": "int getRange()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_6", 
            "text": "Reads the currently configured sample range of the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_5", 
            "text": "The sample range, in g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#whoami", 
            "text": "", 
            "title": "whoAmI"
        }, 
        {
            "location": "/ubit/accelerometer/#int-whoami", 
            "text": "", 
            "title": "int whoAmI()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_7", 
            "text": "Attempts to determine the 8 bit ID from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_6", 
            "text": "the 8 bit ID returned by the accelerometer, or MICROBIT_I2C_ERROR if the request fails.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_1", 
            "text": "uBit.accelerometer.whoAmI();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getx", 
            "text": "", 
            "title": "getX"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getx", 
            "text": "", 
            "title": "int getX()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_8", 
            "text": "Reads the X axis value of the latest update from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_7", 
            "text": "The force measured in the X axis, in milli-g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_2", 
            "text": "uBit.accelerometer.getX();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getx-microbitcoordinatesystem-system", 
            "text": "", 
            "title": "int getX( MicroBitCoordinateSystem system)"
        }, 
        {
            "location": "/ubit/accelerometer/#description_9", 
            "text": "Reads the X axis value of the latest update from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters_3", 
            "text": "MicroBitCoordinateSystem   system  - The coordinate system to use. By default, a simple cartesian system is provided.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_8", 
            "text": "The force measured in the X axis, in milli-g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_3", 
            "text": "uBit.accelerometer.getX();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#gety", 
            "text": "", 
            "title": "getY"
        }, 
        {
            "location": "/ubit/accelerometer/#int-gety", 
            "text": "", 
            "title": "int getY()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_10", 
            "text": "Reads the Y axis value of the latest update from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_9", 
            "text": "The force measured in the Y axis, in milli-g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_4", 
            "text": "uBit.accelerometer.getY();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#int-gety-microbitcoordinatesystem-system", 
            "text": "", 
            "title": "int getY( MicroBitCoordinateSystem system)"
        }, 
        {
            "location": "/ubit/accelerometer/#description_11", 
            "text": "Reads the Y axis value of the latest update from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters_4", 
            "text": "MicroBitCoordinateSystem   system  - The coordinate system to use. By default, a simple cartesian system is provided.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_10", 
            "text": "The force measured in the Y axis, in milli-g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_5", 
            "text": "uBit.accelerometer.getY();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getz", 
            "text": "", 
            "title": "getZ"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getz", 
            "text": "", 
            "title": "int getZ()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_12", 
            "text": "Reads the Z axis value of the latest update from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_11", 
            "text": "The force measured in the Z axis, in milli-g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_6", 
            "text": "uBit.accelerometer.getZ();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getz-microbitcoordinatesystem-system", 
            "text": "", 
            "title": "int getZ( MicroBitCoordinateSystem system)"
        }, 
        {
            "location": "/ubit/accelerometer/#description_13", 
            "text": "Reads the Z axis value of the latest update from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters_5", 
            "text": "MicroBitCoordinateSystem   system  - The coordinate system to use. By default, a simple cartesian system is provided.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_12", 
            "text": "The force measured in the Z axis, in milli-g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_7", 
            "text": "uBit.accelerometer.getZ();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getpitch", 
            "text": "", 
            "title": "getPitch"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getpitch", 
            "text": "", 
            "title": "int getPitch()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_14", 
            "text": "Provides a rotation compensated pitch of the device, based on the latest update from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_13", 
            "text": "The pitch of the device, in degrees.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_8", 
            "text": "uBit.accelerometer.getPitch();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getpitchradians", 
            "text": "", 
            "title": "getPitchRadians"
        }, 
        {
            "location": "/ubit/accelerometer/#float-getpitchradians", 
            "text": "", 
            "title": "float getPitchRadians()"
        }, 
        {
            "location": "/ubit/accelerometer/#getroll", 
            "text": "", 
            "title": "getRoll"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getroll", 
            "text": "", 
            "title": "int getRoll()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_15", 
            "text": "Provides a rotation compensated roll of the device, based on the latest update from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_14", 
            "text": "The roll of the device, in degrees.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_9", 
            "text": "uBit.accelerometer.getRoll();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getrollradians", 
            "text": "", 
            "title": "getRollRadians"
        }, 
        {
            "location": "/ubit/accelerometer/#float-getrollradians", 
            "text": "", 
            "title": "float getRollRadians()"
        }, 
        {
            "location": "/ubit/accelerometer/#getgesture", 
            "text": "", 
            "title": "getGesture"
        }, 
        {
            "location": "/ubit/accelerometer/#basicgesture-getgesture", 
            "text": "", 
            "title": "BasicGesture getGesture()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_16", 
            "text": "Reads the last recorded gesture detected.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_15", 
            "text": "The last gesture detected.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_10", 
            "text": "if (uBit.accelerometer.getGesture() == SHAKE)", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#isidlecallbackneeded", 
            "text": "", 
            "title": "isIdleCallbackNeeded"
        }, 
        {
            "location": "/ubit/accelerometer/#int-isidlecallbackneeded", 
            "text": "", 
            "title": "int isIdleCallbackNeeded()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_17", 
            "text": "Returns 0 or 1. 1 indicates data is waiting to be read, zero means data is not ready to be read.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#microbitaccelerometer", 
            "text": "", 
            "title": "~MicroBitAccelerometer"
        }, 
        {
            "location": "/ubit/accelerometer/#microbitaccelerometer_1", 
            "text": "", 
            "title": "~MicroBitAccelerometer()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_18", 
            "text": "Destructor for  MicroBitButton", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/", 
            "text": "uBit.compass\n\n\nOverview\n\n\nOnboard the micro:bit is an electronic magnetometer. Like the \naccelerometer\n, the\n\nmagnetometer is linked to the \ni2c\n bus, which is used to access data\non the magnetometer.\n\n\nThe magnetometer provides information about the magnetic field where a micro:bit\nis situated, crucially providing an indication of where magnetic North is located.\n\n\nRaw magnetic field information alone is not enough to provide accurate\ncompass headings. Therefore, the \naccelerometer\n is used in\nconjunction with the magnetometer to reduce the inaccuracy of the magnetometer reading.\n\n\nThe magnetometer is inaccurate because it considers all 3 planes: x, y and z.\nThe heading North only exists in the horizontal planes (x and y), therefore we only\nneed values in these planes. The accelerometer is used to filter out the vertical plane (z)\nto make our headings far more accurate. You can see this in action when calibrating the compass.\n\n\nAfter calibration has been performed, the end product is an e-compass!\n\n\nWhen using the standard uBit presentation, the compass is continuously updated\nin the background using an idle thread, which is executed whenever the micro:bit\nhas no other tasks to perform.\n\n\nIf there is no scheduler running, the values are synchronously read on \nget[X,Y,Z]()\n and \nheading()\n\ncalls. Additionally, if you would like to drive compass updates manually \nupdateSample()\n\ncan be used.\n\n\nThe micro:bit uses the \nNXP MAG3110\n.\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_COMPASS\n\n\n5\n\n\n\n\n\n\n\n\nMessage Bus Events\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CAL_REQUIRED\n\n\n1 \n(DEPRECATED)\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CAL_START\n\n\n2 \n(DEPRECATED)\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CAL_END\n\n\n3 \n(DEPRECATED)\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_DATA_UPDATE\n\n\n4\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CONFIG_NEEDED\n\n\n5\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CALIBRATE\n\n\n6\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitCompass( \nuint16_t\n id,  \nuint16_t\n address)\n\n\nDescription\n\n\nConstructor. Create a compass representation with the given ID.\n\n\nParameters\n\n\n\n\nuint16_t\n \nid\n - the event ID of the compass object.\n\n\nuint16_t\n \naddress\n - the default address for the compass register\n\n\n\n\nExample\n\n\n compass(MICROBIT_ID_COMPASS, MAG3110_DEFAULT_ADDR);\n\n\n\n\n\nconfigure\n\n\n\n\nint\n configure()\n\n\nDescription\n\n\nConfigures the compass for the sample rate defined in this object. The nearest values are chosen to those defined that are supported by the hardware. The instance variables are then updated to reflect reality.\n\n\nReturns\n\n\nMICROBIT_OK or MICROBIT_I2C_ERROR if the magnetometer could not be configured.\n\n\nsetPeriod\n\n\n\n\nint\n setPeriod( \nint\n period)\n\n\nDescription\n\n\nAttempts to set the sample rate of the compass to the specified value (in ms). n.b. the requested rate may not be possible on the hardware. In this case, the nearest lower rate is chosen.\n\n\nParameters\n\n\n\n\nint\n \nperiod\n - the requested time between samples, in milliseconds.\n\n\n\n\nReturns\n\n\nMICROBIT_OK or MICROBIT_I2C_ERROR if the magnetometer could not be updated.\n\n\ngetPeriod\n\n\n\n\nint\n getPeriod()\n\n\nDescription\n\n\nReads the currently configured sample rate of the compass.\n\n\nReturns\n\n\nThe time between samples, in milliseconds.\n\n\nheading\n\n\n\n\nint\n heading()\n\n\nDescription\n\n\nGets the current heading of the device, relative to magnetic north. If the compass is not calibrated, it will raise the MICROBIT_COMPASS_EVT_CALIBRATE event. Users wishing to implement their own calibration algorithms should listen for this event, using MESSAGE_BUS_LISTENER_IMMEDIATE model. This ensures that calibration is complete before the user program continues.\n\n\nReturns\n\n\nthe current heading, in degrees. Or MICROBIT_CALIBRATION_IN_PROGRESS if the compass is calibrating.\n\n\nExample\n\n\n uBit.compass.heading();\n\n\n\n\n\nwhoAmI\n\n\n\n\nint\n whoAmI()\n\n\nDescription\n\n\nAttempts to determine the 8 bit ID from the magnetometer.\n\n\nReturns\n\n\nthe id of the compass (magnetometer), or MICROBIT_I2C_ERROR if the magnetometer could not be updated.\n\n\nExample\n\n\n uBit.compass.whoAmI();\n\n\n\n\n\ngetX\n\n\n\n\nint\n getX()\n\n\nDescription\n\n\nReads the X axis value of the latest update from the compass.\n\n\nReturns\n\n\nThe magnetic force measured in the X axis, in nano teslas.\n\n\nExample\n\n\n uBit.compass.getX();\n\n\n\n\n\n\n\nint\n getX( \nMicroBitCoordinateSystem\n system)\n\n\nDescription\n\n\nReads the X axis value of the latest update from the compass.\n\n\nParameters\n\n\n\n\nMicroBitCoordinateSystem\n \nsystem\n\n\n\n\nReturns\n\n\nThe magnetic force measured in the X axis, in nano teslas.\n\n\nExample\n\n\n uBit.compass.getX();\n\n\n\n\n\ngetY\n\n\n\n\nint\n getY()\n\n\nDescription\n\n\nReads the Y axis value of the latest update from the compass.\n\n\nReturns\n\n\nThe magnetic force measured in the Y axis, in nano teslas.\n\n\nExample\n\n\n uBit.compass.getY();\n\n\n\n\n\n\n\nint\n getY( \nMicroBitCoordinateSystem\n system)\n\n\nDescription\n\n\nReads the Y axis value of the latest update from the compass.\n\n\nParameters\n\n\n\n\nMicroBitCoordinateSystem\n \nsystem\n\n\n\n\nReturns\n\n\nThe magnetic force measured in the Y axis, in nano teslas.\n\n\nExample\n\n\n uBit.compass.getY();\n\n\n\n\n\ngetZ\n\n\n\n\nint\n getZ()\n\n\nDescription\n\n\nReads the Z axis value of the latest update from the compass.\n\n\nReturns\n\n\nThe magnetic force measured in the Z axis, in nano teslas.\n\n\nExample\n\n\n uBit.compass.getZ();\n\n\n\n\n\n\n\nint\n getZ( \nMicroBitCoordinateSystem\n system)\n\n\nDescription\n\n\nReads the Z axis value of the latest update from the compass.\n\n\nParameters\n\n\n\n\nMicroBitCoordinateSystem\n \nsystem\n\n\n\n\nReturns\n\n\nThe magnetic force measured in the Z axis, in nano teslas.\n\n\nExample\n\n\n uBit.compass.getZ();\n\n\n\n\n\ngetFieldStrength\n\n\n\n\nint\n getFieldStrength()\n\n\nDescription\n\n\nDetermines the overall magnetic field strength based on the latest update from the compass.\n\n\nReturns\n\n\nThe magnetic force measured across all axes, in nano teslas.\n\n\nExample\n\n\n uBit.compass.getFieldStrength();\n\n\n\n\n\nreadTemperature\n\n\n\n\nint\n readTemperature()\n\n\nDescription\n\n\nReads the current die temperature of the compass.\n\n\nReturns\n\n\nthe temperature in degrees celsius, or MICROBIT_I2C_ERROR if the magnetometer could not be updated.\n\n\ncalibrate\n\n\n\n\nint\n calibrate()\n\n\nDescription\n\n\nPerform a calibration of the compass.\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_I2C_ERROR if the magnetometer could not be accessed, or MICROBIT_CALIBRATION_REQUIRED if the calibration algorithm failed to complete succesfully.\n\n\n\n\nNote\n\n\nTHIS MUST BE CALLED TO GAIN RELIABLE VALUES FROM THE COMPASS\n\n\n\n\ncalibrateAsync\n\n\n\n\nvoid\n calibrateAsync()\n\n\nDescription\n\n\nPerform the asynchronous calibration of the compass. This will fire MICROBIT_COMPASS_EVT_CAL_START and MICROBIT_COMPASS_EVT_CAL_END when finished.  calibrate()\n\n\nReturns\n\n\nMICROBIT_OK, or MICROBIT_I2C_ERROR if the magnetometer could not be accessed.\n\n\n\n\nNote\n\n\n THIS FUNCITON IS NOW DEPRECATED AND WILL BE REMOVED IN THE NEXT MAJOR RELEASE \n\n\n\n\ncalibrateStart\n\n\n\n\nint\n calibrateStart()\n\n\nDescription\n\n\nPerform a calibration of the compass. This will fire MICROBIT_COMPASS_EVT_CAL_START.\n\n\nReturns\n\n\nMICROBIT_OK, or MICROBIT_I2C_ERROR if the magnetometer could not be accessed.\n\n\n\n\nNote\n\n\n THIS FUNCITON IS NOW DEPRECATED AND WILL BE REMOVED IN THE NEXT MAJOR RELEASE \n\n\n\n\ncalibrateEnd\n\n\n\n\nvoid\n calibrateEnd()\n\n\nDescription\n\n\nComplete the calibration of the compass. This will fire MICROBIT_COMPASS_EVT_CAL_END.\n\n\n\n\nNote\n\n\n THIS FUNCITON IS NOW DEPRECATED AND WILL BE REMOVED IN THE NEXT MAJOR RELEASE \n\n\n\n\nsetCalibration\n\n\n\n\nvoid\n setCalibration( \nCompassSample\n calibration)\n\n\nDescription\n\n\nConfigure the compass to use the given calibration data. Calibration data is comprised of the perceived zero offset of each axis of the compass. After calibration this should now take into account trimming errors in the magnetometer, and any \"hard iron\" offsets on the device.\n\n\nParameters\n\n\n\n\nCompassSample\n \ncalibration\n\n\n\n\ngetCalibration\n\n\n\n\nCompassSample\n getCalibration()\n\n\nDescription\n\n\nProvides the calibration data currently in use by the compass. More specifically, the x, y and z zero offsets of the compass.\n\n\nReturns\n\n\nThe x, y and z xero offsets of the compass.\n\n\nisCalibrated\n\n\n\n\nint\n isCalibrated()\n\n\nDescription\n\n\nReturns 0 or 1. 1 indicates that the compass is calibrated, zero means the compass requires calibration.\n\n\nisCalibrating\n\n\n\n\nint\n isCalibrating()\n\n\nDescription\n\n\nReturns 0 or 1. 1 indicates that the compass is calibrating, zero means the compass is not currently calibrating.\n\n\nclearCalibration\n\n\n\n\nvoid\n clearCalibration()\n\n\nDescription\n\n\nClears the calibration held in persistent storage, and sets the calibrated flag to zero.\n\n\nisIdleCallbackNeeded\n\n\n\n\nint\n isIdleCallbackNeeded()\n\n\nDescription\n\n\nReturns 0 or 1. 1 indicates data is waiting to be read, zero means data is not ready to be read.\n\n\n~MicroBitCompass\n\n\n\n\n~MicroBitCompass()\n\n\nDescription\n\n\nDestructor for  MicroBitCompass", 
            "title": "compass"
        }, 
        {
            "location": "/ubit/compass/#ubitcompass", 
            "text": "", 
            "title": "uBit.compass"
        }, 
        {
            "location": "/ubit/compass/#overview", 
            "text": "Onboard the micro:bit is an electronic magnetometer. Like the  accelerometer , the \nmagnetometer is linked to the  i2c  bus, which is used to access data\non the magnetometer.  The magnetometer provides information about the magnetic field where a micro:bit\nis situated, crucially providing an indication of where magnetic North is located.  Raw magnetic field information alone is not enough to provide accurate\ncompass headings. Therefore, the  accelerometer  is used in\nconjunction with the magnetometer to reduce the inaccuracy of the magnetometer reading.  The magnetometer is inaccurate because it considers all 3 planes: x, y and z.\nThe heading North only exists in the horizontal planes (x and y), therefore we only\nneed values in these planes. The accelerometer is used to filter out the vertical plane (z)\nto make our headings far more accurate. You can see this in action when calibrating the compass.  After calibration has been performed, the end product is an e-compass!  When using the standard uBit presentation, the compass is continuously updated\nin the background using an idle thread, which is executed whenever the micro:bit\nhas no other tasks to perform.  If there is no scheduler running, the values are synchronously read on  get[X,Y,Z]()  and  heading() \ncalls. Additionally, if you would like to drive compass updates manually  updateSample() \ncan be used.  The micro:bit uses the  NXP MAG3110 .", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/compass/#message-bus-id", 
            "text": "Constant  Value      MICROBIT_ID_COMPASS  5", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/compass/#message-bus-events", 
            "text": "Constant  Value      MICROBIT_COMPASS_EVT_CAL_REQUIRED  1  (DEPRECATED)    MICROBIT_COMPASS_EVT_CAL_START  2  (DEPRECATED)    MICROBIT_COMPASS_EVT_CAL_END  3  (DEPRECATED)    MICROBIT_COMPASS_EVT_DATA_UPDATE  4    MICROBIT_COMPASS_EVT_CONFIG_NEEDED  5    MICROBIT_COMPASS_EVT_CALIBRATE  6", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/compass/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/compass/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-uint16_t-id-uint16_t-address", 
            "text": "", 
            "title": "MicroBitCompass( uint16_t id,  uint16_t address)"
        }, 
        {
            "location": "/ubit/compass/#description", 
            "text": "Constructor. Create a compass representation with the given ID.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters", 
            "text": "uint16_t   id  - the event ID of the compass object.  uint16_t   address  - the default address for the compass register", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example", 
            "text": "compass(MICROBIT_ID_COMPASS, MAG3110_DEFAULT_ADDR);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#configure", 
            "text": "", 
            "title": "configure"
        }, 
        {
            "location": "/ubit/compass/#int-configure", 
            "text": "", 
            "title": "int configure()"
        }, 
        {
            "location": "/ubit/compass/#description_1", 
            "text": "Configures the compass for the sample rate defined in this object. The nearest values are chosen to those defined that are supported by the hardware. The instance variables are then updated to reflect reality.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns", 
            "text": "MICROBIT_OK or MICROBIT_I2C_ERROR if the magnetometer could not be configured.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#setperiod", 
            "text": "", 
            "title": "setPeriod"
        }, 
        {
            "location": "/ubit/compass/#int-setperiod-int-period", 
            "text": "", 
            "title": "int setPeriod( int period)"
        }, 
        {
            "location": "/ubit/compass/#description_2", 
            "text": "Attempts to set the sample rate of the compass to the specified value (in ms). n.b. the requested rate may not be possible on the hardware. In this case, the nearest lower rate is chosen.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_1", 
            "text": "int   period  - the requested time between samples, in milliseconds.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#returns_1", 
            "text": "MICROBIT_OK or MICROBIT_I2C_ERROR if the magnetometer could not be updated.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#getperiod", 
            "text": "", 
            "title": "getPeriod"
        }, 
        {
            "location": "/ubit/compass/#int-getperiod", 
            "text": "", 
            "title": "int getPeriod()"
        }, 
        {
            "location": "/ubit/compass/#description_3", 
            "text": "Reads the currently configured sample rate of the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_2", 
            "text": "The time between samples, in milliseconds.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#heading", 
            "text": "", 
            "title": "heading"
        }, 
        {
            "location": "/ubit/compass/#int-heading", 
            "text": "", 
            "title": "int heading()"
        }, 
        {
            "location": "/ubit/compass/#description_4", 
            "text": "Gets the current heading of the device, relative to magnetic north. If the compass is not calibrated, it will raise the MICROBIT_COMPASS_EVT_CALIBRATE event. Users wishing to implement their own calibration algorithms should listen for this event, using MESSAGE_BUS_LISTENER_IMMEDIATE model. This ensures that calibration is complete before the user program continues.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_3", 
            "text": "the current heading, in degrees. Or MICROBIT_CALIBRATION_IN_PROGRESS if the compass is calibrating.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_1", 
            "text": "uBit.compass.heading();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#whoami", 
            "text": "", 
            "title": "whoAmI"
        }, 
        {
            "location": "/ubit/compass/#int-whoami", 
            "text": "", 
            "title": "int whoAmI()"
        }, 
        {
            "location": "/ubit/compass/#description_5", 
            "text": "Attempts to determine the 8 bit ID from the magnetometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_4", 
            "text": "the id of the compass (magnetometer), or MICROBIT_I2C_ERROR if the magnetometer could not be updated.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_2", 
            "text": "uBit.compass.whoAmI();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#getx", 
            "text": "", 
            "title": "getX"
        }, 
        {
            "location": "/ubit/compass/#int-getx", 
            "text": "", 
            "title": "int getX()"
        }, 
        {
            "location": "/ubit/compass/#description_6", 
            "text": "Reads the X axis value of the latest update from the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_5", 
            "text": "The magnetic force measured in the X axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_3", 
            "text": "uBit.compass.getX();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#int-getx-microbitcoordinatesystem-system", 
            "text": "", 
            "title": "int getX( MicroBitCoordinateSystem system)"
        }, 
        {
            "location": "/ubit/compass/#description_7", 
            "text": "Reads the X axis value of the latest update from the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_2", 
            "text": "MicroBitCoordinateSystem   system", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#returns_6", 
            "text": "The magnetic force measured in the X axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_4", 
            "text": "uBit.compass.getX();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#gety", 
            "text": "", 
            "title": "getY"
        }, 
        {
            "location": "/ubit/compass/#int-gety", 
            "text": "", 
            "title": "int getY()"
        }, 
        {
            "location": "/ubit/compass/#description_8", 
            "text": "Reads the Y axis value of the latest update from the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_7", 
            "text": "The magnetic force measured in the Y axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_5", 
            "text": "uBit.compass.getY();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#int-gety-microbitcoordinatesystem-system", 
            "text": "", 
            "title": "int getY( MicroBitCoordinateSystem system)"
        }, 
        {
            "location": "/ubit/compass/#description_9", 
            "text": "Reads the Y axis value of the latest update from the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_3", 
            "text": "MicroBitCoordinateSystem   system", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#returns_8", 
            "text": "The magnetic force measured in the Y axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_6", 
            "text": "uBit.compass.getY();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#getz", 
            "text": "", 
            "title": "getZ"
        }, 
        {
            "location": "/ubit/compass/#int-getz", 
            "text": "", 
            "title": "int getZ()"
        }, 
        {
            "location": "/ubit/compass/#description_10", 
            "text": "Reads the Z axis value of the latest update from the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_9", 
            "text": "The magnetic force measured in the Z axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_7", 
            "text": "uBit.compass.getZ();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#int-getz-microbitcoordinatesystem-system", 
            "text": "", 
            "title": "int getZ( MicroBitCoordinateSystem system)"
        }, 
        {
            "location": "/ubit/compass/#description_11", 
            "text": "Reads the Z axis value of the latest update from the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_4", 
            "text": "MicroBitCoordinateSystem   system", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#returns_10", 
            "text": "The magnetic force measured in the Z axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_8", 
            "text": "uBit.compass.getZ();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#getfieldstrength", 
            "text": "", 
            "title": "getFieldStrength"
        }, 
        {
            "location": "/ubit/compass/#int-getfieldstrength", 
            "text": "", 
            "title": "int getFieldStrength()"
        }, 
        {
            "location": "/ubit/compass/#description_12", 
            "text": "Determines the overall magnetic field strength based on the latest update from the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_11", 
            "text": "The magnetic force measured across all axes, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_9", 
            "text": "uBit.compass.getFieldStrength();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#readtemperature", 
            "text": "", 
            "title": "readTemperature"
        }, 
        {
            "location": "/ubit/compass/#int-readtemperature", 
            "text": "", 
            "title": "int readTemperature()"
        }, 
        {
            "location": "/ubit/compass/#description_13", 
            "text": "Reads the current die temperature of the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_12", 
            "text": "the temperature in degrees celsius, or MICROBIT_I2C_ERROR if the magnetometer could not be updated.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#calibrate", 
            "text": "", 
            "title": "calibrate"
        }, 
        {
            "location": "/ubit/compass/#int-calibrate", 
            "text": "", 
            "title": "int calibrate()"
        }, 
        {
            "location": "/ubit/compass/#description_14", 
            "text": "Perform a calibration of the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_13", 
            "text": "MICROBIT_OK, MICROBIT_I2C_ERROR if the magnetometer could not be accessed, or MICROBIT_CALIBRATION_REQUIRED if the calibration algorithm failed to complete succesfully.   Note  THIS MUST BE CALLED TO GAIN RELIABLE VALUES FROM THE COMPASS", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#calibrateasync", 
            "text": "", 
            "title": "calibrateAsync"
        }, 
        {
            "location": "/ubit/compass/#void-calibrateasync", 
            "text": "", 
            "title": "void calibrateAsync()"
        }, 
        {
            "location": "/ubit/compass/#description_15", 
            "text": "Perform the asynchronous calibration of the compass. This will fire MICROBIT_COMPASS_EVT_CAL_START and MICROBIT_COMPASS_EVT_CAL_END when finished.  calibrate()", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_14", 
            "text": "MICROBIT_OK, or MICROBIT_I2C_ERROR if the magnetometer could not be accessed.   Note   THIS FUNCITON IS NOW DEPRECATED AND WILL BE REMOVED IN THE NEXT MAJOR RELEASE", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#calibratestart", 
            "text": "", 
            "title": "calibrateStart"
        }, 
        {
            "location": "/ubit/compass/#int-calibratestart", 
            "text": "", 
            "title": "int calibrateStart()"
        }, 
        {
            "location": "/ubit/compass/#description_16", 
            "text": "Perform a calibration of the compass. This will fire MICROBIT_COMPASS_EVT_CAL_START.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_15", 
            "text": "MICROBIT_OK, or MICROBIT_I2C_ERROR if the magnetometer could not be accessed.   Note   THIS FUNCITON IS NOW DEPRECATED AND WILL BE REMOVED IN THE NEXT MAJOR RELEASE", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#calibrateend", 
            "text": "", 
            "title": "calibrateEnd"
        }, 
        {
            "location": "/ubit/compass/#void-calibrateend", 
            "text": "", 
            "title": "void calibrateEnd()"
        }, 
        {
            "location": "/ubit/compass/#description_17", 
            "text": "Complete the calibration of the compass. This will fire MICROBIT_COMPASS_EVT_CAL_END.   Note   THIS FUNCITON IS NOW DEPRECATED AND WILL BE REMOVED IN THE NEXT MAJOR RELEASE", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#setcalibration", 
            "text": "", 
            "title": "setCalibration"
        }, 
        {
            "location": "/ubit/compass/#void-setcalibration-compasssample-calibration", 
            "text": "", 
            "title": "void setCalibration( CompassSample calibration)"
        }, 
        {
            "location": "/ubit/compass/#description_18", 
            "text": "Configure the compass to use the given calibration data. Calibration data is comprised of the perceived zero offset of each axis of the compass. After calibration this should now take into account trimming errors in the magnetometer, and any \"hard iron\" offsets on the device.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_5", 
            "text": "CompassSample   calibration", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#getcalibration", 
            "text": "", 
            "title": "getCalibration"
        }, 
        {
            "location": "/ubit/compass/#compasssample-getcalibration", 
            "text": "", 
            "title": "CompassSample getCalibration()"
        }, 
        {
            "location": "/ubit/compass/#description_19", 
            "text": "Provides the calibration data currently in use by the compass. More specifically, the x, y and z zero offsets of the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_16", 
            "text": "The x, y and z xero offsets of the compass.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#iscalibrated", 
            "text": "", 
            "title": "isCalibrated"
        }, 
        {
            "location": "/ubit/compass/#int-iscalibrated", 
            "text": "", 
            "title": "int isCalibrated()"
        }, 
        {
            "location": "/ubit/compass/#description_20", 
            "text": "Returns 0 or 1. 1 indicates that the compass is calibrated, zero means the compass requires calibration.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#iscalibrating", 
            "text": "", 
            "title": "isCalibrating"
        }, 
        {
            "location": "/ubit/compass/#int-iscalibrating", 
            "text": "", 
            "title": "int isCalibrating()"
        }, 
        {
            "location": "/ubit/compass/#description_21", 
            "text": "Returns 0 or 1. 1 indicates that the compass is calibrating, zero means the compass is not currently calibrating.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#clearcalibration", 
            "text": "", 
            "title": "clearCalibration"
        }, 
        {
            "location": "/ubit/compass/#void-clearcalibration", 
            "text": "", 
            "title": "void clearCalibration()"
        }, 
        {
            "location": "/ubit/compass/#description_22", 
            "text": "Clears the calibration held in persistent storage, and sets the calibrated flag to zero.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#isidlecallbackneeded", 
            "text": "", 
            "title": "isIdleCallbackNeeded"
        }, 
        {
            "location": "/ubit/compass/#int-isidlecallbackneeded", 
            "text": "", 
            "title": "int isIdleCallbackNeeded()"
        }, 
        {
            "location": "/ubit/compass/#description_23", 
            "text": "Returns 0 or 1. 1 indicates data is waiting to be read, zero means data is not ready to be read.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass", 
            "text": "", 
            "title": "~MicroBitCompass"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass_1", 
            "text": "", 
            "title": "~MicroBitCompass()"
        }, 
        {
            "location": "/ubit/compass/#description_24", 
            "text": "Destructor for  MicroBitCompass", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/", 
            "text": "uBit.thermometer\n\n\nOverview\n\n\nMessage Bus ID\n\n\nMessage Bus Events\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitThermometer( \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor. Create new object that can sense temperature.  MicroBitThermometer\n\n\nParameters\n\n\n\n\nuint16_t\n \nid\n - the ID of the new  MicroBitThermometer  object.\n\n\n\n\nExample\n\n\n thermometer(MICROBIT_ID_THERMOMETER); \n\n\n\n\n\nsetPeriod\n\n\n\n\nvoid\n setPeriod( \nint\n period)\n\n\nDescription\n\n\nSet the sample rate at which the temperatureis read (in ms). n.b. the temperature is alwasy read in the background, so wis only updated when the processor is idle, or when the temperature is explicitly read. The default sample period is 1 second. \n\n\nParameters\n\n\n\n\nint\n \nperiod\n - the requested time between samples, in milliseconds. \n\n\n\n\ngetPeriod\n\n\n\n\nint\n getPeriod()\n\n\nDescription\n\n\nReads the currently configured sample rate of the thermometer. \n\n\nReturns\n\n\nThe time between samples, in milliseconds. \n\n\ngetTemperature\n\n\n\n\nint\n getTemperature()\n\n\nDescription\n\n\nGets the current temperature of the microbit. \n\n\nReturns\n\n\nthe current temperature, in degrees celsius.\n\n\nExample\n\n\n uBit.thermometer.getTemperature(); \n\n\n\n\n\nisIdleCallbackNeeded\n\n\n\n\nint\n isIdleCallbackNeeded()\n\n\nDescription\n\n\nIndicates if we'd like some processor time to sense the temperature. 0 means we're not due to read the tmeperature yet. \n\n\nReturns\n\n\n1 if we'd like some processor time, 0 otherwise.", 
            "title": "thermometer"
        }, 
        {
            "location": "/ubit/thermometer/#ubitthermometer", 
            "text": "", 
            "title": "uBit.thermometer"
        }, 
        {
            "location": "/ubit/thermometer/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/thermometer/#message-bus-id", 
            "text": "", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/thermometer/#message-bus-events", 
            "text": "", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/thermometer/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/thermometer/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/thermometer/#microbitthermometer-uint16_t-id", 
            "text": "", 
            "title": "MicroBitThermometer( uint16_t id)"
        }, 
        {
            "location": "/ubit/thermometer/#description", 
            "text": "Constructor. Create new object that can sense temperature.  MicroBitThermometer", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#parameters", 
            "text": "uint16_t   id  - the ID of the new  MicroBitThermometer  object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/thermometer/#example", 
            "text": "thermometer(MICROBIT_ID_THERMOMETER);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/thermometer/#setperiod", 
            "text": "", 
            "title": "setPeriod"
        }, 
        {
            "location": "/ubit/thermometer/#void-setperiod-int-period", 
            "text": "", 
            "title": "void setPeriod( int period)"
        }, 
        {
            "location": "/ubit/thermometer/#description_1", 
            "text": "Set the sample rate at which the temperatureis read (in ms). n.b. the temperature is alwasy read in the background, so wis only updated when the processor is idle, or when the temperature is explicitly read. The default sample period is 1 second.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#parameters_1", 
            "text": "int   period  - the requested time between samples, in milliseconds.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/thermometer/#getperiod", 
            "text": "", 
            "title": "getPeriod"
        }, 
        {
            "location": "/ubit/thermometer/#int-getperiod", 
            "text": "", 
            "title": "int getPeriod()"
        }, 
        {
            "location": "/ubit/thermometer/#description_2", 
            "text": "Reads the currently configured sample rate of the thermometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#returns", 
            "text": "The time between samples, in milliseconds.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/thermometer/#gettemperature", 
            "text": "", 
            "title": "getTemperature"
        }, 
        {
            "location": "/ubit/thermometer/#int-gettemperature", 
            "text": "", 
            "title": "int getTemperature()"
        }, 
        {
            "location": "/ubit/thermometer/#description_3", 
            "text": "Gets the current temperature of the microbit.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#returns_1", 
            "text": "the current temperature, in degrees celsius.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/thermometer/#example_1", 
            "text": "uBit.thermometer.getTemperature();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/thermometer/#isidlecallbackneeded", 
            "text": "", 
            "title": "isIdleCallbackNeeded"
        }, 
        {
            "location": "/ubit/thermometer/#int-isidlecallbackneeded", 
            "text": "", 
            "title": "int isIdleCallbackNeeded()"
        }, 
        {
            "location": "/ubit/thermometer/#description_4", 
            "text": "Indicates if we'd like some processor time to sense the temperature. 0 means we're not due to read the tmeperature yet.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#returns_2", 
            "text": "1 if we'd like some processor time, 0 otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/", 
            "text": "uBit.io\n\n\nOverview\n\n\nuBit.io\n provides a means of accessing the pins exposed on the edge connector,\nenabling Analog and Digital Input/Output operations. Some pins can also perform\nbasic touch sensing through resistance detection.\n\n\nThere are 6 Analog capable pins which can be used to generate Analog wave forms\nand approximate Analog inputs. There is only one Analog to Digital converter on\nthe NRF51822, which prevents concurrent analog to digital conversions.\n\n\nAnalog waveforms are simulated via Pulse Width Modulation generated by software.\nAs such, there is a limit of \n3\n concurrent PWM outputs.\n\n\nThere are two ways of accessing pins on the edge connector:\n\n\n\n\nuBit.io.P0.setDigitalValue(1)\n - Would configure P0 as a digital output, and set that pin HI.\n\n\nuBit.io.pin[1].setDigitalValue(1)\n - Would configure P1 as a digital output, and set that pin HI.\n\n\n\n\nBy design, the operation of the pins on the edge connector are dynamic, and can swap between\nmodes based on the method that as been called.\n\n\nFor example:\n\n\nwhile(1)\n{\n    uBit.io.P0.setDigitalValue(1);\n    uBit.sleep(1000);\n    uBit.io.P0.setServoValue(90);\n    uBit.sleep(1000);\n}\n\n\n\n\nWill transition between Digital and Analog output every second.\n\n\nShared Functionality\n\n\nAs well as being General Purpose Input Output (\nGPIO\n) pins, some pins on the\nmicro:bit have other functionality used internally by the micro:bit.\n\n\nTherefore, some functionality on the micro:bit may have to be disabled in order\nto use some GPIO pins.\n\n\nThis is illustrated by the diagram below:\n\n\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\nCapability\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_IO_P0\n\n\n7\n\n\nAnalog, digital and touch\n\n\n\n\n\n\nMICROBIT_ID_IO_P1\n\n\n8\n\n\nAnalog, digital and touch\n\n\n\n\n\n\nMICROBIT_ID_IO_P2\n\n\n9\n\n\nAnalog, digital and touch\n\n\n\n\n\n\nMICROBIT_ID_IO_P3\n\n\n10\n\n\nAnalog and digital\n\n\n\n\n\n\nMICROBIT_ID_IO_P4\n\n\n11\n\n\nAnalog and digital\n\n\n\n\n\n\nMICROBIT_ID_IO_P5\n\n\n12\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P6\n\n\n13\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P7\n\n\n14\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P8\n\n\n15\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P9\n\n\n16\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P10\n\n\n17\n\n\nAnalog and digital\n\n\n\n\n\n\nMICROBIT_ID_IO_P11\n\n\n18\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P12\n\n\n19\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P13\n\n\n20\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P14\n\n\n21\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P15\n\n\n22\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P16\n\n\n23\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P19\n\n\n24\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P20\n\n\n25\n\n\nDigital only\n\n\n\n\n\n\n\n\nMessage Bus Events\n\n\nWhen \nisTouched()\n is called, provided that the selected pin has touch capabilities\n(outlined above), an instance of \nbutton\n will be created. Listeners\ncan therefore be placed using the desired pins' ID, with the exact same events\nproduced by a standard \nbutton\n.\n\n\nuBit.messageBus.listen(MICROBIT_ID_IO_P0, MICROBIT_EVT_ANY, someFunction);\nuBit.io.P0.isTouched();\n\n\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOWN\n\n\n1\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_UP\n\n\n2\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_CLICK\n\n\n3\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_LONG_CLICK\n\n\n4\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_HOLD\n\n\n5\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOUBLE_CLICK\n\n\n6\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitPin( \nint\n id,  \nPinName\n name,  \nPinCapability\n capability)\n\n\nDescription\n\n\nConstructor. Create a Button representation with the given ID.  MicroBitPin\n\n\nParameters\n\n\n\n\nint\n \nid\n - the ID of the new Pin object.\n\n\nPinName\n \nname\n - the pin name for this  MicroBitPin  instance to represent\n\n\nPinCapability\n \ncapability\n - the capability of this pin.\n\n\n\n\nExample\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH);\n\n\n\n\n\nsetDigitalValue\n\n\n\n\nint\n setDigitalValue( \nint\n value)\n\n\nDescription\n\n\nConfigures this IO pin as a digital output (if necessary) and sets the pin to 'value'.\n\n\nParameters\n\n\n\n\nint\n \nvalue\n - 0 (LO) or 1 (HI)\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have digital capability.\n\n\nExample\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH);\n P0.setDigitalValue(1); // P0 is now HI\n\n\n\n\n\ngetDigitalValue\n\n\n\n\nint\n getDigitalValue()\n\n\nDescription\n\n\nConfigures this IO pin as a digital input (if necessary) and tests its current value.\n\n\nReturns\n\n\n1 if this input is high, 0 if input is LO, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.\n\n\nExample\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH);\n P0.getDigitalValue(); // P0 is either 0 or 1;\n\n\n\n\n\nsetAnalogValue\n\n\n\n\nint\n setAnalogValue( \nint\n value)\n\n\nDescription\n\n\nConfigures this IO pin as an analog/pwm output, and change the output value to the given level.\n\n\nParameters\n\n\n\n\nint\n \nvalue\n - the level to set on the output pin, in the range 0 - 1024\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.\n\n\nsetServoValue\n\n\n\n\nint\n setServoValue( \nint\n value)\n\n\nDescription\n\n\nConfigures this IO pin as an analog/pwm output if it isn't already, configures the period to be 20ms, and sets the duty cycle between 0.05 and 0.1 (i.e. 5% or 10%) based on the value given to this method.\n\n\nParameters\n\n\n\n\nint\n \nvalue\n - the level to set on the output pin, in the range 0 - 180\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.\n\n\n\nint\n setServoValue( \nint\n value,  \nint\n range)\n\n\nDescription\n\n\nConfigures this IO pin as an analog/pwm output if it isn't already, configures the period to be 20ms, and sets the duty cycle between 0.05 and 0.1 (i.e. 5% or 10%) based on the value given to this method.\n\n\nParameters\n\n\n\n\nint\n \nvalue\n - the level to set on the output pin, in the range 0 - 180\n\n\nint\n \nrange\n - which gives the span of possible values the i.e. lower and upper bounds center  range/2 (Defaults to: MICROBIT_PIN_DEFAULT_SERVO_RANGE)\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.\n\n\n\nint\n setServoValue( \nint\n value,  \nint\n range,  \nint\n center)\n\n\nDescription\n\n\nConfigures this IO pin as an analog/pwm output if it isn't already, configures the period to be 20ms, and sets the duty cycle between 0.05 and 0.1 (i.e. 5% or 10%) based on the value given to this method.\n\n\nParameters\n\n\n\n\nint\n \nvalue\n - the level to set on the output pin, in the range 0 - 180\n\n\nint\n \nrange\n - which gives the span of possible values the i.e. lower and upper bounds center  range/2 (Defaults to: MICROBIT_PIN_DEFAULT_SERVO_RANGE)\n\n\nint\n \ncenter\n - the center point from which to calculate the lower and upper bounds (Defaults to: MICROBIT_PIN_DEFAULT_SERVO_CENTER)\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.\n\n\ngetAnalogValue\n\n\n\n\nint\n getAnalogValue()\n\n\nDescription\n\n\nConfigures this IO pin as an analogue input (if necessary and possible).\n\n\nReturns\n\n\nthe current analogue level on the pin, in the range 0 - 1024, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.\n\n\nExample\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH);\n P0.getAnalogValue(); // P0 is a value in the range of 0 - 1024\n\n\n\n\n\nisInput\n\n\n\n\nint\n isInput()\n\n\nDescription\n\n\nDetermines if this IO pin is currently configured as an input.\n\n\nReturns\n\n\n1 if pin is an analog or digital input, 0 otherwise.\n\n\nisOutput\n\n\n\n\nint\n isOutput()\n\n\nDescription\n\n\nDetermines if this IO pin is currently configured as an output.\n\n\nReturns\n\n\n1 if pin is an analog or digital output, 0 otherwise.\n\n\nisDigital\n\n\n\n\nint\n isDigital()\n\n\nDescription\n\n\nDetermines if this IO pin is currently configured for digital use.\n\n\nReturns\n\n\n1 if pin is digital, 0 otherwise.\n\n\nisAnalog\n\n\n\n\nint\n isAnalog()\n\n\nDescription\n\n\nDetermines if this IO pin is currently configured for analog use.\n\n\nReturns\n\n\n1 if pin is analog, 0 otherwise.\n\n\nisTouched\n\n\n\n\nint\n isTouched()\n\n\nDescription\n\n\nConfigures this IO pin as a makey makey style touch sensor (if necessary) and tests its current debounced state.\n\n\nReturns\n\n\n1 if pin is touched, 0 if not, or MICROBIT_NOT_SUPPORTED if this pin does not support touch capability.\n\n\nExample\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_ALL);\n if(P0.isTouched())\n {\n uBit.display.clear();\n }\n\n\n\n\n\nsetServoPulseUs\n\n\n\n\nint\n setServoPulseUs( \nint\n pulseWidth)\n\n\nDescription\n\n\nConfigures this IO pin as an analog/pwm output if it isn't already, configures the period to be 20ms, and sets the pulse width, based on the value it is given\n\n\nParameters\n\n\n\n\nint\n \npulseWidth\n - the desired pulse width in microseconds.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.\n\n\nsetAnalogPeriod\n\n\n\n\nint\n setAnalogPeriod( \nint\n period)\n\n\nDescription\n\n\nConfigures the PWM period of the analog output to the given value.\n\n\nParameters\n\n\n\n\nint\n \nperiod\n - The new period for the analog output in milliseconds.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.\n\n\nsetAnalogPeriodUs\n\n\n\n\nint\n setAnalogPeriodUs( \nint\n period)\n\n\nDescription\n\n\nConfigures the PWM period of the analog output to the given value.\n\n\nParameters\n\n\n\n\nint\n \nperiod\n - The new period for the analog output in microseconds.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.\n\n\ngetAnalogPeriodUs\n\n\n\n\nint\n getAnalogPeriodUs()\n\n\nDescription\n\n\nRetrieves the PWM period of the analog output.\n\n\nReturns\n\n\nthe period on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.\n\n\ngetAnalogPeriod\n\n\n\n\nint\n getAnalogPeriod()\n\n\nDescription\n\n\nRetrieves the PWM period of the analog output.\n\n\nReturns\n\n\nthe period on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.", 
            "title": "io"
        }, 
        {
            "location": "/ubit/io/#ubitio", 
            "text": "", 
            "title": "uBit.io"
        }, 
        {
            "location": "/ubit/io/#overview", 
            "text": "uBit.io  provides a means of accessing the pins exposed on the edge connector,\nenabling Analog and Digital Input/Output operations. Some pins can also perform\nbasic touch sensing through resistance detection.  There are 6 Analog capable pins which can be used to generate Analog wave forms\nand approximate Analog inputs. There is only one Analog to Digital converter on\nthe NRF51822, which prevents concurrent analog to digital conversions.  Analog waveforms are simulated via Pulse Width Modulation generated by software.\nAs such, there is a limit of  3  concurrent PWM outputs.  There are two ways of accessing pins on the edge connector:   uBit.io.P0.setDigitalValue(1)  - Would configure P0 as a digital output, and set that pin HI.  uBit.io.pin[1].setDigitalValue(1)  - Would configure P1 as a digital output, and set that pin HI.   By design, the operation of the pins on the edge connector are dynamic, and can swap between\nmodes based on the method that as been called.  For example:  while(1)\n{\n    uBit.io.P0.setDigitalValue(1);\n    uBit.sleep(1000);\n    uBit.io.P0.setServoValue(90);\n    uBit.sleep(1000);\n}  Will transition between Digital and Analog output every second.", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/io/#shared-functionality", 
            "text": "As well as being General Purpose Input Output ( GPIO ) pins, some pins on the\nmicro:bit have other functionality used internally by the micro:bit.  Therefore, some functionality on the micro:bit may have to be disabled in order\nto use some GPIO pins.  This is illustrated by the diagram below:", 
            "title": "Shared Functionality"
        }, 
        {
            "location": "/ubit/io/#message-bus-id", 
            "text": "Constant  Value  Capability      MICROBIT_ID_IO_P0  7  Analog, digital and touch    MICROBIT_ID_IO_P1  8  Analog, digital and touch    MICROBIT_ID_IO_P2  9  Analog, digital and touch    MICROBIT_ID_IO_P3  10  Analog and digital    MICROBIT_ID_IO_P4  11  Analog and digital    MICROBIT_ID_IO_P5  12  Digital only    MICROBIT_ID_IO_P6  13  Digital only    MICROBIT_ID_IO_P7  14  Digital only    MICROBIT_ID_IO_P8  15  Digital only    MICROBIT_ID_IO_P9  16  Digital only    MICROBIT_ID_IO_P10  17  Analog and digital    MICROBIT_ID_IO_P11  18  Digital only    MICROBIT_ID_IO_P12  19  Digital only    MICROBIT_ID_IO_P13  20  Digital only    MICROBIT_ID_IO_P14  21  Digital only    MICROBIT_ID_IO_P15  22  Digital only    MICROBIT_ID_IO_P16  23  Digital only    MICROBIT_ID_IO_P19  24  Digital only    MICROBIT_ID_IO_P20  25  Digital only", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/io/#message-bus-events", 
            "text": "When  isTouched()  is called, provided that the selected pin has touch capabilities\n(outlined above), an instance of  button  will be created. Listeners\ncan therefore be placed using the desired pins' ID, with the exact same events\nproduced by a standard  button .  uBit.messageBus.listen(MICROBIT_ID_IO_P0, MICROBIT_EVT_ANY, someFunction);\nuBit.io.P0.isTouched();     Constant  Value      MICROBIT_BUTTON_EVT_DOWN  1    MICROBIT_BUTTON_EVT_UP  2    MICROBIT_BUTTON_EVT_CLICK  3    MICROBIT_BUTTON_EVT_LONG_CLICK  4    MICROBIT_BUTTON_EVT_HOLD  5    MICROBIT_BUTTON_EVT_DOUBLE_CLICK  6", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/io/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/io/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/io/#microbitpin-int-id-pinname-name-pincapability-capability", 
            "text": "", 
            "title": "MicroBitPin( int id,  PinName name,  PinCapability capability)"
        }, 
        {
            "location": "/ubit/io/#description", 
            "text": "Constructor. Create a Button representation with the given ID.  MicroBitPin", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters", 
            "text": "int   id  - the ID of the new Pin object.  PinName   name  - the pin name for this  MicroBitPin  instance to represent  PinCapability   capability  - the capability of this pin.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#example", 
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/io/#setdigitalvalue", 
            "text": "", 
            "title": "setDigitalValue"
        }, 
        {
            "location": "/ubit/io/#int-setdigitalvalue-int-value", 
            "text": "", 
            "title": "int setDigitalValue( int value)"
        }, 
        {
            "location": "/ubit/io/#description_1", 
            "text": "Configures this IO pin as a digital output (if necessary) and sets the pin to 'value'.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_1", 
            "text": "int   value  - 0 (LO) or 1 (HI)", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have digital capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#example_1", 
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH);\n P0.setDigitalValue(1); // P0 is now HI", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/io/#getdigitalvalue", 
            "text": "", 
            "title": "getDigitalValue"
        }, 
        {
            "location": "/ubit/io/#int-getdigitalvalue", 
            "text": "", 
            "title": "int getDigitalValue()"
        }, 
        {
            "location": "/ubit/io/#description_2", 
            "text": "Configures this IO pin as a digital input (if necessary) and tests its current value.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_1", 
            "text": "1 if this input is high, 0 if input is LO, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#example_2", 
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH);\n P0.getDigitalValue(); // P0 is either 0 or 1;", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/io/#setanalogvalue", 
            "text": "", 
            "title": "setAnalogValue"
        }, 
        {
            "location": "/ubit/io/#int-setanalogvalue-int-value", 
            "text": "", 
            "title": "int setAnalogValue( int value)"
        }, 
        {
            "location": "/ubit/io/#description_3", 
            "text": "Configures this IO pin as an analog/pwm output, and change the output value to the given level.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_2", 
            "text": "int   value  - the level to set on the output pin, in the range 0 - 1024", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_2", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#setservovalue", 
            "text": "", 
            "title": "setServoValue"
        }, 
        {
            "location": "/ubit/io/#int-setservovalue-int-value", 
            "text": "", 
            "title": "int setServoValue( int value)"
        }, 
        {
            "location": "/ubit/io/#description_4", 
            "text": "Configures this IO pin as an analog/pwm output if it isn't already, configures the period to be 20ms, and sets the duty cycle between 0.05 and 0.1 (i.e. 5% or 10%) based on the value given to this method.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_3", 
            "text": "int   value  - the level to set on the output pin, in the range 0 - 180", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_3", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#int-setservovalue-int-value-int-range", 
            "text": "", 
            "title": "int setServoValue( int value,  int range)"
        }, 
        {
            "location": "/ubit/io/#description_5", 
            "text": "Configures this IO pin as an analog/pwm output if it isn't already, configures the period to be 20ms, and sets the duty cycle between 0.05 and 0.1 (i.e. 5% or 10%) based on the value given to this method.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_4", 
            "text": "int   value  - the level to set on the output pin, in the range 0 - 180  int   range  - which gives the span of possible values the i.e. lower and upper bounds center  range/2 (Defaults to: MICROBIT_PIN_DEFAULT_SERVO_RANGE)", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_4", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#int-setservovalue-int-value-int-range-int-center", 
            "text": "", 
            "title": "int setServoValue( int value,  int range,  int center)"
        }, 
        {
            "location": "/ubit/io/#description_6", 
            "text": "Configures this IO pin as an analog/pwm output if it isn't already, configures the period to be 20ms, and sets the duty cycle between 0.05 and 0.1 (i.e. 5% or 10%) based on the value given to this method.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_5", 
            "text": "int   value  - the level to set on the output pin, in the range 0 - 180  int   range  - which gives the span of possible values the i.e. lower and upper bounds center  range/2 (Defaults to: MICROBIT_PIN_DEFAULT_SERVO_RANGE)  int   center  - the center point from which to calculate the lower and upper bounds (Defaults to: MICROBIT_PIN_DEFAULT_SERVO_CENTER)", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_5", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#getanalogvalue", 
            "text": "", 
            "title": "getAnalogValue"
        }, 
        {
            "location": "/ubit/io/#int-getanalogvalue", 
            "text": "", 
            "title": "int getAnalogValue()"
        }, 
        {
            "location": "/ubit/io/#description_7", 
            "text": "Configures this IO pin as an analogue input (if necessary and possible).", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_6", 
            "text": "the current analogue level on the pin, in the range 0 - 1024, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#example_3", 
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH);\n P0.getAnalogValue(); // P0 is a value in the range of 0 - 1024", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/io/#isinput", 
            "text": "", 
            "title": "isInput"
        }, 
        {
            "location": "/ubit/io/#int-isinput", 
            "text": "", 
            "title": "int isInput()"
        }, 
        {
            "location": "/ubit/io/#description_8", 
            "text": "Determines if this IO pin is currently configured as an input.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_7", 
            "text": "1 if pin is an analog or digital input, 0 otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#isoutput", 
            "text": "", 
            "title": "isOutput"
        }, 
        {
            "location": "/ubit/io/#int-isoutput", 
            "text": "", 
            "title": "int isOutput()"
        }, 
        {
            "location": "/ubit/io/#description_9", 
            "text": "Determines if this IO pin is currently configured as an output.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_8", 
            "text": "1 if pin is an analog or digital output, 0 otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#isdigital", 
            "text": "", 
            "title": "isDigital"
        }, 
        {
            "location": "/ubit/io/#int-isdigital", 
            "text": "", 
            "title": "int isDigital()"
        }, 
        {
            "location": "/ubit/io/#description_10", 
            "text": "Determines if this IO pin is currently configured for digital use.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_9", 
            "text": "1 if pin is digital, 0 otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#isanalog", 
            "text": "", 
            "title": "isAnalog"
        }, 
        {
            "location": "/ubit/io/#int-isanalog", 
            "text": "", 
            "title": "int isAnalog()"
        }, 
        {
            "location": "/ubit/io/#description_11", 
            "text": "Determines if this IO pin is currently configured for analog use.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_10", 
            "text": "1 if pin is analog, 0 otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#istouched", 
            "text": "", 
            "title": "isTouched"
        }, 
        {
            "location": "/ubit/io/#int-istouched", 
            "text": "", 
            "title": "int isTouched()"
        }, 
        {
            "location": "/ubit/io/#description_12", 
            "text": "Configures this IO pin as a makey makey style touch sensor (if necessary) and tests its current debounced state.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_11", 
            "text": "1 if pin is touched, 0 if not, or MICROBIT_NOT_SUPPORTED if this pin does not support touch capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#example_4", 
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_ALL);\n if(P0.isTouched())\n {\n uBit.display.clear();\n }", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/io/#setservopulseus", 
            "text": "", 
            "title": "setServoPulseUs"
        }, 
        {
            "location": "/ubit/io/#int-setservopulseus-int-pulsewidth", 
            "text": "", 
            "title": "int setServoPulseUs( int pulseWidth)"
        }, 
        {
            "location": "/ubit/io/#description_13", 
            "text": "Configures this IO pin as an analog/pwm output if it isn't already, configures the period to be 20ms, and sets the pulse width, based on the value it is given", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_6", 
            "text": "int   pulseWidth  - the desired pulse width in microseconds.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_12", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#setanalogperiod", 
            "text": "", 
            "title": "setAnalogPeriod"
        }, 
        {
            "location": "/ubit/io/#int-setanalogperiod-int-period", 
            "text": "", 
            "title": "int setAnalogPeriod( int period)"
        }, 
        {
            "location": "/ubit/io/#description_14", 
            "text": "Configures the PWM period of the analog output to the given value.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_7", 
            "text": "int   period  - The new period for the analog output in milliseconds.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_13", 
            "text": "MICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#setanalogperiodus", 
            "text": "", 
            "title": "setAnalogPeriodUs"
        }, 
        {
            "location": "/ubit/io/#int-setanalogperiodus-int-period", 
            "text": "", 
            "title": "int setAnalogPeriodUs( int period)"
        }, 
        {
            "location": "/ubit/io/#description_15", 
            "text": "Configures the PWM period of the analog output to the given value.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_8", 
            "text": "int   period  - The new period for the analog output in microseconds.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_14", 
            "text": "MICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#getanalogperiodus", 
            "text": "", 
            "title": "getAnalogPeriodUs"
        }, 
        {
            "location": "/ubit/io/#int-getanalogperiodus", 
            "text": "", 
            "title": "int getAnalogPeriodUs()"
        }, 
        {
            "location": "/ubit/io/#description_16", 
            "text": "Retrieves the PWM period of the analog output.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_15", 
            "text": "the period on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#getanalogperiod", 
            "text": "", 
            "title": "getAnalogPeriod"
        }, 
        {
            "location": "/ubit/io/#int-getanalogperiod", 
            "text": "", 
            "title": "int getAnalogPeriod()"
        }, 
        {
            "location": "/ubit/io/#description_17", 
            "text": "Retrieves the PWM period of the analog output.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_16", 
            "text": "the period on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/ble/", 
            "text": "", 
            "title": "ble"
        }, 
        {
            "location": "/ubit/blemanager/", 
            "text": "", 
            "title": "bleManager"
        }, 
        {
            "location": "/ubit/radio/", 
            "text": "uBit.radio\n\n\nOverview\n\n\nMessage Bus ID\n\n\nMessage Bus Events\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitRadio( \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nuint16_t\n \nid\n\n\n\n\nsetTransmitPower\n\n\n\n\nint\n setTransmitPower( \nint\n power)\n\n\nDescription\n\n\nChange the output power level of the transmitter to the given value.\n\n\nParameters\n\n\n\n\nint\n \npower\n - a value in the range 0..7, where 0 is the lowest power and 7 is the highest. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the value is out of range. \n\n\nsetFrequencyBand\n\n\n\n\nint\n setFrequencyBand( \nint\n band)\n\n\nDescription\n\n\nChange the transmission and reception band of the radio to the given channel\n\n\nParameters\n\n\n\n\nint\n \nband\n - a frequency band in the range 0 - 100. Each step is 1MHz wide, based at 2400MHz. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the value is out of range, or MICROBIT_NOT_SUPPORTED if the BLE stack is running. \n\n\ngetRxBuf\n\n\n\n\nFrameBuffer\n getRxBuf()\n\n\nDescription\n\n\nRetrieve a pointer to the currently allocated recieve buffer. This is the area of memory actively being used by the radio hardware to store incoming data.\n\n\nReturns\n\n\na pointer to the current receive buffer\n\n\nqueueRxBuf\n\n\n\n\nint\n queueRxBuf()\n\n\nDescription\n\n\nAttempt to queue a buffer received by the radio hardware, if sufficient space is available.\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NO_RESOURCES if a replacement receiver buffer could not be allocated (either by policy or memory exhaustion). \n\n\nsetRSSI\n\n\n\n\nint\n setRSSI( \nuint8_t\n rssi)\n\n\nDescription\n\n\nSets the RSSI for the most recent packet.\n\n\nParameters\n\n\n\n\nuint8_t\n \nrssi\n - the new rssi value\n\n\n\n\n\n\nNote\n\n\nshould only be called from RADIO_IRQHandler... \n\n\n\n\ngetRSSI\n\n\n\n\nint\n getRSSI()\n\n\nDescription\n\n\nRetrieves the current RSSI for the most recent packet. \n\n\nenable\n\n\n\n\nint\n enable()\n\n\nDescription\n\n\nInitialises the radio for use as a multipoint sender/receiver \n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_NOT_SUPPORTED if SoftDevice is enabled.\n\n\ndisable\n\n\n\n\nint\n disable()\n\n\nDescription\n\n\nDisables the radio for use as a multipoint sender/receiver. \n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_NOT_SUPPORTED if SoftDevice is enabled. \n\n\nsetGroup\n\n\n\n\nint\n setGroup( \nuint8_t\n group)\n\n\nDescription\n\n\nSets the radio to listen to packets sent with the given group id.\n\n\nParameters\n\n\n\n\nuint8_t\n \ngroup\n - The group to join. A micro:bit can only listen to one group ID at any time. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the BLE stack is running. \n\n\ndataReady\n\n\n\n\nint\n dataReady()\n\n\nDescription\n\n\nDetermines the number of packets ready to be processed. \n\n\nReturns\n\n\nThe number of packets in the receive buffer. \n\n\nrecv\n\n\n\n\nFrameBuffer\n recv()\n\n\nDescription\n\n\nRetrieves the next packet from the receive buffer. If a data packet is available, then it will be returned immediately to the caller. This call will also dequeue the buffer.\n\n\nReturns\n\n\nThe buffer containing the the packet. If no data is available, NULL is returned. \n\n\nsend\n\n\n\n\nint\n send( \nFrameBuffer  *\n buffer)\n\n\nDescription\n\n\nTransmits the given buffer onto the broadcast radio. The call will wait until the transmission of the packet has completed before returning.\n\n\nParameters\n\n\n\n\nFrameBuffer  \n \nbuffer*\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the BLE stack is running.", 
            "title": "radio"
        }, 
        {
            "location": "/ubit/radio/#ubitradio", 
            "text": "", 
            "title": "uBit.radio"
        }, 
        {
            "location": "/ubit/radio/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/radio/#message-bus-id", 
            "text": "", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/radio/#message-bus-events", 
            "text": "", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/radio/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/radio/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/radio/#microbitradio-uint16_t-id", 
            "text": "", 
            "title": "MicroBitRadio( uint16_t id)"
        }, 
        {
            "location": "/ubit/radio/#description", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#parameters", 
            "text": "uint16_t   id", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/radio/#settransmitpower", 
            "text": "", 
            "title": "setTransmitPower"
        }, 
        {
            "location": "/ubit/radio/#int-settransmitpower-int-power", 
            "text": "", 
            "title": "int setTransmitPower( int power)"
        }, 
        {
            "location": "/ubit/radio/#description_1", 
            "text": "Change the output power level of the transmitter to the given value.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#parameters_1", 
            "text": "int   power  - a value in the range 0..7, where 0 is the lowest power and 7 is the highest.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/radio/#returns", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the value is out of range.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#setfrequencyband", 
            "text": "", 
            "title": "setFrequencyBand"
        }, 
        {
            "location": "/ubit/radio/#int-setfrequencyband-int-band", 
            "text": "", 
            "title": "int setFrequencyBand( int band)"
        }, 
        {
            "location": "/ubit/radio/#description_2", 
            "text": "Change the transmission and reception band of the radio to the given channel", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#parameters_2", 
            "text": "int   band  - a frequency band in the range 0 - 100. Each step is 1MHz wide, based at 2400MHz.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/radio/#returns_1", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the value is out of range, or MICROBIT_NOT_SUPPORTED if the BLE stack is running.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#getrxbuf", 
            "text": "", 
            "title": "getRxBuf"
        }, 
        {
            "location": "/ubit/radio/#framebuffer-getrxbuf", 
            "text": "", 
            "title": "FrameBuffer getRxBuf()"
        }, 
        {
            "location": "/ubit/radio/#description_3", 
            "text": "Retrieve a pointer to the currently allocated recieve buffer. This is the area of memory actively being used by the radio hardware to store incoming data.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_2", 
            "text": "a pointer to the current receive buffer", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#queuerxbuf", 
            "text": "", 
            "title": "queueRxBuf"
        }, 
        {
            "location": "/ubit/radio/#int-queuerxbuf", 
            "text": "", 
            "title": "int queueRxBuf()"
        }, 
        {
            "location": "/ubit/radio/#description_4", 
            "text": "Attempt to queue a buffer received by the radio hardware, if sufficient space is available.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_3", 
            "text": "MICROBIT_OK on success, or MICROBIT_NO_RESOURCES if a replacement receiver buffer could not be allocated (either by policy or memory exhaustion).", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#setrssi", 
            "text": "", 
            "title": "setRSSI"
        }, 
        {
            "location": "/ubit/radio/#int-setrssi-uint8_t-rssi", 
            "text": "", 
            "title": "int setRSSI( uint8_t rssi)"
        }, 
        {
            "location": "/ubit/radio/#description_5", 
            "text": "Sets the RSSI for the most recent packet.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#parameters_3", 
            "text": "uint8_t   rssi  - the new rssi value    Note  should only be called from RADIO_IRQHandler...", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/radio/#getrssi", 
            "text": "", 
            "title": "getRSSI"
        }, 
        {
            "location": "/ubit/radio/#int-getrssi", 
            "text": "", 
            "title": "int getRSSI()"
        }, 
        {
            "location": "/ubit/radio/#description_6", 
            "text": "Retrieves the current RSSI for the most recent packet.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#enable", 
            "text": "", 
            "title": "enable"
        }, 
        {
            "location": "/ubit/radio/#int-enable", 
            "text": "", 
            "title": "int enable()"
        }, 
        {
            "location": "/ubit/radio/#description_7", 
            "text": "Initialises the radio for use as a multipoint sender/receiver", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_4", 
            "text": "MICROBIT_OK on success, MICROBIT_NOT_SUPPORTED if SoftDevice is enabled.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#disable", 
            "text": "", 
            "title": "disable"
        }, 
        {
            "location": "/ubit/radio/#int-disable", 
            "text": "", 
            "title": "int disable()"
        }, 
        {
            "location": "/ubit/radio/#description_8", 
            "text": "Disables the radio for use as a multipoint sender/receiver.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_5", 
            "text": "MICROBIT_OK on success, MICROBIT_NOT_SUPPORTED if SoftDevice is enabled.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#setgroup", 
            "text": "", 
            "title": "setGroup"
        }, 
        {
            "location": "/ubit/radio/#int-setgroup-uint8_t-group", 
            "text": "", 
            "title": "int setGroup( uint8_t group)"
        }, 
        {
            "location": "/ubit/radio/#description_9", 
            "text": "Sets the radio to listen to packets sent with the given group id.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#parameters_4", 
            "text": "uint8_t   group  - The group to join. A micro:bit can only listen to one group ID at any time.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/radio/#returns_6", 
            "text": "MICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the BLE stack is running.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#dataready", 
            "text": "", 
            "title": "dataReady"
        }, 
        {
            "location": "/ubit/radio/#int-dataready", 
            "text": "", 
            "title": "int dataReady()"
        }, 
        {
            "location": "/ubit/radio/#description_10", 
            "text": "Determines the number of packets ready to be processed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_7", 
            "text": "The number of packets in the receive buffer.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#recv", 
            "text": "", 
            "title": "recv"
        }, 
        {
            "location": "/ubit/radio/#framebuffer-recv", 
            "text": "", 
            "title": "FrameBuffer recv()"
        }, 
        {
            "location": "/ubit/radio/#description_11", 
            "text": "Retrieves the next packet from the receive buffer. If a data packet is available, then it will be returned immediately to the caller. This call will also dequeue the buffer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_8", 
            "text": "The buffer containing the the packet. If no data is available, NULL is returned.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#send", 
            "text": "", 
            "title": "send"
        }, 
        {
            "location": "/ubit/radio/#int-send-framebuffer-buffer", 
            "text": "", 
            "title": "int send( FrameBuffer  * buffer)"
        }, 
        {
            "location": "/ubit/radio/#description_12", 
            "text": "Transmits the given buffer onto the broadcast radio. The call will wait until the transmission of the packet has completed before returning.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#parameters_5", 
            "text": "FrameBuffer     buffer*", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/radio/#returns_9", 
            "text": "MICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the BLE stack is running.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/", 
            "text": "MicroBitImage\n\n\nOverview\n\n\nMessage Bus ID\n\n\nMessage Bus Events\n\n\nAPI\n\n\nleakData\n\n\n\n\nImageData\n leakData()\n\n\nDescription\n\n\nGet current ptr, do not decr() it, and set the current instance to empty image. This is to be used by specialized runtimes which pass  ImageData\n\n\ngetBitmap\n\n\n\n\nuint8_t *\n getBitmap()\n\n\nDescription\n\n\nReturn a 2D array representing the bitmap image. \n\n\nConstructor\n\n\n\n\nMicroBitImage( \nImageData  *\n ptr)\n\n\nDescription\n\n\nConstructor. Create an image from a specially prepared constant array, with no copying. Will call ptr-\nincr().\n\n\nParameters\n\n\n\n\nImageData  \n \nptr* - The literal - first two bytes should be 0xff, then width, 0, height, 0, and the bitmap. Width and height are 16 bit. The literal has to be 4-byte aligned.\n\n\n\n\nExample\n\n\n static const uint8_t heart[] __attribute__ ((aligned (4))) = { 0xff, 0xff, 10, 0, 5, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i((ImageData*)(void*)heart); \n\n\n\n\n\n\n\nMicroBitImage()\n\n\nDescription\n\n\nDefault Constructor. Creates a new reference to the empty  MicroBitImage\n\n\nExample\n\n\n MicroBitImage i(); //an empty image \n\n\n\n\n\n\n\nMicroBitImage( \nconst  MicroBitImage  \n image)\n\n\nDescription\n\n\nCopy Constructor. Add ourselves as a reference to an existing  MicroBitImage\n\n\nParameters\n\n\n\n\nconst  MicroBitImage  \n \nimage\n - The  MicroBitImage  to reference.\n\n\n\n\nExample\n\n\n MicroBitImage i(\n0,1,0,1,0\\n\n); \n MicroBitImage i2(i); //points to i \n\n\n\n\n\n\n\nMicroBitImage( \nconst char *\n s)\n\n\nDescription\n\n\nConstructor. Create a blank bitmap representation of a given size.\n\n\nParameters\n\n\n\n\nconst char \n \ns* - A text based representation of the image given whitespace delimited numeric values.\n\n\n\n\nExample\n\n\n MicroBitImage i(\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\n); // 5x5 image \n\n\n\n\n\n\n\nMicroBitImage( \nconst int16_t\n x,  \nconst int16_t\n y)\n\n\nDescription\n\n\nConstructor. Create a blank bitmap representation of a given size.\n\n\nParameters\n\n\n\n\nconst int16_t\n \nx\n - the width of the image. \n\n\nconst int16_t\n \ny\n - the height of the image.\n\n\n\n\nExample\n\n\n MicroBitImage i(5,5); // a blank 5x5 image \n\n\n\n\n\n\n\nMicroBitImage( \nconst int16_t\n x,  \nconst int16_t\n y,  \nconst uint8_t *\n bitmap)\n\n\nDescription\n\n\nConstructor. Create a bitmap representation of a given size, based on a given buffer.\n\n\nParameters\n\n\n\n\nconst int16_t\n \nx\n - the width of the image. \n\n\nconst int16_t\n \ny\n - the height of the image. \n\n\nconst uint8_t \n \nbitmap* - a 2D array representing the image.\n\n\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n\n\n\n\n\n~MicroBitImage\n\n\n\n\n~MicroBitImage()\n\n\nDescription\n\n\nDestructor. Removes buffer resources held by the instance. \n\n\noperator=\n\n\n\n\nMicroBitImage\n operator=( \nconst  MicroBitImage  \n i)\n\n\nDescription\n\n\nCopy assign operation.\n\n\nParameters\n\n\n\n\nconst  MicroBitImage  \n \ni\n\n\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n MicroBitImage i1(); \n i1 = 1; // i1 now references i \n\n\n\n\n\noperator==\n\n\n\n\nbool\n operator==( \nconst  MicroBitImage  \n i)\n\n\nDescription\n\n\nEquality operation.\n\n\nParameters\n\n\n\n\nconst  MicroBitImage  \n \ni\n - The  MicroBitImage  to test ourselves against. \n\n\n\n\nReturns\n\n\ntrue if this  MicroBitImage  is identical to the one supplied, false otherwise.\n\n\nExample\n\n\n MicroBitImage i(); \n MicroBitImage i1(); \n\n if(i == i1) //will be true \n print(\ntrue\n); \n\n\n\n\n\nclear\n\n\n\n\nvoid\n clear()\n\n\nDescription\n\n\nClears all pixels in this image\n\n\nExample\n\n\n MicroBitImage i(\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\n); // 5x5 image \n i.clear(); \n\n\n\n\n\nsetPixelValue\n\n\n\n\nint\n setPixelValue( \nint16_t\n x,  \nint16_t\n y,  \nuint8_t\n value)\n\n\nDescription\n\n\nSets the pixel at the given co-ordinates to a given value. \n\n\nParameters\n\n\n\n\nint16_t\n \nx\n - The co-ordinate of the pixel to change w.r.t. top left origin. \n\n\nint16_t\n \ny\n - The co-ordinate of the pixel to change w.r.t. top left origin. \n\n\nuint8_t\n \nvalue\n - The new value of the pixel (the brightness level 0-255) \n\n\n\n\nReturns\n\n\nMICROBIT_OK, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicroBitImage i(\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\n); // 5x5 image \n i.setPixelValue(0,0,255); \n\n\n\n\n\ngetPixelValue\n\n\n\n\nint\n getPixelValue( \nint16_t\n x,  \nint16_t\n y)\n\n\nDescription\n\n\nDetermines the value of a given pixel.\n\n\nParameters\n\n\n\n\nint16_t\n \nx\n - The x co-ordinate of the pixel to read. Must be within the dimensions of the image. \n\n\nint16_t\n \ny\n - The y co-ordinate of the pixel to read. Must be within the dimensions of the image. \n\n\n\n\nReturns\n\n\nThe value assigned to the given pixel location (the brightness level 0-255), or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicroBitImage i(\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\n); // 5x5 image \n i.getPixelValue(0,0); //should be 0; \n\n\n\n\n\nprintImage\n\n\n\n\nint\n printImage( \nint16_t\n x,  \nint16_t\n y,  \nconst uint8_t *\n bitmap)\n\n\nDescription\n\n\nReplaces the content of this image with that of a given 2D array representing the image. Origin is in the top left corner of the image.\n\n\nParameters\n\n\n\n\nint16_t\n \nx\n - the width of the image. Must be within the dimensions of the image. \n\n\nint16_t\n \ny\n - the width of the image. Must be within the dimensions of the image. \n\n\nconst uint8_t \n \nbitmap* - a 2D array representing the image. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(); \n i.printImage(0,0,heart); \n\n\n\n\n\npaste\n\n\n\n\nint\n paste( \nconst  MicroBitImage  \n image,  \nint16_t\n x,  \nint16_t\n y,  \nuint8_t\n alpha)\n\n\nDescription\n\n\nPastes a given bitmap at the given co-ordinates. Any pixels in the relvant area of this image are replaced.\n\n\nParameters\n\n\n\n\nconst  MicroBitImage  \n \nimage\n - The  MicroBitImage  to paste. \n\n\nint16_t\n \nx\n - The leftmost X co-ordinate in this image where the given image should be pasted. \n\n\nint16_t\n \ny\n - The uppermost Y co-ordinate in this image where the given image should be pasted. \n\n\nuint8_t\n \nalpha\n - set to 1 if transparency clear pixels in given image should be treated as transparent. Set to 0 otherwise. \n\n\n\n\nReturns\n\n\nThe number of pixels written, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); //if you show this image - you will see a big heart \n i.paste(-5,0,i); //displays a small heart :) \n\n\n\n\n\nprint\n\n\n\n\nint\n print( \nchar\n c,  \nint16_t\n x,  \nint16_t\n y)\n\n\nDescription\n\n\nPrints a character to the display at the given location\n\n\nParameters\n\n\n\n\nchar\n \nc\n - The character to display. \n\n\nint16_t\n \nx\n - The x co-ordinate of on the image to place the top left of the character \n\n\nint16_t\n \ny\n - The y co-ordinate of on the image to place the top left of the character \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicroBitImage i(5,5); \n i.print('a',0,0); \n\n\n\n\n\nshiftLeft\n\n\n\n\nint\n shiftLeft( \nint16_t\n n)\n\n\nDescription\n\n\nShifts the pixels in this Image a given number of pixels to the Left.\n\n\nParameters\n\n\n\n\nint16_t\n \nn\n - The number of pixels to shift. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); //if you show this image - you will see a big heart \n i.shiftLeft(5); //displays a small heart :) \n\n\n\n\n\nshiftRight\n\n\n\n\nint\n shiftRight( \nint16_t\n n)\n\n\nDescription\n\n\nShifts the pixels in this Image a given number of pixels to the Right.\n\n\nParameters\n\n\n\n\nint16_t\n \nn\n - The number of pixels to shift. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftLeft(5); //displays a small heart :) \n i.shiftRight(5); //displays a big heart :) \n\n\n\n\n\nshiftUp\n\n\n\n\nint\n shiftUp( \nint16_t\n n)\n\n\nDescription\n\n\nShifts the pixels in this Image a given number of pixels to Upward.\n\n\nParameters\n\n\n\n\nint16_t\n \nn\n - The number of pixels to shift. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftUp(1); \n\n\n\n\n\nshiftDown\n\n\n\n\nint\n shiftDown( \nint16_t\n n)\n\n\nDescription\n\n\nShifts the pixels in this Image a given number of pixels to Downward.\n\n\nParameters\n\n\n\n\nint16_t\n \nn\n - The number of pixels to shift. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftDown(1); \n\n\n\n\n\ngetWidth\n\n\n\n\nint\n getWidth()\n\n\nDescription\n\n\nGets the width of this image.\n\n\nReturns\n\n\nThe width of this image.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getWidth(); //equals 10... \n\n\n\n\n\ngetHeight\n\n\n\n\nint\n getHeight()\n\n\nDescription\n\n\nGets the height of this image.\n\n\nReturns\n\n\nThe height of this image.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getHeight(); //equals 5... \n\n\n\n\n\ngetSize\n\n\n\n\nint\n getSize()\n\n\nDescription\n\n\nGets number of bytes in the bitmap, ie., width * height.\n\n\nReturns\n\n\nThe size of the bitmap.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getSize(); //equals 50... \n\n\n\n\n\ntoString\n\n\n\n\nManagedString\n toString()\n\n\nDescription\n\n\nConverts the bitmap to a csv string.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n uBit.serial.printString(i.toString()); // \n0,1,0,1,0,0,0,0,0,0\\n...\n \n\n\n\n\n\ncrop\n\n\n\n\nMicroBitImage\n crop( \nint\n startx,  \nint\n starty,  \nint\n finx,  \nint\n finy)\n\n\nDescription\n\n\nCrops the image to the given dimensions\n\n\nParameters\n\n\n\n\nint\n \nstartx\n - the location to start the crop in the x-axis \n\n\nint\n \nstarty\n - the location to start the crop in the y-axis \n\n\nint\n \nfinx\n\n\nint\n \nfiny\n\n\n\n\nReturns\n\n\nan instance of  MicroBitImage  with your cropped region\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n uBit.serial.printImage(i.crop(0,0,2,2)); // \n0,1\\n1,1\\n\n \n\n\n\n\n\nisReadOnly\n\n\n\n\nbool\n isReadOnly()\n\n\nDescription\n\n\nCheck if image is read-only (i.e., residing in flash). \n\n\nclone\n\n\n\n\nMicroBitImage\n clone()\n\n\nDescription\n\n\nCreate a copy of the image bitmap. Used particularly, when  isReadOnly()\n\n\nReturns\n\n\nan instance of  MicroBitImage  which can be modified independently of the current instance", 
            "title": "MicroBitImage"
        }, 
        {
            "location": "/data-types/image/#microbitimage", 
            "text": "", 
            "title": "MicroBitImage"
        }, 
        {
            "location": "/data-types/image/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/data-types/image/#message-bus-id", 
            "text": "", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/data-types/image/#message-bus-events", 
            "text": "", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/data-types/image/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/data-types/image/#leakdata", 
            "text": "", 
            "title": "leakData"
        }, 
        {
            "location": "/data-types/image/#imagedata-leakdata", 
            "text": "", 
            "title": "ImageData leakData()"
        }, 
        {
            "location": "/data-types/image/#description", 
            "text": "Get current ptr, do not decr() it, and set the current instance to empty image. This is to be used by specialized runtimes which pass  ImageData", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#getbitmap", 
            "text": "", 
            "title": "getBitmap"
        }, 
        {
            "location": "/data-types/image/#uint8_t-getbitmap", 
            "text": "", 
            "title": "uint8_t * getBitmap()"
        }, 
        {
            "location": "/data-types/image/#description_1", 
            "text": "Return a 2D array representing the bitmap image.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/data-types/image/#microbitimage-imagedata-ptr", 
            "text": "", 
            "title": "MicroBitImage( ImageData  * ptr)"
        }, 
        {
            "location": "/data-types/image/#description_2", 
            "text": "Constructor. Create an image from a specially prepared constant array, with no copying. Will call ptr- incr().", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters", 
            "text": "ImageData     ptr* - The literal - first two bytes should be 0xff, then width, 0, height, 0, and the bitmap. Width and height are 16 bit. The literal has to be 4-byte aligned.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#example", 
            "text": "static const uint8_t heart[] __attribute__ ((aligned (4))) = { 0xff, 0xff, 10, 0, 5, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i((ImageData*)(void*)heart);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#microbitimage_1", 
            "text": "", 
            "title": "MicroBitImage()"
        }, 
        {
            "location": "/data-types/image/#description_3", 
            "text": "Default Constructor. Creates a new reference to the empty  MicroBitImage", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#example_1", 
            "text": "MicroBitImage i(); //an empty image", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#microbitimage-const-microbitimage-image", 
            "text": "", 
            "title": "MicroBitImage( const  MicroBitImage  &amp; image)"
        }, 
        {
            "location": "/data-types/image/#description_4", 
            "text": "Copy Constructor. Add ourselves as a reference to an existing  MicroBitImage", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_1", 
            "text": "const  MicroBitImage     image  - The  MicroBitImage  to reference.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#example_2", 
            "text": "MicroBitImage i( 0,1,0,1,0\\n ); \n MicroBitImage i2(i); //points to i", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#microbitimage-const-char-s", 
            "text": "", 
            "title": "MicroBitImage( const char * s)"
        }, 
        {
            "location": "/data-types/image/#description_5", 
            "text": "Constructor. Create a blank bitmap representation of a given size.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_2", 
            "text": "const char    s* - A text based representation of the image given whitespace delimited numeric values.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#example_3", 
            "text": "MicroBitImage i( 0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n ); // 5x5 image", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#microbitimage-const-int16_t-x-const-int16_t-y", 
            "text": "", 
            "title": "MicroBitImage( const int16_t x,  const int16_t y)"
        }, 
        {
            "location": "/data-types/image/#description_6", 
            "text": "Constructor. Create a blank bitmap representation of a given size.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_3", 
            "text": "const int16_t   x  - the width of the image.   const int16_t   y  - the height of the image.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#example_4", 
            "text": "MicroBitImage i(5,5); // a blank 5x5 image", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#microbitimage-const-int16_t-x-const-int16_t-y-const-uint8_t-bitmap", 
            "text": "", 
            "title": "MicroBitImage( const int16_t x,  const int16_t y,  const uint8_t * bitmap)"
        }, 
        {
            "location": "/data-types/image/#description_7", 
            "text": "Constructor. Create a bitmap representation of a given size, based on a given buffer.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_4", 
            "text": "const int16_t   x  - the width of the image.   const int16_t   y  - the height of the image.   const uint8_t    bitmap* - a 2D array representing the image.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#example_5", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#microbitimage_2", 
            "text": "", 
            "title": "~MicroBitImage"
        }, 
        {
            "location": "/data-types/image/#microbitimage_3", 
            "text": "", 
            "title": "~MicroBitImage()"
        }, 
        {
            "location": "/data-types/image/#description_8", 
            "text": "Destructor. Removes buffer resources held by the instance.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#operator", 
            "text": "", 
            "title": "operator="
        }, 
        {
            "location": "/data-types/image/#microbitimage-operator-const-microbitimage-i", 
            "text": "", 
            "title": "MicroBitImage operator=( const  MicroBitImage  &amp; i)"
        }, 
        {
            "location": "/data-types/image/#description_9", 
            "text": "Copy assign operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_5", 
            "text": "const  MicroBitImage     i", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#example_6", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n MicroBitImage i1(); \n i1 = 1; // i1 now references i", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#operator_1", 
            "text": "", 
            "title": "operator=="
        }, 
        {
            "location": "/data-types/image/#bool-operator-const-microbitimage-i", 
            "text": "", 
            "title": "bool operator==( const  MicroBitImage  &amp; i)"
        }, 
        {
            "location": "/data-types/image/#description_10", 
            "text": "Equality operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_6", 
            "text": "const  MicroBitImage     i  - The  MicroBitImage  to test ourselves against.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns", 
            "text": "true if this  MicroBitImage  is identical to the one supplied, false otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_7", 
            "text": "MicroBitImage i(); \n MicroBitImage i1(); \n\n if(i == i1) //will be true \n print( true );", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#clear", 
            "text": "", 
            "title": "clear"
        }, 
        {
            "location": "/data-types/image/#void-clear", 
            "text": "", 
            "title": "void clear()"
        }, 
        {
            "location": "/data-types/image/#description_11", 
            "text": "Clears all pixels in this image", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#example_8", 
            "text": "MicroBitImage i( 0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n ); // 5x5 image \n i.clear();", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#setpixelvalue", 
            "text": "", 
            "title": "setPixelValue"
        }, 
        {
            "location": "/data-types/image/#int-setpixelvalue-int16_t-x-int16_t-y-uint8_t-value", 
            "text": "", 
            "title": "int setPixelValue( int16_t x,  int16_t y,  uint8_t value)"
        }, 
        {
            "location": "/data-types/image/#description_12", 
            "text": "Sets the pixel at the given co-ordinates to a given value.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_7", 
            "text": "int16_t   x  - The co-ordinate of the pixel to change w.r.t. top left origin.   int16_t   y  - The co-ordinate of the pixel to change w.r.t. top left origin.   uint8_t   value  - The new value of the pixel (the brightness level 0-255)", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_1", 
            "text": "MICROBIT_OK, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_9", 
            "text": "MicroBitImage i( 0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n ); // 5x5 image \n i.setPixelValue(0,0,255);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#getpixelvalue", 
            "text": "", 
            "title": "getPixelValue"
        }, 
        {
            "location": "/data-types/image/#int-getpixelvalue-int16_t-x-int16_t-y", 
            "text": "", 
            "title": "int getPixelValue( int16_t x,  int16_t y)"
        }, 
        {
            "location": "/data-types/image/#description_13", 
            "text": "Determines the value of a given pixel.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_8", 
            "text": "int16_t   x  - The x co-ordinate of the pixel to read. Must be within the dimensions of the image.   int16_t   y  - The y co-ordinate of the pixel to read. Must be within the dimensions of the image.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_2", 
            "text": "The value assigned to the given pixel location (the brightness level 0-255), or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_10", 
            "text": "MicroBitImage i( 0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n ); // 5x5 image \n i.getPixelValue(0,0); //should be 0;", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#printimage", 
            "text": "", 
            "title": "printImage"
        }, 
        {
            "location": "/data-types/image/#int-printimage-int16_t-x-int16_t-y-const-uint8_t-bitmap", 
            "text": "", 
            "title": "int printImage( int16_t x,  int16_t y,  const uint8_t * bitmap)"
        }, 
        {
            "location": "/data-types/image/#description_14", 
            "text": "Replaces the content of this image with that of a given 2D array representing the image. Origin is in the top left corner of the image.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_9", 
            "text": "int16_t   x  - the width of the image. Must be within the dimensions of the image.   int16_t   y  - the width of the image. Must be within the dimensions of the image.   const uint8_t    bitmap* - a 2D array representing the image.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_3", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_11", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(); \n i.printImage(0,0,heart);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#paste", 
            "text": "", 
            "title": "paste"
        }, 
        {
            "location": "/data-types/image/#int-paste-const-microbitimage-image-int16_t-x-int16_t-y-uint8_t-alpha", 
            "text": "", 
            "title": "int paste( const  MicroBitImage  &amp; image,  int16_t x,  int16_t y,  uint8_t alpha)"
        }, 
        {
            "location": "/data-types/image/#description_15", 
            "text": "Pastes a given bitmap at the given co-ordinates. Any pixels in the relvant area of this image are replaced.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_10", 
            "text": "const  MicroBitImage     image  - The  MicroBitImage  to paste.   int16_t   x  - The leftmost X co-ordinate in this image where the given image should be pasted.   int16_t   y  - The uppermost Y co-ordinate in this image where the given image should be pasted.   uint8_t   alpha  - set to 1 if transparency clear pixels in given image should be treated as transparent. Set to 0 otherwise.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_4", 
            "text": "The number of pixels written, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_12", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); //if you show this image - you will see a big heart \n i.paste(-5,0,i); //displays a small heart :)", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#print", 
            "text": "", 
            "title": "print"
        }, 
        {
            "location": "/data-types/image/#int-print-char-c-int16_t-x-int16_t-y", 
            "text": "", 
            "title": "int print( char c,  int16_t x,  int16_t y)"
        }, 
        {
            "location": "/data-types/image/#description_16", 
            "text": "Prints a character to the display at the given location", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_11", 
            "text": "char   c  - The character to display.   int16_t   x  - The x co-ordinate of on the image to place the top left of the character   int16_t   y  - The y co-ordinate of on the image to place the top left of the character", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_5", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_13", 
            "text": "MicroBitImage i(5,5); \n i.print('a',0,0);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#shiftleft", 
            "text": "", 
            "title": "shiftLeft"
        }, 
        {
            "location": "/data-types/image/#int-shiftleft-int16_t-n", 
            "text": "", 
            "title": "int shiftLeft( int16_t n)"
        }, 
        {
            "location": "/data-types/image/#description_17", 
            "text": "Shifts the pixels in this Image a given number of pixels to the Left.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_12", 
            "text": "int16_t   n  - The number of pixels to shift.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_6", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_14", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); //if you show this image - you will see a big heart \n i.shiftLeft(5); //displays a small heart :)", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#shiftright", 
            "text": "", 
            "title": "shiftRight"
        }, 
        {
            "location": "/data-types/image/#int-shiftright-int16_t-n", 
            "text": "", 
            "title": "int shiftRight( int16_t n)"
        }, 
        {
            "location": "/data-types/image/#description_18", 
            "text": "Shifts the pixels in this Image a given number of pixels to the Right.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_13", 
            "text": "int16_t   n  - The number of pixels to shift.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_7", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_15", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftLeft(5); //displays a small heart :) \n i.shiftRight(5); //displays a big heart :)", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#shiftup", 
            "text": "", 
            "title": "shiftUp"
        }, 
        {
            "location": "/data-types/image/#int-shiftup-int16_t-n", 
            "text": "", 
            "title": "int shiftUp( int16_t n)"
        }, 
        {
            "location": "/data-types/image/#description_19", 
            "text": "Shifts the pixels in this Image a given number of pixels to Upward.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_14", 
            "text": "int16_t   n  - The number of pixels to shift.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_8", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_16", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftUp(1);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#shiftdown", 
            "text": "", 
            "title": "shiftDown"
        }, 
        {
            "location": "/data-types/image/#int-shiftdown-int16_t-n", 
            "text": "", 
            "title": "int shiftDown( int16_t n)"
        }, 
        {
            "location": "/data-types/image/#description_20", 
            "text": "Shifts the pixels in this Image a given number of pixels to Downward.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_15", 
            "text": "int16_t   n  - The number of pixels to shift.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_9", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_17", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftDown(1);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#getwidth", 
            "text": "", 
            "title": "getWidth"
        }, 
        {
            "location": "/data-types/image/#int-getwidth", 
            "text": "", 
            "title": "int getWidth()"
        }, 
        {
            "location": "/data-types/image/#description_21", 
            "text": "Gets the width of this image.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#returns_10", 
            "text": "The width of this image.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_18", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getWidth(); //equals 10...", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#getheight", 
            "text": "", 
            "title": "getHeight"
        }, 
        {
            "location": "/data-types/image/#int-getheight", 
            "text": "", 
            "title": "int getHeight()"
        }, 
        {
            "location": "/data-types/image/#description_22", 
            "text": "Gets the height of this image.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#returns_11", 
            "text": "The height of this image.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_19", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getHeight(); //equals 5...", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#getsize", 
            "text": "", 
            "title": "getSize"
        }, 
        {
            "location": "/data-types/image/#int-getsize", 
            "text": "", 
            "title": "int getSize()"
        }, 
        {
            "location": "/data-types/image/#description_23", 
            "text": "Gets number of bytes in the bitmap, ie., width * height.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#returns_12", 
            "text": "The size of the bitmap.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_20", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getSize(); //equals 50...", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#tostring", 
            "text": "", 
            "title": "toString"
        }, 
        {
            "location": "/data-types/image/#managedstring-tostring", 
            "text": "", 
            "title": "ManagedString toString()"
        }, 
        {
            "location": "/data-types/image/#description_24", 
            "text": "Converts the bitmap to a csv string.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#example_21", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n uBit.serial.printString(i.toString()); //  0,1,0,1,0,0,0,0,0,0\\n...", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#crop", 
            "text": "", 
            "title": "crop"
        }, 
        {
            "location": "/data-types/image/#microbitimage-crop-int-startx-int-starty-int-finx-int-finy", 
            "text": "", 
            "title": "MicroBitImage crop( int startx,  int starty,  int finx,  int finy)"
        }, 
        {
            "location": "/data-types/image/#description_25", 
            "text": "Crops the image to the given dimensions", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_16", 
            "text": "int   startx  - the location to start the crop in the x-axis   int   starty  - the location to start the crop in the y-axis   int   finx  int   finy", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_13", 
            "text": "an instance of  MicroBitImage  with your cropped region", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_22", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n uBit.serial.printImage(i.crop(0,0,2,2)); //  0,1\\n1,1\\n", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#isreadonly", 
            "text": "", 
            "title": "isReadOnly"
        }, 
        {
            "location": "/data-types/image/#bool-isreadonly", 
            "text": "", 
            "title": "bool isReadOnly()"
        }, 
        {
            "location": "/data-types/image/#description_26", 
            "text": "Check if image is read-only (i.e., residing in flash).", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#clone", 
            "text": "", 
            "title": "clone"
        }, 
        {
            "location": "/data-types/image/#microbitimage-clone", 
            "text": "", 
            "title": "MicroBitImage clone()"
        }, 
        {
            "location": "/data-types/image/#description_27", 
            "text": "Create a copy of the image bitmap. Used particularly, when  isReadOnly()", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#returns_14", 
            "text": "an instance of  MicroBitImage  which can be modified independently of the current instance", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/event/", 
            "text": "MicroBitEvent\n\n\nOverview\n\n\nMessage Bus ID\n\n\nMessage Bus Events\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitEvent( \nuint16_t\n source,  \nuint16_t\n value)\n\n\nDescription\n\n\nConstructor.  MicroBit MicroBitEvent MicroBitEvent MicroBitMessageBus MicroBitEvent\n\n\nParameters\n\n\n\n\nuint16_t\n \nsource\n\n\nuint16_t\n \nvalue\n - Component specific code indicating the cause of the event. \n\n\n\n\nExample\n\n\n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK); \n\n\n\n\n\n\n\nMicroBitEvent( \nuint16_t\n source,  \nuint16_t\n value,  \nMicroBitEventLaunchMode\n mode)\n\n\nDescription\n\n\nConstructor.  MicroBit MicroBitEvent MicroBitEvent MicroBitMessageBus MicroBitEvent\n\n\nParameters\n\n\n\n\nuint16_t\n \nsource\n\n\nuint16_t\n \nvalue\n - Component specific code indicating the cause of the event. \n\n\nMicroBitEventLaunchMode\n \nmode\n - optional definition of how the event should be processed after construction (if at all):\n\n\n\n\nExample\n\n\n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK); \n\n\n\n\n\n\n\nMicroBitEvent()\n\n\nDescription\n\n\nDefault constructor - initialises all values, and sets timestamp to the current time. \n\n\nfire\n\n\n\n\nvoid\n fire()\n\n\nDescription\n\n\nFires the represented event onto the message bus using the default configuration.\n\n\n\nvoid\n fire( \nMicroBitEventLaunchMode\n mode)\n\n\nDescription\n\n\nFires the represented event onto the message bus. \n\n\nParameters\n\n\n\n\nMicroBitEventLaunchMode\n \nmode\n - Configuration of how the event is processed.", 
            "title": "MicroBitEvent"
        }, 
        {
            "location": "/data-types/event/#microbitevent", 
            "text": "", 
            "title": "MicroBitEvent"
        }, 
        {
            "location": "/data-types/event/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/data-types/event/#message-bus-id", 
            "text": "", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/data-types/event/#message-bus-events", 
            "text": "", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/data-types/event/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/data-types/event/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/data-types/event/#microbitevent-uint16_t-source-uint16_t-value", 
            "text": "", 
            "title": "MicroBitEvent( uint16_t source,  uint16_t value)"
        }, 
        {
            "location": "/data-types/event/#description", 
            "text": "Constructor.  MicroBit MicroBitEvent MicroBitEvent MicroBitMessageBus MicroBitEvent", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/event/#parameters", 
            "text": "uint16_t   source  uint16_t   value  - Component specific code indicating the cause of the event.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/event/#example", 
            "text": "MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/event/#microbitevent-uint16_t-source-uint16_t-value-microbiteventlaunchmode-mode", 
            "text": "", 
            "title": "MicroBitEvent( uint16_t source,  uint16_t value,  MicroBitEventLaunchMode mode)"
        }, 
        {
            "location": "/data-types/event/#description_1", 
            "text": "Constructor.  MicroBit MicroBitEvent MicroBitEvent MicroBitMessageBus MicroBitEvent", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/event/#parameters_1", 
            "text": "uint16_t   source  uint16_t   value  - Component specific code indicating the cause of the event.   MicroBitEventLaunchMode   mode  - optional definition of how the event should be processed after construction (if at all):", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/event/#example_1", 
            "text": "MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/event/#microbitevent_1", 
            "text": "", 
            "title": "MicroBitEvent()"
        }, 
        {
            "location": "/data-types/event/#description_2", 
            "text": "Default constructor - initialises all values, and sets timestamp to the current time.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/event/#fire", 
            "text": "", 
            "title": "fire"
        }, 
        {
            "location": "/data-types/event/#void-fire", 
            "text": "", 
            "title": "void fire()"
        }, 
        {
            "location": "/data-types/event/#description_3", 
            "text": "Fires the represented event onto the message bus using the default configuration.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/event/#void-fire-microbiteventlaunchmode-mode", 
            "text": "", 
            "title": "void fire( MicroBitEventLaunchMode mode)"
        }, 
        {
            "location": "/data-types/event/#description_4", 
            "text": "Fires the represented event onto the message bus.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/event/#parameters_2", 
            "text": "MicroBitEventLaunchMode   mode  - Configuration of how the event is processed.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/", 
            "text": "ManagedString\n\n\nOverview\n\n\nMessage Bus ID\n\n\nMessage Bus Events\n\n\nAPI\n\n\nConstructor\n\n\n\n\nManagedString( \nStringData  *\n ptr)\n\n\nDescription\n\n\nConstructor. Create a managed string from a specially prepared string literal. It will ptr-\nincr().\n\n\nParameters\n\n\n\n\nStringData  \n \nptr* - The literal - first two bytes should be 0xff, then the length in little endian, then the literal. The literal has to be 4-byte aligned.\n\n\n\n\nExample\n\n\n static const char hello[] __attribute__ ((aligned (4))) = \n\\xff\\xff\\x05\\x00\n \nHello\n; \n ManagedString s((StringData*)(void*)hello); \n\n\n\n\n\nleakData\n\n\n\n\nStringData\n leakData()\n\n\nDescription\n\n\nGet current ptr, do not decr() it, and set the current instance to empty string. This is to be used by specialized runtimes which pass  StringData\n\n\nConstructor\n\n\n\n\nManagedString( \nconst char *\n str)\n\n\nDescription\n\n\nConstructor. Create a managed string from a pointer to an 8-bit character buffer. The buffer is copied to ensure safe memory management (the supplied character buffer may be decalred on the stack for instance).\n\n\nParameters\n\n\n\n\nconst char \n \nstr* - The character array on which to base the new  ManagedString .\n\n\n\n\nExample\n\n\n ManagedString s(\nabcdefg\n); \n\n\n\n\n\n\n\nManagedString( \nconst int\n value)\n\n\nDescription\n\n\nConstructor. Create a managed string from a given integer.\n\n\nParameters\n\n\n\n\nconst int\n \nvalue\n - The integer from which to create the  ManagedString\n\n\n\n\nExample\n\n\n ManagedString s(20); \n\n\n\n\n\n\n\nManagedString( \nconst char\n value)\n\n\nDescription\n\n\nConstructor. Create a managed string from a given char.\n\n\nParameters\n\n\n\n\nconst char\n \nvalue\n - The char from which to create the  ManagedString\n\n\n\n\nExample\n\n\n ManagedString s('a'); \n\n\n\n\n\n\n\nManagedString( \nconst char *\n str,  \nconst int16_t\n length)\n\n\nDescription\n\n\nConstructor. Create a managed string from a pointer to an 8-bit character buffer of a given length. The buffer is copied to ensure sane memory management (the supplied character buffer may be declared on the stack for instance).\n\n\nParameters\n\n\n\n\nconst char \n \nstr* - The character array on which to base the new  ManagedString . \n\n\nconst int16_t\n \nlength\n - The length of the character array\n\n\n\n\nExample\n\n\n ManagedString s(\nabcdefg\n,7); // this is generally used for substring... why not use a normal char * constructor? \n\n\n\n\n\n\n\nManagedString( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nCopy constructor. Makes a new  ManagedString ManagedString\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to copy.\n\n\n\n\nExample\n\n\n ManagedString s(\nabcdefg\n); \n ManagedString p(s); \n\n\n\n\n\n\n\nManagedString()\n\n\nDescription\n\n\nDefault constructor.\n\n\nExample\n\n\n ManagedString s(); \n\n\n\n\n\n~ManagedString\n\n\n\n\n~ManagedString()\n\n\nDescription\n\n\nDestructor.\n\n\noperator=\n\n\n\n\nManagedString\n operator=( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nCopy assign operation.\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to copy.\n\n\n\n\nExample\n\n\n ManagedString s(\nabcd\n); \n ManagedString p(\nefgh\n); \n p = s // p now points to s, s' ref is incremented \n\n\n\n\n\noperator==\n\n\n\n\nbool\n operator==( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nEquality operation.\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to test ourselves against. \n\n\n\n\nReturns\n\n\ntrue if this  ManagedString  is identical to the one supplied, false otherwise.\n\n\nExample\n\n\n ManagedString s(\nabcd\n); \n ManagedString p(\nefgh\n); \n\n if(p==s) \n print(\nWe are the same!\n); \n else \n print(\nWe are different!\n); //p is not equal to s - this will be called \n\n\n\n\n\noperator\n\n\n\n\nbool\n operator\n( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nInequality operation.\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to test ourselves against. \n\n\n\n\nReturns\n\n\ntrue if this  ManagedString  is alphabetically less than to the one supplied, false otherwise.\n\n\nExample\n\n\n ManagedString s(\na\n); \n ManagedString p(\nb\n); \n\n if(s\np) \n print(\na is before b!\n); //a is before b \n else \n print(\nb is before a!\n); \n\n\n\n\n\noperator\n\n\n\n\nbool\n operator\n( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nInequality operation.\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to test ourselves against. \n\n\n\n\nReturns\n\n\ntrue if this  ManagedString  is alphabetically greater than to the one supplied, false otherwise.\n\n\nExample\n\n\n ManagedString s(\na\n); \n ManagedString p(\nb\n); \n\n if(p\na) \n print(\nb is after a!\n); //b is after a \n else \n print(\na is after b!\n); \n\n\n\n\n\nsubstring\n\n\n\n\nManagedString\n substring( \nint16_t\n start,  \nint16_t\n length)\n\n\nDescription\n\n\nExtracts a  ManagedString\n\n\nParameters\n\n\n\n\nint16_t\n \nstart\n - The index of the first character to extract, indexed from zero. \n\n\nint16_t\n \nlength\n - The number of characters to extract from the start position \n\n\n\n\nReturns\n\n\na  ManagedString  representing the requested substring.\n\n\nExample\n\n\n ManagedString s(\nabcdefg\n); \n\n print(s.substring(0,2)) // prints \nab\n \n\n\n\n\n\noperator+\n\n\n\n\nManagedString\n operator+( \nManagedString  \n s)\n\n\nDescription\n\n\nConcatenates this string with the one provided.\n\n\nParameters\n\n\n\n\nManagedString  \n \ns\n - The  ManagedString  to concatenate. \n\n\n\n\nReturns\n\n\na new  ManagedString  representing the joined strings.\n\n\nExample\n\n\n ManagedString s(\nabcd\n); \n ManagedString p(\nefgh\n) \n\n print(s + p) // prints \nabcdefgh\n \n\n\n\n\n\ncharAt\n\n\n\n\nchar\n charAt( \nint16_t\n index)\n\n\nDescription\n\n\nProvides a character value at a given position in the string, indexed from zero.\n\n\nParameters\n\n\n\n\nint16_t\n \nindex\n - The position of the character to return. \n\n\n\n\nReturns\n\n\nthe character at posisiton index, zero if index is invalid.\n\n\nExample\n\n\n ManagedString s(\nabcd\n); \n\n print(s.charAt(1)) // prints \nb\n \n\n\n\n\n\ntoCharArray\n\n\n\n\nconst char *\n toCharArray()\n\n\nDescription\n\n\nProvides an immutable 8 bit wide character buffer representing this string.\n\n\nReturns\n\n\na pointer to the character buffer. \n\n\nlength\n\n\n\n\nint16_t\n length()\n\n\nDescription\n\n\nDetermines the length of this  ManagedString\n\n\nReturns\n\n\nthe length of the string in characters.\n\n\nExample\n\n\n ManagedString s(\nabcd\n); \n\n print(s.length()) // prints \n4", 
            "title": "ManagedString"
        }, 
        {
            "location": "/data-types/string/#managedstring", 
            "text": "", 
            "title": "ManagedString"
        }, 
        {
            "location": "/data-types/string/#overview", 
            "text": "", 
            "title": "Overview"
        }, 
        {
            "location": "/data-types/string/#message-bus-id", 
            "text": "", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/data-types/string/#message-bus-events", 
            "text": "", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/data-types/string/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/data-types/string/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/data-types/string/#managedstring-stringdata-ptr", 
            "text": "", 
            "title": "ManagedString( StringData  * ptr)"
        }, 
        {
            "location": "/data-types/string/#description", 
            "text": "Constructor. Create a managed string from a specially prepared string literal. It will ptr- incr().", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters", 
            "text": "StringData     ptr* - The literal - first two bytes should be 0xff, then the length in little endian, then the literal. The literal has to be 4-byte aligned.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example", 
            "text": "static const char hello[] __attribute__ ((aligned (4))) =  \\xff\\xff\\x05\\x00   Hello ; \n ManagedString s((StringData*)(void*)hello);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#leakdata", 
            "text": "", 
            "title": "leakData"
        }, 
        {
            "location": "/data-types/string/#stringdata-leakdata", 
            "text": "", 
            "title": "StringData leakData()"
        }, 
        {
            "location": "/data-types/string/#description_1", 
            "text": "Get current ptr, do not decr() it, and set the current instance to empty string. This is to be used by specialized runtimes which pass  StringData", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#constructor_1", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/data-types/string/#managedstring-const-char-str", 
            "text": "", 
            "title": "ManagedString( const char * str)"
        }, 
        {
            "location": "/data-types/string/#description_2", 
            "text": "Constructor. Create a managed string from a pointer to an 8-bit character buffer. The buffer is copied to ensure safe memory management (the supplied character buffer may be decalred on the stack for instance).", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_1", 
            "text": "const char    str* - The character array on which to base the new  ManagedString .", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_1", 
            "text": "ManagedString s( abcdefg );", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#managedstring-const-int-value", 
            "text": "", 
            "title": "ManagedString( const int value)"
        }, 
        {
            "location": "/data-types/string/#description_3", 
            "text": "Constructor. Create a managed string from a given integer.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_2", 
            "text": "const int   value  - The integer from which to create the  ManagedString", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_2", 
            "text": "ManagedString s(20);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#managedstring-const-char-value", 
            "text": "", 
            "title": "ManagedString( const char value)"
        }, 
        {
            "location": "/data-types/string/#description_4", 
            "text": "Constructor. Create a managed string from a given char.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_3", 
            "text": "const char   value  - The char from which to create the  ManagedString", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_3", 
            "text": "ManagedString s('a');", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#managedstring-const-char-str-const-int16_t-length", 
            "text": "", 
            "title": "ManagedString( const char * str,  const int16_t length)"
        }, 
        {
            "location": "/data-types/string/#description_5", 
            "text": "Constructor. Create a managed string from a pointer to an 8-bit character buffer of a given length. The buffer is copied to ensure sane memory management (the supplied character buffer may be declared on the stack for instance).", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_4", 
            "text": "const char    str* - The character array on which to base the new  ManagedString .   const int16_t   length  - The length of the character array", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_4", 
            "text": "ManagedString s( abcdefg ,7); // this is generally used for substring... why not use a normal char * constructor?", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#managedstring-const-managedstring-s", 
            "text": "", 
            "title": "ManagedString( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/string/#description_6", 
            "text": "Copy constructor. Makes a new  ManagedString ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_5", 
            "text": "const  ManagedString     s  - The  ManagedString  to copy.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_5", 
            "text": "ManagedString s( abcdefg ); \n ManagedString p(s);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#managedstring_1", 
            "text": "", 
            "title": "ManagedString()"
        }, 
        {
            "location": "/data-types/string/#description_7", 
            "text": "Default constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#example_6", 
            "text": "ManagedString s();", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#managedstring_2", 
            "text": "", 
            "title": "~ManagedString"
        }, 
        {
            "location": "/data-types/string/#managedstring_3", 
            "text": "", 
            "title": "~ManagedString()"
        }, 
        {
            "location": "/data-types/string/#description_8", 
            "text": "Destructor.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#operator", 
            "text": "", 
            "title": "operator="
        }, 
        {
            "location": "/data-types/string/#managedstring-operator-const-managedstring-s", 
            "text": "", 
            "title": "ManagedString operator=( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/string/#description_9", 
            "text": "Copy assign operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_6", 
            "text": "const  ManagedString     s  - The  ManagedString  to copy.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_7", 
            "text": "ManagedString s( abcd ); \n ManagedString p( efgh ); \n p = s // p now points to s, s' ref is incremented", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#operator_1", 
            "text": "", 
            "title": "operator=="
        }, 
        {
            "location": "/data-types/string/#bool-operator-const-managedstring-s", 
            "text": "", 
            "title": "bool operator==( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/string/#description_10", 
            "text": "Equality operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_7", 
            "text": "const  ManagedString     s  - The  ManagedString  to test ourselves against.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#returns", 
            "text": "true if this  ManagedString  is identical to the one supplied, false otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_8", 
            "text": "ManagedString s( abcd ); \n ManagedString p( efgh ); \n\n if(p==s) \n print( We are the same! ); \n else \n print( We are different! ); //p is not equal to s - this will be called", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#operator_2", 
            "text": "", 
            "title": "operator&lt;"
        }, 
        {
            "location": "/data-types/string/#bool-operator-const-managedstring-s_1", 
            "text": "", 
            "title": "bool operator&lt;( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/string/#description_11", 
            "text": "Inequality operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_8", 
            "text": "const  ManagedString     s  - The  ManagedString  to test ourselves against.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#returns_1", 
            "text": "true if this  ManagedString  is alphabetically less than to the one supplied, false otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_9", 
            "text": "ManagedString s( a ); \n ManagedString p( b ); \n\n if(s p) \n print( a is before b! ); //a is before b \n else \n print( b is before a! );", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#operator_3", 
            "text": "", 
            "title": "operator&gt;"
        }, 
        {
            "location": "/data-types/string/#bool-operator-const-managedstring-s_2", 
            "text": "", 
            "title": "bool operator&gt;( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/string/#description_12", 
            "text": "Inequality operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_9", 
            "text": "const  ManagedString     s  - The  ManagedString  to test ourselves against.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#returns_2", 
            "text": "true if this  ManagedString  is alphabetically greater than to the one supplied, false otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_10", 
            "text": "ManagedString s( a ); \n ManagedString p( b ); \n\n if(p a) \n print( b is after a! ); //b is after a \n else \n print( a is after b! );", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#substring", 
            "text": "", 
            "title": "substring"
        }, 
        {
            "location": "/data-types/string/#managedstring-substring-int16_t-start-int16_t-length", 
            "text": "", 
            "title": "ManagedString substring( int16_t start,  int16_t length)"
        }, 
        {
            "location": "/data-types/string/#description_13", 
            "text": "Extracts a  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_10", 
            "text": "int16_t   start  - The index of the first character to extract, indexed from zero.   int16_t   length  - The number of characters to extract from the start position", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#returns_3", 
            "text": "a  ManagedString  representing the requested substring.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_11", 
            "text": "ManagedString s( abcdefg ); \n\n print(s.substring(0,2)) // prints  ab", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#operator_4", 
            "text": "", 
            "title": "operator+"
        }, 
        {
            "location": "/data-types/string/#managedstring-operator-managedstring-s", 
            "text": "", 
            "title": "ManagedString operator+( ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/string/#description_14", 
            "text": "Concatenates this string with the one provided.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_11", 
            "text": "ManagedString     s  - The  ManagedString  to concatenate.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#returns_4", 
            "text": "a new  ManagedString  representing the joined strings.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_12", 
            "text": "ManagedString s( abcd ); \n ManagedString p( efgh ) \n\n print(s + p) // prints  abcdefgh", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#charat", 
            "text": "", 
            "title": "charAt"
        }, 
        {
            "location": "/data-types/string/#char-charat-int16_t-index", 
            "text": "", 
            "title": "char charAt( int16_t index)"
        }, 
        {
            "location": "/data-types/string/#description_15", 
            "text": "Provides a character value at a given position in the string, indexed from zero.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_12", 
            "text": "int16_t   index  - The position of the character to return.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#returns_5", 
            "text": "the character at posisiton index, zero if index is invalid.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_13", 
            "text": "ManagedString s( abcd ); \n\n print(s.charAt(1)) // prints  b", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#tochararray", 
            "text": "", 
            "title": "toCharArray"
        }, 
        {
            "location": "/data-types/string/#const-char-tochararray", 
            "text": "", 
            "title": "const char * toCharArray()"
        }, 
        {
            "location": "/data-types/string/#description_16", 
            "text": "Provides an immutable 8 bit wide character buffer representing this string.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#returns_6", 
            "text": "a pointer to the character buffer.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#length", 
            "text": "", 
            "title": "length"
        }, 
        {
            "location": "/data-types/string/#int16_t-length", 
            "text": "", 
            "title": "int16_t length()"
        }, 
        {
            "location": "/data-types/string/#description_17", 
            "text": "Determines the length of this  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#returns_7", 
            "text": "the length of the string in characters.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_14", 
            "text": "ManagedString s( abcd ); \n\n print(s.length()) // prints  4", 
            "title": "Example"
        }, 
        {
            "location": "/ble/profile/", 
            "text": "BBC micro:bit Bluetooth Profile\n\n\nIntroduction\n\n\nThe BBC micro:bit will ship with a default Bluetooth Low Energy Profile flashed to it. This profile, in the terminology in use by the BBC is to be used with the \"tethered device\".\n\n\nThe profile consists of various \"services\" and \"characteristics\" designed to give easy access to the micro:bit's hardware so that initial exploration of the device's capabilities may take place using a corresponding, standard smart phone application.\n\n\nGiven the nature of micro:bit and the tools which will be available to developers, it will be possible for the profile to be partly or completely changed and replaced with a profile of the developer's own design. The latter case is out of scope for this document which focuses on the standard, default profilefor the tethered device scenario only.\n\n\nProfile Design\n\n\nThe profile was designed using Bluetooth Developer Studio and is presented in the form of two associated PDF documents depicting the profile at different levels of detail, which should be consulted alongside this supplement.\n\n\nStatus of the Design\n\n\nA version of the profile design was signed off on 28th May 2015. It was anticipated however that minor changes would be required and that these will be identified and applied iteratively during the implementation of the profile. For example data types may need optimising. Any further changes will mostly require the profile designer, Martin Woolley of the Bluetooth SIG to work with Joe Finney of Lancaster University.\n\n\nThe design should now be considered to be under change control.\n\n\nAssumptions\n\n\nThis initial profile design is based on discussions with other members of the team and various assumptions. As far as possible, assumptions have been documented here for reference purposes.\n\n\nmicro:bit Hardware Specification\n\n\nBluetooth Low Energy\n\n\nNordic Semiconductor nRF51822 with S110 soft device capable of both central and peripheral mode\n\n\nBluetooth 4.1 compliant\n\n\nSensors\n\n\nAccelerometer\n\n\nMagnetometer\n\n\nUser Interface\n\n\n2 buttons\n\n\n25 LED matrix (red)\n\n\n1 x System LED (yellow)\n\n\nI/O\n\n\n18 pins which may be used as either analogue or digital pins according to explicit configuration. The device firmware will automatically configure the input/output mode of a pin according to I/O operations addressed to it.\n\n\nPower\n\n\n1 x cell battery\n\n\nGeneral Design Assumptions\n\n\nmicro:bit will act as a GAP peripheral and advertise so that GAP central devices such as a smart phone can discover and connect to it.\n\n\nStandard Bluetooth SIG \"adopted\" services will be used where appropriate in conjunction with custom services designed specifically for micro:bit. As such the micro:bit will be shipped with a custom Bluetooth profile. At the time of writing, the Generic Access Service and Device Information Service have been identified as useful adopted services and included in the profile.\n\n\nThe micro:bit \"tethered\" profile is based around the capabilities and features of the micro:bit device itself. It is not tightly coupled to any particular application of the device such as video control or telephony. It is however able to indicate actions it wishes a connected client device to perform or signal events that have occurred and which the client is expected to act upon in some way.\n\n\nAll services are \"primary services\" and so may be discovered and enumerated by a client wishing to determine the capabilities of the device.\n\n\nEase of use has been considered to be more important than having absolute configurability of all aspects of the hardware (e.g. sensors) in the default profile.\n\n\nGATT Services\n\n\n\n\n\n\n\n\nService\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nGeneric Access Service\n\n\nAdopted\n\n\nProvides generic information about the device. Mandatory in GATT profiles.\n\n\n\n\n\n\nGeneric Attribute Service\n\n\nAdopted\n\n\nCan inform clients of changes in the attribute table such as reassigned handle values.Mandatory in GATT profiles.\n\n\n\n\n\n\nDevice Information Service\n\n\nAdopted\n\n\nProvides more comprehensive details about the device and its manufacturer\n\n\n\n\n\n\nAccelerometer Service\n\n\nCustom\n\n\nProvides access to the accelerometer sensor state and configuration of the frequency with which readings are reported.\n\n\n\n\n\n\nMagnetometer Service\n\n\nCustom\n\n\nProvides access to the magnetometer sensor state and configuration of the frequency with which readings are reported. Provides access to a \"current bearing\" value in degrees.\n\n\n\n\n\n\nTemperature Service\n\n\nCustom\n\n\nProvides access to a simplified, integer temperature measurement in celsius, derived from several sensors in the micro:bit.\n\n\n\n\n\n\nButton Service\n\n\nCustom\n\n\nAllow button state changes to be notified to the client\n\n\n\n\n\n\nLED Service\n\n\nCustom\n\n\nAllows access to both the LED \"display\" grid and the system status LED\n\n\n\n\n\n\nIO Pin Service\n\n\nCustom\n\n\nAllows access to and configuration of IO pins on the edge connector.\n\n\n\n\n\n\nEvent Service\n\n\nCustom\n\n\nAllows the micro:bit to inform the connected client of the types of event it wants to be informed about. Allows the client to inform the micro:bit of relevant events. Allows micro:bit to inform the client of events originating on the micro:bit.Event data includes both a type and a reason or origin.\n\n\n\n\n\n\n\n\nThe following sections elaborate on the description of a service and/or its characteristics where this seemed worthwhile.\n\n\nAbout the Device Information Service\n\n\nThis is an adopted service which defines 9 characteristics, all of which are optional members of of the service. For micro:bit we chose to include 5 of those characteristics only.\n\n\nSee \nhttps://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.device_information.xml\n\n\nAbout the Accelerometer Service\n\n\nCharacteristics\n\n\nAccelerometer Data\n : Contains accelerometer measurements for X, Y and Z axes as 3 unsigned 16 bit values in that order and in little endian format. Data can be read on demand or notified periodically. Values are in the range +/-1000 and in milli-newtons.\n\n\nAccelerometer Period:\n Determines the frequency with which accelerometer data is reported in milliseconds.\n\n\nAbout the Magnetometer Service\n\n\nCharacteristics\n\n\nMagnetometer Data\n : Contains magnetometer measurements for X, Y and Z axes as 3 unsigned 16 bit values in that order and in little endian format. Data can be read on demand or notified periodically.\n\n\nMagnetometer Period\n : Determines the frequency with which magnetometer data is reported in milliseconds.\n\n\nMagnetometer Bearing\n : Compass bearing in degrees from North.\n\n\nAbout the Temperature Service\n\n\nCharacteristics\n\n\nTemperature\n : Signed integer 8 bit value in celsius.\n\n\nAbout the Button Service\n\n\nThe Button Service exposes the two buttons on the micro:bit and allows their state to be read on demand by a connected client or the client to subscribe to notifications of state change. 3 button states are defined and represented by a simple numeric enumeration:  0 = not pressed, 1 = pressed, 2 = long press.\n\n\nAbout the LED Service\n\n\nThe service provides the client with direct control of each individual LED in the display grid. The client may also work at a higher level of abstraction and send strings of text to be displayed one character at a time on the LED display, with configurable scrolling transitions from one character to the next.\n\n\nA single characteristic containing a 32 bit mask (7 bits are unused) represents all 25 LEDs with a 0 bit indicating LED OFF and a 1 indicating LED ON. The characteristic may be written or read in a single GATT operation allowing efficient manipulation of all LEDs in the grid.\n\n\nOther characteristics allow a text string to be written to it by the client for display and the scrolling speed may be set.\n\n\nCharacteristics\n\n\nLED Matrix State\n : Allows the state of any|all LEDs in the 5x5 grid to be set to on or off with a single GATT operation. Consists of a 32 bit field with bits 0 - 24 representing the off (0) or on (1) state of the corresponding LED.\n\n\nLED Text\n : A UTF-8 string to be shown on the LED display.\n\n\nScrolling Speed\n : Specifies a millisecond delay to wait for in between showing each character on the display.\n\n\nAbout the IO Pin Service\n\n\nCharacteristics\n\n\nPin Data\n : Contains data relating to zero or more pins. Structured as a variable length array of up to 19 Pin Number / Value pairs. Pin Number and Value are each uint8 fields. Note however that the micro:bit has a 10 bit ADC and so values are compressed to 8 bits with a loss of resolution.\n\n\nWRITE: Clients may write values to one or more pins in a single GATT write operation. A pin to which a value is to be written must have been configured for output using the Pin IO Configuration characteristic. Any attempt to write to a pin which is configured for input will be ignored.\n\n\nNOTIFY: Notifications will deliver Pin Number / Value pairs for those pins defined as input pins by the Pin IO Configuration characteristic and whose value when read differs from the last read of the pin.\n\n\nREAD: A client reading this characteristic will receive Pin Number / Value pairs for \nall\n those pins defined as input pins by the Pin IO Configuration characteristic.\n\n\nThe associated Pin AD Configuration characteristic allows the client to indicate how each pin is to be used, as either an analogue or a digital pin.\n\n\nPin IO Configuration\n : A bit mask which allows each pin to be configured for input or output use. Bit n corresponds to pin n where 0 \n= n \n 19. A value of 0 means configured for output and 1 means configured for input.\n\n\nPin AD Configuration\n : A bit mask which allows each pin to be configured for analogue or digital use. Bit n corresponds to pin n where 0 \n= n \n 19. A value of 0 means digital and 1 means analogue.\n\n\nAbout the Event Service\n\n\nThe Event Service allows events or commands to be notified to the micro:bit by a connected client and it allows micro:bit to notify the connected client of events or commands originating from with the micro:bit. The micro:bit can inform the client of the types of event it is interested in being informed about (e.g. an incoming call) and the client can inform the micro:bit of types of event it wants to be notified about.  The term \"event\" will be used here for both event and command types of data.\n\n\nEvents may have an associated value.\n\n\nNote that specific event ID values including any special values such as those which may represent wild cards are not defined here. The micro:bit run time documentation should be consulted for this information.\n\n\nMultiple events of different types may be notified to the client or micro:bit at the same time.\n\n\nEvent data is encoded as an array of structs each encoding an event of a given type together with an associated value. Event Type and Event Value are both defined as uint16 and therefore the length of this array will always be a multiple of 4.\n\n\n\n\n\n\n\n\nstruct event {  uint16 event_type;  uint16 event_value;};\n\n\n\n\n\n\n\n\n\n\nThe Event Service has four characteristics in total:\n\n\nmicro:bit Requirements\n is a variable length list of event data structures which indicates the types of client event, potentially with a specific value which the micro:bit wishes to be informed of when they occur. The client should read this characteristic when it first connects to the micro:bit. It may also subscribe to notifications to that it can be informed if the value of this characteristic is changed by the micro:bit firmware.\n\n\nClient Requirements\n is a variable length list of event data structures which indicates the types of micro:bit event, potentially with a specific value which the client wishes to be informed of when they occur. The client should write to this characteristic when it first connects to the micro:bit.\n\n\nmicro:bit Event\n contains one or more event structures which should be notified to the client. It supports notifications and as such the client should subscribe to notifications from this characteristic.\n\n\nClient Event\n is a writable characteristic which the client may write one or more event structures to, to inform the micro:bit of events which have occurred on the client. These should be of types indicated in the micro:bit Requirements characteristic bit mask.\n\n\nAbout the DFU Control Service\n\n\nAllows clients to initiate the micro:bit pairing and over the air firmware update procedures. Firmware updates are actually handled by the Nordic Semiconductor DFU service which is not part of this profile, after the micro:bit enters an alternate bootloader.\n\n\nCharacteristics\n\n\nDFU Control\n : Writing 0x01 initiates rebooting the micro:bit into the Nordic Semiconductor bootloader if the DFU Flash Code characteristic has been written to with the correct secret key. Writing 0x02 to this charactertistic  means \"request flash code\".\n\n\nDFU Flash Code\n : Allows a client to indicate that it \"knows\" the flash code produced when pairing. Notifications are used to deliver the flash code to a client during the initial pairing process.\n\n\nOpen Issues\n\n\nIn no particular order:\n\n\n\n\n\n\nDevice will require listing on the Bluetooth SIG site. BBC are aware of the need and process.\n\n\n\n\n\n\nThe full list of event IDs needs to be defined and documented elsewhere. These are just tables of numeric identifiers with an associated meaning.\n\n\n\n\n\n\nAppendix A \u2013 Example Sequence Diagrams\n\n\n\n\nFigure 1 - Button Notifications\n\n\n\n\nFigure 2 - LED control\n\n\n\n\nFigure 3 - Accelerometer config and data notifications\n\n\nNB: Figure 3 shows accelerometer data as an example. The same pattern applies to the Magnetometer Service.\n\n\n\n\nFigure 4 - Client determining micro:bit notification requirements and then sending relevant events as they arise\n\n\n\n\nFigure 5 - micro:bit sending events / commands to the client\n\n\n\n\nFigure 6 - Client Event Requirements  and Notifications", 
            "title": "Profile"
        }, 
        {
            "location": "/ble/profile/#bbc-microbit-bluetooth-profile", 
            "text": "", 
            "title": "BBC micro:bit Bluetooth Profile"
        }, 
        {
            "location": "/ble/profile/#introduction", 
            "text": "The BBC micro:bit will ship with a default Bluetooth Low Energy Profile flashed to it. This profile, in the terminology in use by the BBC is to be used with the \"tethered device\".  The profile consists of various \"services\" and \"characteristics\" designed to give easy access to the micro:bit's hardware so that initial exploration of the device's capabilities may take place using a corresponding, standard smart phone application.  Given the nature of micro:bit and the tools which will be available to developers, it will be possible for the profile to be partly or completely changed and replaced with a profile of the developer's own design. The latter case is out of scope for this document which focuses on the standard, default profilefor the tethered device scenario only.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ble/profile/#profile-design", 
            "text": "The profile was designed using Bluetooth Developer Studio and is presented in the form of two associated PDF documents depicting the profile at different levels of detail, which should be consulted alongside this supplement.", 
            "title": "Profile Design"
        }, 
        {
            "location": "/ble/profile/#status-of-the-design", 
            "text": "A version of the profile design was signed off on 28th May 2015. It was anticipated however that minor changes would be required and that these will be identified and applied iteratively during the implementation of the profile. For example data types may need optimising. Any further changes will mostly require the profile designer, Martin Woolley of the Bluetooth SIG to work with Joe Finney of Lancaster University.  The design should now be considered to be under change control.", 
            "title": "Status of the Design"
        }, 
        {
            "location": "/ble/profile/#assumptions", 
            "text": "This initial profile design is based on discussions with other members of the team and various assumptions. As far as possible, assumptions have been documented here for reference purposes.", 
            "title": "Assumptions"
        }, 
        {
            "location": "/ble/profile/#microbit-hardware-specification", 
            "text": "Bluetooth Low Energy  Nordic Semiconductor nRF51822 with S110 soft device capable of both central and peripheral mode  Bluetooth 4.1 compliant  Sensors  Accelerometer  Magnetometer  User Interface  2 buttons  25 LED matrix (red)  1 x System LED (yellow)  I/O  18 pins which may be used as either analogue or digital pins according to explicit configuration. The device firmware will automatically configure the input/output mode of a pin according to I/O operations addressed to it.  Power  1 x cell battery", 
            "title": "micro:bit Hardware Specification"
        }, 
        {
            "location": "/ble/profile/#general-design-assumptions", 
            "text": "micro:bit will act as a GAP peripheral and advertise so that GAP central devices such as a smart phone can discover and connect to it.  Standard Bluetooth SIG \"adopted\" services will be used where appropriate in conjunction with custom services designed specifically for micro:bit. As such the micro:bit will be shipped with a custom Bluetooth profile. At the time of writing, the Generic Access Service and Device Information Service have been identified as useful adopted services and included in the profile.  The micro:bit \"tethered\" profile is based around the capabilities and features of the micro:bit device itself. It is not tightly coupled to any particular application of the device such as video control or telephony. It is however able to indicate actions it wishes a connected client device to perform or signal events that have occurred and which the client is expected to act upon in some way.  All services are \"primary services\" and so may be discovered and enumerated by a client wishing to determine the capabilities of the device.  Ease of use has been considered to be more important than having absolute configurability of all aspects of the hardware (e.g. sensors) in the default profile.", 
            "title": "General Design Assumptions"
        }, 
        {
            "location": "/ble/profile/#gatt-services", 
            "text": "Service  Type  Description      Generic Access Service  Adopted  Provides generic information about the device. Mandatory in GATT profiles.    Generic Attribute Service  Adopted  Can inform clients of changes in the attribute table such as reassigned handle values.Mandatory in GATT profiles.    Device Information Service  Adopted  Provides more comprehensive details about the device and its manufacturer    Accelerometer Service  Custom  Provides access to the accelerometer sensor state and configuration of the frequency with which readings are reported.    Magnetometer Service  Custom  Provides access to the magnetometer sensor state and configuration of the frequency with which readings are reported. Provides access to a \"current bearing\" value in degrees.    Temperature Service  Custom  Provides access to a simplified, integer temperature measurement in celsius, derived from several sensors in the micro:bit.    Button Service  Custom  Allow button state changes to be notified to the client    LED Service  Custom  Allows access to both the LED \"display\" grid and the system status LED    IO Pin Service  Custom  Allows access to and configuration of IO pins on the edge connector.    Event Service  Custom  Allows the micro:bit to inform the connected client of the types of event it wants to be informed about. Allows the client to inform the micro:bit of relevant events. Allows micro:bit to inform the client of events originating on the micro:bit.Event data includes both a type and a reason or origin.     The following sections elaborate on the description of a service and/or its characteristics where this seemed worthwhile.", 
            "title": "GATT Services"
        }, 
        {
            "location": "/ble/profile/#about-the-device-information-service", 
            "text": "This is an adopted service which defines 9 characteristics, all of which are optional members of of the service. For micro:bit we chose to include 5 of those characteristics only.  See  https://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.device_information.xml", 
            "title": "About the Device Information Service"
        }, 
        {
            "location": "/ble/profile/#about-the-accelerometer-service", 
            "text": "", 
            "title": "About the Accelerometer Service"
        }, 
        {
            "location": "/ble/profile/#characteristics", 
            "text": "Accelerometer Data  : Contains accelerometer measurements for X, Y and Z axes as 3 unsigned 16 bit values in that order and in little endian format. Data can be read on demand or notified periodically. Values are in the range +/-1000 and in milli-newtons.  Accelerometer Period:  Determines the frequency with which accelerometer data is reported in milliseconds.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/ble/profile/#about-the-magnetometer-service", 
            "text": "", 
            "title": "About the Magnetometer Service"
        }, 
        {
            "location": "/ble/profile/#characteristics_1", 
            "text": "Magnetometer Data  : Contains magnetometer measurements for X, Y and Z axes as 3 unsigned 16 bit values in that order and in little endian format. Data can be read on demand or notified periodically.  Magnetometer Period  : Determines the frequency with which magnetometer data is reported in milliseconds.  Magnetometer Bearing  : Compass bearing in degrees from North.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/ble/profile/#about-the-temperature-service", 
            "text": "", 
            "title": "About the Temperature Service"
        }, 
        {
            "location": "/ble/profile/#characteristics_2", 
            "text": "Temperature  : Signed integer 8 bit value in celsius.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/ble/profile/#about-the-button-service", 
            "text": "The Button Service exposes the two buttons on the micro:bit and allows their state to be read on demand by a connected client or the client to subscribe to notifications of state change. 3 button states are defined and represented by a simple numeric enumeration:  0 = not pressed, 1 = pressed, 2 = long press.", 
            "title": "About the Button Service"
        }, 
        {
            "location": "/ble/profile/#about-the-led-service", 
            "text": "The service provides the client with direct control of each individual LED in the display grid. The client may also work at a higher level of abstraction and send strings of text to be displayed one character at a time on the LED display, with configurable scrolling transitions from one character to the next.  A single characteristic containing a 32 bit mask (7 bits are unused) represents all 25 LEDs with a 0 bit indicating LED OFF and a 1 indicating LED ON. The characteristic may be written or read in a single GATT operation allowing efficient manipulation of all LEDs in the grid.  Other characteristics allow a text string to be written to it by the client for display and the scrolling speed may be set.", 
            "title": "About the LED Service"
        }, 
        {
            "location": "/ble/profile/#characteristics_3", 
            "text": "LED Matrix State  : Allows the state of any|all LEDs in the 5x5 grid to be set to on or off with a single GATT operation. Consists of a 32 bit field with bits 0 - 24 representing the off (0) or on (1) state of the corresponding LED.  LED Text  : A UTF-8 string to be shown on the LED display.  Scrolling Speed  : Specifies a millisecond delay to wait for in between showing each character on the display.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/ble/profile/#about-the-io-pin-service", 
            "text": "", 
            "title": "About the IO Pin Service"
        }, 
        {
            "location": "/ble/profile/#characteristics_4", 
            "text": "Pin Data  : Contains data relating to zero or more pins. Structured as a variable length array of up to 19 Pin Number / Value pairs. Pin Number and Value are each uint8 fields. Note however that the micro:bit has a 10 bit ADC and so values are compressed to 8 bits with a loss of resolution.  WRITE: Clients may write values to one or more pins in a single GATT write operation. A pin to which a value is to be written must have been configured for output using the Pin IO Configuration characteristic. Any attempt to write to a pin which is configured for input will be ignored.  NOTIFY: Notifications will deliver Pin Number / Value pairs for those pins defined as input pins by the Pin IO Configuration characteristic and whose value when read differs from the last read of the pin.  READ: A client reading this characteristic will receive Pin Number / Value pairs for  all  those pins defined as input pins by the Pin IO Configuration characteristic.  The associated Pin AD Configuration characteristic allows the client to indicate how each pin is to be used, as either an analogue or a digital pin.  Pin IO Configuration  : A bit mask which allows each pin to be configured for input or output use. Bit n corresponds to pin n where 0  = n   19. A value of 0 means configured for output and 1 means configured for input.  Pin AD Configuration  : A bit mask which allows each pin to be configured for analogue or digital use. Bit n corresponds to pin n where 0  = n   19. A value of 0 means digital and 1 means analogue.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/ble/profile/#about-the-event-service", 
            "text": "The Event Service allows events or commands to be notified to the micro:bit by a connected client and it allows micro:bit to notify the connected client of events or commands originating from with the micro:bit. The micro:bit can inform the client of the types of event it is interested in being informed about (e.g. an incoming call) and the client can inform the micro:bit of types of event it wants to be notified about.  The term \"event\" will be used here for both event and command types of data.  Events may have an associated value.  Note that specific event ID values including any special values such as those which may represent wild cards are not defined here. The micro:bit run time documentation should be consulted for this information.  Multiple events of different types may be notified to the client or micro:bit at the same time.  Event data is encoded as an array of structs each encoding an event of a given type together with an associated value. Event Type and Event Value are both defined as uint16 and therefore the length of this array will always be a multiple of 4.     struct event {  uint16 event_type;  uint16 event_value;};      The Event Service has four characteristics in total:  micro:bit Requirements  is a variable length list of event data structures which indicates the types of client event, potentially with a specific value which the micro:bit wishes to be informed of when they occur. The client should read this characteristic when it first connects to the micro:bit. It may also subscribe to notifications to that it can be informed if the value of this characteristic is changed by the micro:bit firmware.  Client Requirements  is a variable length list of event data structures which indicates the types of micro:bit event, potentially with a specific value which the client wishes to be informed of when they occur. The client should write to this characteristic when it first connects to the micro:bit.  micro:bit Event  contains one or more event structures which should be notified to the client. It supports notifications and as such the client should subscribe to notifications from this characteristic.  Client Event  is a writable characteristic which the client may write one or more event structures to, to inform the micro:bit of events which have occurred on the client. These should be of types indicated in the micro:bit Requirements characteristic bit mask.", 
            "title": "About the Event Service"
        }, 
        {
            "location": "/ble/profile/#about-the-dfu-control-service", 
            "text": "Allows clients to initiate the micro:bit pairing and over the air firmware update procedures. Firmware updates are actually handled by the Nordic Semiconductor DFU service which is not part of this profile, after the micro:bit enters an alternate bootloader.", 
            "title": "About the DFU Control Service"
        }, 
        {
            "location": "/ble/profile/#characteristics_5", 
            "text": "DFU Control  : Writing 0x01 initiates rebooting the micro:bit into the Nordic Semiconductor bootloader if the DFU Flash Code characteristic has been written to with the correct secret key. Writing 0x02 to this charactertistic  means \"request flash code\".  DFU Flash Code  : Allows a client to indicate that it \"knows\" the flash code produced when pairing. Notifications are used to deliver the flash code to a client during the initial pairing process.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/ble/profile/#open-issues", 
            "text": "In no particular order:    Device will require listing on the Bluetooth SIG site. BBC are aware of the need and process.    The full list of event IDs needs to be defined and documented elsewhere. These are just tables of numeric identifiers with an associated meaning.", 
            "title": "Open Issues"
        }, 
        {
            "location": "/ble/profile/#appendix-a-example-sequence-diagrams", 
            "text": "Figure 1 - Button Notifications   Figure 2 - LED control   Figure 3 - Accelerometer config and data notifications  NB: Figure 3 shows accelerometer data as an example. The same pattern applies to the Magnetometer Service.   Figure 4 - Client determining micro:bit notification requirements and then sending relevant events as they arise   Figure 5 - micro:bit sending events / commands to the client   Figure 6 - Client Event Requirements  and Notifications", 
            "title": "Appendix A \u2013 Example Sequence Diagrams"
        }, 
        {
            "location": "/extras/light-sensing/", 
            "text": "MicroBitLightSensor\n\n\nOperation\n\n\nSensing Pins\n\n\nIf the current is inverted on an LED, it becomes sensitive to light. In particular\nit is sensitive to the \nsame colour\n of light it emits.\n\n\nYou will find that the Light Sensor on the micro:bit is more reactive to red light\nthan any other colour because that is the colour of light the display emits.\n\n\nThe display is architected with 3 rows, each with 9 columns. This is illustrated\nbelow:\n\n\n\n\nWhere the format is: \nROW\n.\nCOLUMN\n\n\nOn the micro:bit we have 6 analog pins, 3 are applicable to the display and reside\non columns 1, 2 and 3.\n\n\nThis means that we have 9 pins in total that we can sense light on if we are\nfast enough to transition between emitting and sensing light.\n\n\nThe 9 sense pins are illustrated below:\n\n\n\n\n _____________________________\n| 1.1 |     | 1.2 |     | 1.3 |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n| 2.2 |     | 2.3 |     | 2.1 |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n| 3.3 |     | 3.1 |     | 3.2 |\n|_____|_____|_____|_____|_____|\n\n\n\n\n\n\nThe ADC takes around 4ms to settle and give accurate values with minimal current.\nThis places restrictions on our sensing window.\n\n\nInterleaving\n\n\nIn the current implementation, the display and the Light sensor can operate in an\ninterleaving manner. This interleaving is enabled due to a special display mode on the \ndisplay\n\nwhich is automatically activated when \nreadLightLevel\n is called by the user.\n\n\nThis special mode (\nDISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE\n), increases the rate of the \nsystemTick\n callback to 5ms, and the\n\ndisplay\n is thusly configured to drop the 4th frame for user processing,\nwhich in this case, is entirely consumed by the light sensor. This reduces the display\nrefresh rate from 55Hz to around 50Hz.\n\n\nTo signify the window for user processing, the display will fire an event:\n\n\n\n\nID\n: \nMICROBIT_ID_DISPLAY\n\n\nValue\n: \nMICROBIT_DISPLAY_EVT_LIGHT_SENSE\n\n\n\n\nThis will trigger an event handler in the \nMicroBitLightSensor\n class.\n\n\nSensing Life Cycle\n\n\nIn the previous section we discussed how the \ndisplay\n and the Light\nSensor interleave. This section will cover the actual operation of the sensor during\nthe \nMICROBIT_DISPLAY_EVT_LIGHT_SENSE\n event.\n\n\n\n\n\n\nNote\n\n\nIf you would like to manually trigger the Light Sensor, a few steps must be taken:\n\n1) Disable the display so that the column pins are under the users' control.\n\n2) Construct an instance of \nMicroBitLightSensor\n\n3) Trigger the Light Sensor by firing a \nMicroBitEvent\n with the ID \nMICROBIT_ID_DISPLAY\n and the value \nMICROBIT_DISPLAY_EVT_LIGHT_SENSE\n.\n\n\n\n\nThe Concept of Channels\n\n\nAs we previously discussed there are 9 pins we can sense light on. However, we face the problem\nof interference from the state of other Columns.\n\n\nWe found that the best combination was to treat each of the three analog enabled Columns as a channel.\nThis leads our picture to look something more like this:\n\n\n\n\n _____________________________\n|  1  |     |  2  |     |  3  |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n|  2  |     |  3  |     |  1  |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n|  3  |     |  1  |     |  2  |\n|_____|_____|_____|_____|_____|\n\n\n\n\n\n\nWhere each number represents a different column, now named a channel as it is a collection of 3 rows\n\n\nThis reduces the resolution of our light sensing capabilities as we can\nnow no longer can use 9 pins to sense light, purely due to the unfortunate fact\nthat we obtain interference from other pins that cannot be mitigated.\n\n\nHowever, we do gain an accurate picture of the overall brightness detected by the display.\n\n\nWe expose a mean representation of the light level from the 3 channels on the display.\n\n\nThe Algorithm\n\n\nUpon receiving an event:\n\n\n\n\nSet all rows to be a DigitalOut, with a value of 0.\n\n\nFor the current channel:\n\n\nSet the current channel pin HI.\n\n\nImmediately transition the current channel to be an AnalogIn\n\n\n\n\n\n\nAttach an interrupt to occur 4ms into the future. (This allows our AnalogIn instance\nto settle correctly)\n\n\n\n\nUpon interrupt:\n\n\n\n\nObtain our analog value.\n\n\nRelease the pin from GPIOTE control. (\nIf we do not do these, this column will not\nbe useable in the display driver\n)\n\n\nMove onto the next channel.\n\n\n\n\nAfter these two phases have occurred, the display will now once again be available\nfor regular usage until the next interleave is signaled by the display.\n\n\nMessage Bus ID\n\n\nMessage Bus Events\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitLightSensor()\n\n\nDescription\n\n\nConstructor. Create a representation of the light sensor \n\n\nread\n\n\n\n\nint\n read()\n\n\nDescription\n\n\nThis method returns a summed average of the three sections of the display.\n\n\nReturns\n\n\nreturns a value in the range 0 - 255 where 0 is dark, and 255 is very bright\n\n\n\n\nNote\n\n\ncurrently returns a value in the range 0 - 255 where 0 is dark, and 255 is very bright perhaps we should normalise the returned values into an SI unit! TODO. \n\n\n\n\n~MicroBitLightSensor\n\n\n\n\n~MicroBitLightSensor()\n\n\nDescription\n\n\nThe destructor restores the default Display Mode and tick speed, and also removes the listener from the MessageBus.", 
            "title": "MicroBitLightSensor"
        }, 
        {
            "location": "/extras/light-sensing/#microbitlightsensor", 
            "text": "", 
            "title": "MicroBitLightSensor"
        }, 
        {
            "location": "/extras/light-sensing/#operation", 
            "text": "", 
            "title": "Operation"
        }, 
        {
            "location": "/extras/light-sensing/#sensing-pins", 
            "text": "If the current is inverted on an LED, it becomes sensitive to light. In particular\nit is sensitive to the  same colour  of light it emits.  You will find that the Light Sensor on the micro:bit is more reactive to red light\nthan any other colour because that is the colour of light the display emits.  The display is architected with 3 rows, each with 9 columns. This is illustrated\nbelow:   Where the format is:  ROW . COLUMN  On the micro:bit we have 6 analog pins, 3 are applicable to the display and reside\non columns 1, 2 and 3.  This means that we have 9 pins in total that we can sense light on if we are\nfast enough to transition between emitting and sensing light.  The 9 sense pins are illustrated below:    _____________________________\n| 1.1 |     | 1.2 |     | 1.3 |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n| 2.2 |     | 2.3 |     | 2.1 |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n| 3.3 |     | 3.1 |     | 3.2 |\n|_____|_____|_____|_____|_____|   The ADC takes around 4ms to settle and give accurate values with minimal current.\nThis places restrictions on our sensing window.", 
            "title": "Sensing Pins"
        }, 
        {
            "location": "/extras/light-sensing/#interleaving", 
            "text": "In the current implementation, the display and the Light sensor can operate in an\ninterleaving manner. This interleaving is enabled due to a special display mode on the  display \nwhich is automatically activated when  readLightLevel  is called by the user.  This special mode ( DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE ), increases the rate of the  systemTick  callback to 5ms, and the display  is thusly configured to drop the 4th frame for user processing,\nwhich in this case, is entirely consumed by the light sensor. This reduces the display\nrefresh rate from 55Hz to around 50Hz.  To signify the window for user processing, the display will fire an event:   ID :  MICROBIT_ID_DISPLAY  Value :  MICROBIT_DISPLAY_EVT_LIGHT_SENSE   This will trigger an event handler in the  MicroBitLightSensor  class.", 
            "title": "Interleaving"
        }, 
        {
            "location": "/extras/light-sensing/#sensing-life-cycle", 
            "text": "In the previous section we discussed how the  display  and the Light\nSensor interleave. This section will cover the actual operation of the sensor during\nthe  MICROBIT_DISPLAY_EVT_LIGHT_SENSE  event.    Note  If you would like to manually trigger the Light Sensor, a few steps must be taken: \n1) Disable the display so that the column pins are under the users' control. \n2) Construct an instance of  MicroBitLightSensor \n3) Trigger the Light Sensor by firing a  MicroBitEvent  with the ID  MICROBIT_ID_DISPLAY  and the value  MICROBIT_DISPLAY_EVT_LIGHT_SENSE .", 
            "title": "Sensing Life Cycle"
        }, 
        {
            "location": "/extras/light-sensing/#the-concept-of-channels", 
            "text": "As we previously discussed there are 9 pins we can sense light on. However, we face the problem\nof interference from the state of other Columns.  We found that the best combination was to treat each of the three analog enabled Columns as a channel.\nThis leads our picture to look something more like this:    _____________________________\n|  1  |     |  2  |     |  3  |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n|  2  |     |  3  |     |  1  |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n|  3  |     |  1  |     |  2  |\n|_____|_____|_____|_____|_____|   Where each number represents a different column, now named a channel as it is a collection of 3 rows  This reduces the resolution of our light sensing capabilities as we can\nnow no longer can use 9 pins to sense light, purely due to the unfortunate fact\nthat we obtain interference from other pins that cannot be mitigated.  However, we do gain an accurate picture of the overall brightness detected by the display.  We expose a mean representation of the light level from the 3 channels on the display.", 
            "title": "The Concept of Channels"
        }, 
        {
            "location": "/extras/light-sensing/#the-algorithm", 
            "text": "Upon receiving an event:   Set all rows to be a DigitalOut, with a value of 0.  For the current channel:  Set the current channel pin HI.  Immediately transition the current channel to be an AnalogIn    Attach an interrupt to occur 4ms into the future. (This allows our AnalogIn instance\nto settle correctly)   Upon interrupt:   Obtain our analog value.  Release the pin from GPIOTE control. ( If we do not do these, this column will not\nbe useable in the display driver )  Move onto the next channel.   After these two phases have occurred, the display will now once again be available\nfor regular usage until the next interleave is signaled by the display.", 
            "title": "The Algorithm"
        }, 
        {
            "location": "/extras/light-sensing/#message-bus-id", 
            "text": "", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/extras/light-sensing/#message-bus-events", 
            "text": "", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/extras/light-sensing/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/extras/light-sensing/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/extras/light-sensing/#microbitlightsensor_1", 
            "text": "", 
            "title": "MicroBitLightSensor()"
        }, 
        {
            "location": "/extras/light-sensing/#description", 
            "text": "Constructor. Create a representation of the light sensor", 
            "title": "Description"
        }, 
        {
            "location": "/extras/light-sensing/#read", 
            "text": "", 
            "title": "read"
        }, 
        {
            "location": "/extras/light-sensing/#int-read", 
            "text": "", 
            "title": "int read()"
        }, 
        {
            "location": "/extras/light-sensing/#description_1", 
            "text": "This method returns a summed average of the three sections of the display.", 
            "title": "Description"
        }, 
        {
            "location": "/extras/light-sensing/#returns", 
            "text": "returns a value in the range 0 - 255 where 0 is dark, and 255 is very bright   Note  currently returns a value in the range 0 - 255 where 0 is dark, and 255 is very bright perhaps we should normalise the returned values into an SI unit! TODO.", 
            "title": "Returns"
        }, 
        {
            "location": "/extras/light-sensing/#microbitlightsensor_2", 
            "text": "", 
            "title": "~MicroBitLightSensor"
        }, 
        {
            "location": "/extras/light-sensing/#microbitlightsensor_3", 
            "text": "", 
            "title": "~MicroBitLightSensor()"
        }, 
        {
            "location": "/extras/light-sensing/#description_2", 
            "text": "The destructor restores the default Display Mode and tick speed, and also removes the listener from the MessageBus.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/blemanager/", 
            "text": "", 
            "title": "_blemanager"
        }
    ]
}