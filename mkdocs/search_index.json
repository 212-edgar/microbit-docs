{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nThe micro:bit runtime provides an easy to use environment for programming the BBC micro:bit\nin the C/C++ language, written by Lancaster University. It contains device drivers for all the hardware capabilities of the micro:bit,\nand also a suite of runtime mechanisms to make programming the micro:bit easier and more flexible. These\nrange from control of the LED mtrix display to peer-to-peer radio communication and secure \nBluetooth Low Energy services. The micro:bit runtime is proudly built on the \nARM mbed\n \nand \nNordic nrf51\n platforms.\n\n\nIn addition to supporting development in C/C++, the runtime is also designed specifically to support \nhigher level languages provided by our partners that target the micro:bit. It is currently used as a support library for all the \nlanguages on the BBC \nwww.microbit.co.uk\n website, including Microsoft Block, Microsoft TouchDevelop, Code Kingdoms \nJavaScript and Micropython languages.\n\n\nOn these pages you will find guidance on how to start using the runtime in C/C++, summaries of all the\ncomponents that make up the system and a full set of API documentation (the functions you can use to control the micro:bit).\n\n\nJust to show how easy it is to get started, here is how you would write a traditional Hello World program... \n\n\n   uBit.display.scroll(\nHello micro:bit!\n);\n\n\n\n\nNot so scary after all, eh? \nSo, see the getting started and concepts sections to learn more... then go and create!", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "The micro:bit runtime provides an easy to use environment for programming the BBC micro:bit\nin the C/C++ language, written by Lancaster University. It contains device drivers for all the hardware capabilities of the micro:bit,\nand also a suite of runtime mechanisms to make programming the micro:bit easier and more flexible. These\nrange from control of the LED mtrix display to peer-to-peer radio communication and secure \nBluetooth Low Energy services. The micro:bit runtime is proudly built on the  ARM mbed  \nand  Nordic nrf51  platforms.  In addition to supporting development in C/C++, the runtime is also designed specifically to support \nhigher level languages provided by our partners that target the micro:bit. It is currently used as a support library for all the \nlanguages on the BBC  www.microbit.co.uk  website, including Microsoft Block, Microsoft TouchDevelop, Code Kingdoms \nJavaScript and Micropython languages.  On these pages you will find guidance on how to start using the runtime in C/C++, summaries of all the\ncomponents that make up the system and a full set of API documentation (the functions you can use to control the micro:bit).  Just to show how easy it is to get started, here is how you would write a traditional Hello World program...      uBit.display.scroll( Hello micro:bit! );  Not so scary after all, eh? \nSo, see the getting started and concepts sections to learn more... then go and create!", 
            "title": "Introduction"
        }, 
        {
            "location": "/concepts/", 
            "text": "Concepts\n\n\nThe micro:bit runtime provides an easy to use environment for programming the BBC micro:bit\nin the C/C++ language. It contains device drivers for all the hardware capabilities of the micro:bit,\nand also a suite of runtime mechanisms to make programming the micro:bit easier and more flexible. These\nrange from control of the LED mtrix display to peer-to-peer radio communication and secure \nBluetooth Low Energy services. The micro:bit runtime is proudly built on the \nARM mbed\n \nand \nNordic nrf51\n platforms.\n\n\nIn addition to supporting development in C/C++, the runtime is also designed specifically to support \nhigher level languages provided by our partners that target the micro:bit. It is currently used as a support library for all the \nlanguages on the BBC \nwww.microbit.co.uk\n website, including Microsoft Block, Microsoft TouchDevelop, Code Kingdoms \nJavaScript and Micropython languages.\n\n\n\n\nA Component Based Approach\n\n\nWhenever computer scientists tackle large programming problems, we take the time to split the problem into smaller,\nindependent sections to make the problem easier to solve (divide and conquer!).  The micro:bit runtime is no exception, \nand is made up of a number of smaller components. Each of these components looks after\na specific job on the micro:bit. Building up software like this helps us to write code in a way that is\nmuch easier to maintain as the amount of code grows. For example, a component called \nMicroBitDisplay\n \ncontrols the LEDs on the micro:bit, and lets the programmer show images, animations and messages. The\n\nMicroBitIO\n component controls input and output thorugh the pins on the edge of the device. \nThe micro:bit runtime is object oriented, with each component typically being a C++ class. \nThere are over 30 components making up the runtime, and they are documented on these pages. \n\n\nTo make the runtime as easy to use as possible, there is also a grouping of the most commonly used components in\nan object called \nuBit\n (The 'u' being the greek letter mu - which often refers to 'micro' in scientific units!). \nThe uBit object can be used to easily access most of the functionality of the micro:bit. You can find the components \nand functions that can be accessed this way in the \nuBit\n menu tab at the top of this page... Browse this to find the core\nAPI documentation for functions in the micro:bit runtime.\n\n\nTo show just how easy it is to get started, the following code shows how you would write a traditional Hello World program.\nThis uses the uBit object to access the display component, then instructs the display to scroll the given string across\nthe LEDs. Try to use the \nuBit\n menu tab above to find the documentation for this scroll() function! \n\n\n   uBit.display.scroll(\nHello micro:bit!\n);\n\n\n\n\n\n\nNote\n\n\nDid you know that you don't need to use the uBit object? Advanced users will likely prefer to create only the components they need to conserve memory on the device. See the \nadvanced\n section for how to do this.\n\n\n\n\nEvents\n\n\nComputer programs execute sequentially - one line after another, following the logic of the progrmam you have written.\nSometimes though, we wnt to be able to determine \nwhen\n something has happened, and write some code to decide what should \nhappen in that case. For example, maybe you want to know when a button has been pressed, when your micro:bit has been shaken,\nor when some data has been sent to you over the device's radio. For these sorts of cases, we create a \nMicroBitEvent\n.\n\n\nCreating Events\n\n\nMany componets will raise events when interesting things occur (e.g. MicroBitAccelerometer will raise events to indicate that the\nmicro:bit has be been shaken, or is in freefall. MicroBitButton will send events on a range of button up, down, click and hold events. \nProgrammers are also free to send their own events whenever they feel it would be useful. MicroBitvents are \nvery\n simple, and consist of\nonly two numbers:\n\n\n\n\nA source. A number identifying the component that created the event.\n\n\nA value. A number unqiue to the source that identifies the event.\n\n\n\n\nThe documentation for each component defines its event source, and all the events it may generate, and also gives a name to these\nevent values. For example, take a look at the \nbutton documentation\n to see that the source MICROBIT_ID_BUTTON_A has the value '1',\nand an event MICROBIT_BUTTON_EVT_CLICK with the value '3' is generted when a button is clicked.\n\n\nCreating an event is easy - just create a MicroBitEvent with the source avd value you need:\n\n\nMicroBitEvent(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK);\n\n\n\n\nFeel free to create your own events lke this too. Just try to avoid using any source ID that is already used by the runtime! :-)\nSee the \nmessageBus\n page for a complete table of the reserved source IDs.\n\n\nDetecting Events\n\n\nThe micro:bit runtime has a component called the MicroBitMessgeBus, and its job is remember which events your program is interested in, and \nto deliver those MicroBitEvents to your program as they occur. To find out when an event happens, you need to create a function in your program,\nthen tell the message bus which event you want to attach this function to. This is known as writing an \nevent handler\n.\n\nYou do this through the MicroBitMessageBus \nlisten\n function.\n\nThis may sound complex at first, but it is actually very simple. For example, to find out when button A is clicked, write some code like this:\n\n\nvoid onButtonA(MicroBitEvent e)\n{\n    uBit.display.print(\nA\n);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n}\n\n\n\n\nNow, whenever the MICROBIT_BUTTON_EVT_CLICK event is raise by MICROBIT_ID_BUTTON_A, your code inside function 'onButtonA' will be automatically run.\n\nYou can call listen as many times as you want to attached functions to each of the events that are useful for your program. In fact, a block like the\nfollowing in the Microsoft Block language traslates into code just like that shown above when it is run on a micro:bit!\n\n\n\n\nWildcard Events\n\n\nSometimes though, you want to capture all events genareted by some component. For example, you might want to know when any chages in a button has happened. \nIn this case, there is a special event value called 'MICROBIT_EVT_ANY'. If you call listen with this value, then ALL events from the given source component will be delivered to your function.\nYou can find out which ones by looking at the MicroBitEvent delivered to your function - it contains the source and value variable of the event. For example, you could write\na program like this:\n\n\nvoid onButtonA(MicroBitEvent e)\n{\n    if (e.value == MICROBIT_BUTTON_EVT_CLICK)\n        uBit.display.scroll(\nCLICK\n);\n\n    if (e.value == MICROBIT_BUTTON_EVT_DOWN)\n        uBit.display.scroll(\nDOWN\n);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY, onButtonA);\n}\n\n\n\n\nIf you \nREALLY\n want even more events, there is also a MICROBIT_ID_ANY source, that allows you to attach a function to event generated from any component... Use this\nsparingly though, as this could be quite a lot of events! e.g. The following code would attach the onEvent function to receive all the events from the whole runtime:\n\n\nvoid onEvent(MicroBitEvent e)\n{\n    uBit.display.scroll(\nSOMETHING HAPPENED!\n);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_ANY, MICROBIT_EVT_ANY, onEvent);\n}\n\n\n\n\nQueued Events\n\n\nWhen you write an event handler, your function will be called each time the relevant event is raised. But what happens if your handler takes a long time to execute?\nFor example, the example above will scroll \"SOMETHING HAPPENED\" whenever any event at all is raised... but scrolling that message will take several seconds to complete! \nWhat is another event happens during this time?  By default, the runtime will queue any events for your event handler until it has finished what its already doing. \nAs soon as your handler is finished processing an event, the next one will be delivered (any other event handlers will be unaffected though - just becuase one event handler\nis busy, doesn't mean that another one can't receive its events!).\n\n\nThe runtime does allow you to change this behaviour if you want to though. See the advanced documentation in \nMicroBitMessageBus\n for more details.\n\n\n\n\nNote\n\n\nMore advanced programmers might be interested to know that you can also attach event handler to member function of C++ objects. See the other forms of listen function in \nMicroBitMessageBus\n for more details.\n\n\n\n\nConcurrency\n\n\nIt is not uncommon to want to write programs that can do more than one thing at a time. For example, it takes quite a long time to scroll a message over the LED matrix, so what if you want\nyour program to do something else while this is happening? Programs that do more than one thing at a time are called \nconcurrent programs\n. The runtime provides two ways you can \nachieve concurrency in your programs:\n\n\n\n\n\n\nFunctions that may take a very long time to complete (e.g. display.scroll) often have \"Async\" versions (e.g. display.scrollAsync). These functions\nhave the exact same behaviour as their counterparts, but don't wait for the effect to finish before allowing the user's program to continue. Instead, as soon as the function is called, \nuser's program carries on executing (and can go an do something else while the task is running in the background).\n\n\n\n\n\n\nUsers can also make use of the runtime fiber scheduler. This lets you run parts of your program in the background, and share the processor on your micro:bit between those parts\nas they need it. In fact, whenever you write an event handler, the runtime will normally execute your handler in the background in this way, so that it reduces the impact on the rest of your program!\nThe scheduler is a type of \nnon-preemptive scheduler\n. This means that the runtime will never take control away from your program - it will wait for it to share by making a call to a runtime \nfunction that is \nblocking\n. All the functions that are blocking are listed as such in their documentation.  You can create \nfibers\n at any time. See the \ncreate_fiber\n function for more details.", 
            "title": "Concepts"
        }, 
        {
            "location": "/concepts/#concepts", 
            "text": "The micro:bit runtime provides an easy to use environment for programming the BBC micro:bit\nin the C/C++ language. It contains device drivers for all the hardware capabilities of the micro:bit,\nand also a suite of runtime mechanisms to make programming the micro:bit easier and more flexible. These\nrange from control of the LED mtrix display to peer-to-peer radio communication and secure \nBluetooth Low Energy services. The micro:bit runtime is proudly built on the  ARM mbed  \nand  Nordic nrf51  platforms.  In addition to supporting development in C/C++, the runtime is also designed specifically to support \nhigher level languages provided by our partners that target the micro:bit. It is currently used as a support library for all the \nlanguages on the BBC  www.microbit.co.uk  website, including Microsoft Block, Microsoft TouchDevelop, Code Kingdoms \nJavaScript and Micropython languages.", 
            "title": "Concepts"
        }, 
        {
            "location": "/concepts/#a-component-based-approach", 
            "text": "Whenever computer scientists tackle large programming problems, we take the time to split the problem into smaller,\nindependent sections to make the problem easier to solve (divide and conquer!).  The micro:bit runtime is no exception, \nand is made up of a number of smaller components. Each of these components looks after\na specific job on the micro:bit. Building up software like this helps us to write code in a way that is\nmuch easier to maintain as the amount of code grows. For example, a component called  MicroBitDisplay  \ncontrols the LEDs on the micro:bit, and lets the programmer show images, animations and messages. The MicroBitIO  component controls input and output thorugh the pins on the edge of the device. \nThe micro:bit runtime is object oriented, with each component typically being a C++ class. \nThere are over 30 components making up the runtime, and they are documented on these pages.   To make the runtime as easy to use as possible, there is also a grouping of the most commonly used components in\nan object called  uBit  (The 'u' being the greek letter mu - which often refers to 'micro' in scientific units!). \nThe uBit object can be used to easily access most of the functionality of the micro:bit. You can find the components \nand functions that can be accessed this way in the  uBit  menu tab at the top of this page... Browse this to find the core\nAPI documentation for functions in the micro:bit runtime.  To show just how easy it is to get started, the following code shows how you would write a traditional Hello World program.\nThis uses the uBit object to access the display component, then instructs the display to scroll the given string across\nthe LEDs. Try to use the  uBit  menu tab above to find the documentation for this scroll() function!      uBit.display.scroll( Hello micro:bit! );   Note  Did you know that you don't need to use the uBit object? Advanced users will likely prefer to create only the components they need to conserve memory on the device. See the  advanced  section for how to do this.", 
            "title": "A Component Based Approach"
        }, 
        {
            "location": "/concepts/#events", 
            "text": "Computer programs execute sequentially - one line after another, following the logic of the progrmam you have written.\nSometimes though, we wnt to be able to determine  when  something has happened, and write some code to decide what should \nhappen in that case. For example, maybe you want to know when a button has been pressed, when your micro:bit has been shaken,\nor when some data has been sent to you over the device's radio. For these sorts of cases, we create a  MicroBitEvent .", 
            "title": "Events"
        }, 
        {
            "location": "/concepts/#creating-events", 
            "text": "Many componets will raise events when interesting things occur (e.g. MicroBitAccelerometer will raise events to indicate that the\nmicro:bit has be been shaken, or is in freefall. MicroBitButton will send events on a range of button up, down, click and hold events. \nProgrammers are also free to send their own events whenever they feel it would be useful. MicroBitvents are  very  simple, and consist of\nonly two numbers:   A source. A number identifying the component that created the event.  A value. A number unqiue to the source that identifies the event.   The documentation for each component defines its event source, and all the events it may generate, and also gives a name to these\nevent values. For example, take a look at the  button documentation  to see that the source MICROBIT_ID_BUTTON_A has the value '1',\nand an event MICROBIT_BUTTON_EVT_CLICK with the value '3' is generted when a button is clicked.  Creating an event is easy - just create a MicroBitEvent with the source avd value you need:  MicroBitEvent(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK);  Feel free to create your own events lke this too. Just try to avoid using any source ID that is already used by the runtime! :-)\nSee the  messageBus  page for a complete table of the reserved source IDs.", 
            "title": "Creating Events"
        }, 
        {
            "location": "/concepts/#detecting-events", 
            "text": "The micro:bit runtime has a component called the MicroBitMessgeBus, and its job is remember which events your program is interested in, and \nto deliver those MicroBitEvents to your program as they occur. To find out when an event happens, you need to create a function in your program,\nthen tell the message bus which event you want to attach this function to. This is known as writing an  event handler . \nYou do this through the MicroBitMessageBus  listen  function. \nThis may sound complex at first, but it is actually very simple. For example, to find out when button A is clicked, write some code like this:  void onButtonA(MicroBitEvent e)\n{\n    uBit.display.print( A );\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n}  Now, whenever the MICROBIT_BUTTON_EVT_CLICK event is raise by MICROBIT_ID_BUTTON_A, your code inside function 'onButtonA' will be automatically run. \nYou can call listen as many times as you want to attached functions to each of the events that are useful for your program. In fact, a block like the\nfollowing in the Microsoft Block language traslates into code just like that shown above when it is run on a micro:bit!", 
            "title": "Detecting Events"
        }, 
        {
            "location": "/concepts/#wildcard-events", 
            "text": "Sometimes though, you want to capture all events genareted by some component. For example, you might want to know when any chages in a button has happened. \nIn this case, there is a special event value called 'MICROBIT_EVT_ANY'. If you call listen with this value, then ALL events from the given source component will be delivered to your function.\nYou can find out which ones by looking at the MicroBitEvent delivered to your function - it contains the source and value variable of the event. For example, you could write\na program like this:  void onButtonA(MicroBitEvent e)\n{\n    if (e.value == MICROBIT_BUTTON_EVT_CLICK)\n        uBit.display.scroll( CLICK );\n\n    if (e.value == MICROBIT_BUTTON_EVT_DOWN)\n        uBit.display.scroll( DOWN );\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY, onButtonA);\n}  If you  REALLY  want even more events, there is also a MICROBIT_ID_ANY source, that allows you to attach a function to event generated from any component... Use this\nsparingly though, as this could be quite a lot of events! e.g. The following code would attach the onEvent function to receive all the events from the whole runtime:  void onEvent(MicroBitEvent e)\n{\n    uBit.display.scroll( SOMETHING HAPPENED! );\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_ANY, MICROBIT_EVT_ANY, onEvent);\n}", 
            "title": "Wildcard Events"
        }, 
        {
            "location": "/concepts/#queued-events", 
            "text": "When you write an event handler, your function will be called each time the relevant event is raised. But what happens if your handler takes a long time to execute?\nFor example, the example above will scroll \"SOMETHING HAPPENED\" whenever any event at all is raised... but scrolling that message will take several seconds to complete! \nWhat is another event happens during this time?  By default, the runtime will queue any events for your event handler until it has finished what its already doing. \nAs soon as your handler is finished processing an event, the next one will be delivered (any other event handlers will be unaffected though - just becuase one event handler\nis busy, doesn't mean that another one can't receive its events!).  The runtime does allow you to change this behaviour if you want to though. See the advanced documentation in  MicroBitMessageBus  for more details.   Note  More advanced programmers might be interested to know that you can also attach event handler to member function of C++ objects. See the other forms of listen function in  MicroBitMessageBus  for more details.", 
            "title": "Queued Events"
        }, 
        {
            "location": "/concepts/#concurrency", 
            "text": "It is not uncommon to want to write programs that can do more than one thing at a time. For example, it takes quite a long time to scroll a message over the LED matrix, so what if you want\nyour program to do something else while this is happening? Programs that do more than one thing at a time are called  concurrent programs . The runtime provides two ways you can \nachieve concurrency in your programs:    Functions that may take a very long time to complete (e.g. display.scroll) often have \"Async\" versions (e.g. display.scrollAsync). These functions\nhave the exact same behaviour as their counterparts, but don't wait for the effect to finish before allowing the user's program to continue. Instead, as soon as the function is called, \nuser's program carries on executing (and can go an do something else while the task is running in the background).    Users can also make use of the runtime fiber scheduler. This lets you run parts of your program in the background, and share the processor on your micro:bit between those parts\nas they need it. In fact, whenever you write an event handler, the runtime will normally execute your handler in the background in this way, so that it reduces the impact on the rest of your program!\nThe scheduler is a type of  non-preemptive scheduler . This means that the runtime will never take control away from your program - it will wait for it to share by making a call to a runtime \nfunction that is  blocking . All the functions that are blocking are listed as such in their documentation.  You can create  fibers  at any time. See the  create_fiber  function for more details.", 
            "title": "Concurrency"
        }, 
        {
            "location": "/getting-started/", 
            "text": "About the micro:bit \n\n\n\n\nThe brain of the micro:bit is a \nNordic nRF51822\n\nand it controls all functionality offered by the micro:bit.\n\n\nOn board the micro:bit there is already:\n\n\n\n\na 5 x 5 LED matrix \ndisplay\n.\n\n\n2 programmable \nbuttons\n.\n\n\nan \naccelerometer\n.\n\n\na \ncompass\n.\n\n\nBluetooth\n.\n\n\n20 user controlled \npins\n.\n\n\nserial\n capabilities.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#about-the-microbit", 
            "text": "The brain of the micro:bit is a  Nordic nRF51822 \nand it controls all functionality offered by the micro:bit.  On board the micro:bit there is already:   a 5 x 5 LED matrix  display .  2 programmable  buttons .  an  accelerometer .  a  compass .  Bluetooth .  20 user controlled  pins .  serial  capabilities.", 
            "title": " About the micro:bit "
        }, 
        {
            "location": "/installing-yotta/", 
            "text": "Building a project for the micro:bit using yotta\n\n\nThe micro:bit DAL is built on top of \nmbed\n and hence uses \nyotta\n as an offline build system.\n\n\nIf you'd like to use the mbed online IDE instead, you can find instructions at \nthe mbed Developer site\n\n\nWhen using \nyotta\n to build micro:bit projects there are currently two supported toolchains:\n\n\n\n\nGCC\n\n\nARMCC\n\n\n\n\nInstall yotta and dependencies\n\n\nThe first step is to get \nyotta\n and its dependencies onto your machine, to do this follow the install guide \nhere\n\n\nFor the micro:bit targets you currently still need the srecord tools, which can be installed on \nUbuntu\n using\n\n\nsudo apt-get install srecord\n\n\n\n\nOn \nMac OS X\n you can use brew (\nbrew install srecord\n), or you can install it manually from \nhere\n if you are on \nWindows\n. srecord is used to create the final binaries for the micro:bit so is an essential dependency.\n\n\nFetch the example project\n\n\ngit clone https://github.com/lancaster-university/microbit\ncd microbit #The following instructions assume you're in the example directory\n\n\n\n\nSet your yotta target\n\n\nA \nyotta\n target contains the information required by \nyotta\n in order to build a project for a specific combination of hardware. This includes the type of compiler. The microbit projects can build with both \narmcc\n and \ngcc\n, but as it gets installed with the \nyotta\n installer, we'll use \ngcc\n by default and choose a micro:bit specific target that knows about the hardware on the board.\n\n\nYou can use either \nyotta\n or \nyt\n, which is far easier to type!\n\n\nyt target bbc-microbit-classic-gcc\n\n\n\n\nThe 'classic' part of this target name referes to the fact that the micro:bit uses \"mbed Classic\" (see https://developer.mbed.org/) which is the version of mbed before mbed OS. It is also possible to use mbed OS on the micro:bit (see \nhere\n) but the DAL has not yet been ported to use mbed OS.\n\n\nYou only need to set the target once per project. All future \nyotta\n commands will use this target information (for example, when resolving dependencies).\n\n\nBuild the project\n\n\nyt build\n\n\n\n\nFlash your micro:bit\n\n\nThe final step is to check your hex works.\n\n\nThe \nyotta build\n command will place files in \n/build/\nTARGET_NAME\n/source\n. The file you will need to flash will be microbit-combined.hex. Simply drag and drop the hex.\n\n\nIn the case of our example, using \nbbc-microbit-classic-gcc\n we could flash the micro:bit (assuming it is plugged in and mounted at \n/media/MICROBIT\n) as follows:\n\n\ncp ./build/bbc-microbit-classic-gcc/source/microbit-combined.hex /media/MICROBIT\n\n\n\n\nThe expected result will be that the micro:bit will scroll \nBELLO! :)\n on its display.\n\n\n\n\nNote\n\n\nNote that if you'd like to copy the file from the command line, you can use the following command in any \nyotta\n project to do so, though it assumes you have only one micro:bit plugged in:\n\n\ncp build/$(yt --plain target | head -n 1 | cut -f 1 -d' ')/source/$(yt --plain ls | head -n 1 | cut -f 1 -d' ')-combined.hex /media/MICROBIT/", 
            "title": "Online Development"
        }, 
        {
            "location": "/installing-yotta/#building-a-project-for-the-microbit-using-yotta", 
            "text": "The micro:bit DAL is built on top of  mbed  and hence uses  yotta  as an offline build system.  If you'd like to use the mbed online IDE instead, you can find instructions at  the mbed Developer site  When using  yotta  to build micro:bit projects there are currently two supported toolchains:   GCC  ARMCC", 
            "title": "Building a project for the micro:bit using yotta"
        }, 
        {
            "location": "/installing-yotta/#install-yotta-and-dependencies", 
            "text": "The first step is to get  yotta  and its dependencies onto your machine, to do this follow the install guide  here  For the micro:bit targets you currently still need the srecord tools, which can be installed on  Ubuntu  using  sudo apt-get install srecord  On  Mac OS X  you can use brew ( brew install srecord ), or you can install it manually from  here  if you are on  Windows . srecord is used to create the final binaries for the micro:bit so is an essential dependency.", 
            "title": "Install yotta and dependencies"
        }, 
        {
            "location": "/installing-yotta/#fetch-the-example-project", 
            "text": "git clone https://github.com/lancaster-university/microbit\ncd microbit #The following instructions assume you're in the example directory", 
            "title": "Fetch the example project"
        }, 
        {
            "location": "/installing-yotta/#set-your-yotta-target", 
            "text": "A  yotta  target contains the information required by  yotta  in order to build a project for a specific combination of hardware. This includes the type of compiler. The microbit projects can build with both  armcc  and  gcc , but as it gets installed with the  yotta  installer, we'll use  gcc  by default and choose a micro:bit specific target that knows about the hardware on the board.  You can use either  yotta  or  yt , which is far easier to type!  yt target bbc-microbit-classic-gcc  The 'classic' part of this target name referes to the fact that the micro:bit uses \"mbed Classic\" (see https://developer.mbed.org/) which is the version of mbed before mbed OS. It is also possible to use mbed OS on the micro:bit (see  here ) but the DAL has not yet been ported to use mbed OS.  You only need to set the target once per project. All future  yotta  commands will use this target information (for example, when resolving dependencies).", 
            "title": "Set your yotta target"
        }, 
        {
            "location": "/installing-yotta/#build-the-project", 
            "text": "yt build", 
            "title": "Build the project"
        }, 
        {
            "location": "/installing-yotta/#flash-your-microbit", 
            "text": "The final step is to check your hex works.  The  yotta build  command will place files in  /build/ TARGET_NAME /source . The file you will need to flash will be microbit-combined.hex. Simply drag and drop the hex.  In the case of our example, using  bbc-microbit-classic-gcc  we could flash the micro:bit (assuming it is plugged in and mounted at  /media/MICROBIT ) as follows:  cp ./build/bbc-microbit-classic-gcc/source/microbit-combined.hex /media/MICROBIT  The expected result will be that the micro:bit will scroll  BELLO! :)  on its display.   Note  Note that if you'd like to copy the file from the command line, you can use the following command in any  yotta  project to do so, though it assumes you have only one micro:bit plugged in:  cp build/$(yt --plain target | head -n 1 | cut -f 1 -d' ')/source/$(yt --plain ls | head -n 1 | cut -f 1 -d' ')-combined.hex /media/MICROBIT/", 
            "title": "Flash your micro:bit"
        }, 
        {
            "location": "/installing-yotta/", 
            "text": "Building a project for the micro:bit using yotta\n\n\nThe micro:bit DAL is built on top of \nmbed\n and hence uses \nyotta\n as an offline build system.\n\n\nIf you'd like to use the mbed online IDE instead, you can find instructions at \nthe mbed Developer site\n\n\nWhen using \nyotta\n to build micro:bit projects there are currently two supported toolchains:\n\n\n\n\nGCC\n\n\nARMCC\n\n\n\n\nInstall yotta and dependencies\n\n\nThe first step is to get \nyotta\n and its dependencies onto your machine, to do this follow the install guide \nhere\n\n\nFor the micro:bit targets you currently still need the srecord tools, which can be installed on \nUbuntu\n using\n\n\nsudo apt-get install srecord\n\n\n\n\nOn \nMac OS X\n you can use brew (\nbrew install srecord\n), or you can install it manually from \nhere\n if you are on \nWindows\n. srecord is used to create the final binaries for the micro:bit so is an essential dependency.\n\n\nFetch the example project\n\n\ngit clone https://github.com/lancaster-university/microbit\ncd microbit #The following instructions assume you're in the example directory\n\n\n\n\nSet your yotta target\n\n\nA \nyotta\n target contains the information required by \nyotta\n in order to build a project for a specific combination of hardware. This includes the type of compiler. The microbit projects can build with both \narmcc\n and \ngcc\n, but as it gets installed with the \nyotta\n installer, we'll use \ngcc\n by default and choose a micro:bit specific target that knows about the hardware on the board.\n\n\nYou can use either \nyotta\n or \nyt\n, which is far easier to type!\n\n\nyt target bbc-microbit-classic-gcc\n\n\n\n\nThe 'classic' part of this target name referes to the fact that the micro:bit uses \"mbed Classic\" (see https://developer.mbed.org/) which is the version of mbed before mbed OS. It is also possible to use mbed OS on the micro:bit (see \nhere\n) but the DAL has not yet been ported to use mbed OS.\n\n\nYou only need to set the target once per project. All future \nyotta\n commands will use this target information (for example, when resolving dependencies).\n\n\nBuild the project\n\n\nyt build\n\n\n\n\nFlash your micro:bit\n\n\nThe final step is to check your hex works.\n\n\nThe \nyotta build\n command will place files in \n/build/\nTARGET_NAME\n/source\n. The file you will need to flash will be microbit-combined.hex. Simply drag and drop the hex.\n\n\nIn the case of our example, using \nbbc-microbit-classic-gcc\n we could flash the micro:bit (assuming it is plugged in and mounted at \n/media/MICROBIT\n) as follows:\n\n\ncp ./build/bbc-microbit-classic-gcc/source/microbit-combined.hex /media/MICROBIT\n\n\n\n\nThe expected result will be that the micro:bit will scroll \nBELLO! :)\n on its display.\n\n\n\n\nNote\n\n\nNote that if you'd like to copy the file from the command line, you can use the following command in any \nyotta\n project to do so, though it assumes you have only one micro:bit plugged in:\n\n\ncp build/$(yt --plain target | head -n 1 | cut -f 1 -d' ')/source/$(yt --plain ls | head -n 1 | cut -f 1 -d' ')-combined.hex /media/MICROBIT/", 
            "title": "Offline Development"
        }, 
        {
            "location": "/installing-yotta/#building-a-project-for-the-microbit-using-yotta", 
            "text": "The micro:bit DAL is built on top of  mbed  and hence uses  yotta  as an offline build system.  If you'd like to use the mbed online IDE instead, you can find instructions at  the mbed Developer site  When using  yotta  to build micro:bit projects there are currently two supported toolchains:   GCC  ARMCC", 
            "title": "Building a project for the micro:bit using yotta"
        }, 
        {
            "location": "/installing-yotta/#install-yotta-and-dependencies", 
            "text": "The first step is to get  yotta  and its dependencies onto your machine, to do this follow the install guide  here  For the micro:bit targets you currently still need the srecord tools, which can be installed on  Ubuntu  using  sudo apt-get install srecord  On  Mac OS X  you can use brew ( brew install srecord ), or you can install it manually from  here  if you are on  Windows . srecord is used to create the final binaries for the micro:bit so is an essential dependency.", 
            "title": "Install yotta and dependencies"
        }, 
        {
            "location": "/installing-yotta/#fetch-the-example-project", 
            "text": "git clone https://github.com/lancaster-university/microbit\ncd microbit #The following instructions assume you're in the example directory", 
            "title": "Fetch the example project"
        }, 
        {
            "location": "/installing-yotta/#set-your-yotta-target", 
            "text": "A  yotta  target contains the information required by  yotta  in order to build a project for a specific combination of hardware. This includes the type of compiler. The microbit projects can build with both  armcc  and  gcc , but as it gets installed with the  yotta  installer, we'll use  gcc  by default and choose a micro:bit specific target that knows about the hardware on the board.  You can use either  yotta  or  yt , which is far easier to type!  yt target bbc-microbit-classic-gcc  The 'classic' part of this target name referes to the fact that the micro:bit uses \"mbed Classic\" (see https://developer.mbed.org/) which is the version of mbed before mbed OS. It is also possible to use mbed OS on the micro:bit (see  here ) but the DAL has not yet been ported to use mbed OS.  You only need to set the target once per project. All future  yotta  commands will use this target information (for example, when resolving dependencies).", 
            "title": "Set your yotta target"
        }, 
        {
            "location": "/installing-yotta/#build-the-project", 
            "text": "yt build", 
            "title": "Build the project"
        }, 
        {
            "location": "/installing-yotta/#flash-your-microbit", 
            "text": "The final step is to check your hex works.  The  yotta build  command will place files in  /build/ TARGET_NAME /source . The file you will need to flash will be microbit-combined.hex. Simply drag and drop the hex.  In the case of our example, using  bbc-microbit-classic-gcc  we could flash the micro:bit (assuming it is plugged in and mounted at  /media/MICROBIT ) as follows:  cp ./build/bbc-microbit-classic-gcc/source/microbit-combined.hex /media/MICROBIT  The expected result will be that the micro:bit will scroll  BELLO! :)  on its display.   Note  Note that if you'd like to copy the file from the command line, you can use the following command in any  yotta  project to do so, though it assumes you have only one micro:bit plugged in:  cp build/$(yt --plain target | head -n 1 | cut -f 1 -d' ')/source/$(yt --plain ls | head -n 1 | cut -f 1 -d' ')-combined.hex /media/MICROBIT/", 
            "title": "Flash your micro:bit"
        }, 
        {
            "location": "/device/", 
            "text": "About the micro:bit \n\n\n\n\nThe brain of the micro:bit is a \nNordic nRF51822\n\nand it controls all functionality offered by the micro:bit.\n\n\nOn board the micro:bit there is already:\n\n\n\n\na 5 x 5 LED matrix \ndisplay\n.\n\n\n2 programmable \nbuttons\n.\n\n\nan \naccelerometer\n.\n\n\na \ncompass\n.\n\n\nBluetooth\n.\n\n\n20 user controlled \npins\n.\n\n\nserial\n capabilities.", 
            "title": "The Device"
        }, 
        {
            "location": "/device/#about-the-microbit", 
            "text": "The brain of the micro:bit is a  Nordic nRF51822 \nand it controls all functionality offered by the micro:bit.  On board the micro:bit there is already:   a 5 x 5 LED matrix  display .  2 programmable  buttons .  an  accelerometer .  a  compass .  Bluetooth .  20 user controlled  pins .  serial  capabilities.", 
            "title": " About the micro:bit "
        }, 
        {
            "location": "/ubit/", 
            "text": "uBit\n\n\nOverview\n\n\nAlthough the runtime is built from lots of small components, we also provide an easy to use pre-packaged collection of the commonly used components \nall in one place. This makes it much easier to start programming your micro:bit in C. This grouping is provided by a C++ class called MicroBit.  The MicroBit class has a number of \nmember variables, that operate as device drivers to control the most commonly used features of the micro:bit.\n\n\nThere is an instance of the MicroBit class created as a global variable in all the sample programs, and it contains:\n\n\n\n\nuBit {\n\n   \n.i2c\n,\n\n   \n.serial\n,\n\n   \n.MessageBus\n,\n\n   \n.buttonA\n,\n\n   \n.buttonB\n,\n\n   \n.buttonAB\n,\n\n   \n.display\n,\n\n   \n.accelerometer\n,\n\n   \n.compass\n,\n\n   \n.thermometer\n,\n\n   \n.io\n,\n\n   \n.ble\n,\n\n   \n.BLEManager\n,\n\n   \n.radio\n,\n\n   }\n\n\n\n\nYou can use dot operator '.' to any of these resources inside uBit, then again to access any of the functions they provide. There is a complete list of the\nfunctions available under the \nuBit\n menu item above.\n\n\nFor example, if we needed to scroll some text across the display, we simply would write the following:\n\n\nuBit.display.scroll(\nHELLO!\n);\n\n\n\n\nSimilarly, if we wanted to send some text over serial, we could write the following\ncode:\n\n\nfor(int i = 3; i \n 0; i--)\n{\n    uBit.serial.printf(\n%d...\n, i);\n    uBit.sleep(1000);\n}\n\n// or alternatively...\nuBit.serial.sendString(\nCode!\n);\n\n\n\n\nuBit also provides a number of utility functions that allow the plug and play\nof additional components that developers may create. These are namely \naddSystemComponent()\n\nand \naddIdleComponent()\n. \nRead more about how to plug your own device drivers into the runtime.\n\n\nThe runtime also contains a scheduler, which uses lightweight threads (called fibers)\nto control the rate of execution.\n\n\nTo place the current fiber into a power efficient \nsleep\n write the following:\n\n\n// where X is an integer in milliseconds for the amount of time you would like to sleep for.\nuBit.sleep(X);\n\n\n\n\nRead more about the scheduler.\n\n\nMessage Bus ID\n\n\n\n\nNone\n\n\n\n\nMessage Bus Events\n\n\n\n\nNone\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBit()\n\n\nDescription\n\n\nConstructor. Create a representation of a  MicroBit MicroBitMessageBus\n\n\nExample\n\n\n uBit.messageBus; //The message bus where events are fired. \n uBit.display; //The display object for the LED matrix. \n uBit.buttonA; //The buttonA object for button a. \n uBit.buttonB; //The buttonB object for button b. \n uBit.resetButton; //The resetButton used for soft resets. \n uBit.accelerometer; //The object that represents the inbuilt accelerometer \n uBit.compass; //The object that represents the inbuilt compass(magnetometer) \n uBit.io.P*; //Where P* is P0 to P16, P19 \n P20 on the edge connector \n\n\n\n\ninit\n\n\n\n\nvoid\n init()\n\n\nDescription\n\n\nPost constructor initialisation method. After \n\n\nExample\n\n\n uBit.init(); \n\n\n\n\nreset\n\n\n\n\nvoid\n reset()\n\n\nDescription\n\n\nWill reset the micro:bit when called.\n\n\nExample\n\n\n uBit.reset(); \n\n\n\n\nsleep\n\n\n\n\nvoid\n sleep( \nuint32_t\n milliseconds)\n\n\nDescription\n\n\nDelay for the given amount of time. If the scheduler is running, this will deschedule the current fiber and perform a power efficent, concurrent sleep operation. If the scheduler is disabled or we're running in an interrupt context, this will revert to a busy wait.\n\n\nParameters\n\n\n\n\nuint32_t\n \nmilliseconds\n - the amount of time, in ms, to wait for. This number cannot be negative. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER milliseconds is less than zero.\n\n\nExample\n\n\n MicroBit::sleep(20); //sleep for 20ms \n\n\n\n\n\n\nNote\n\n\nValues of 6 and below tend to lose resolution - do you really need to sleep for this short amount of time?\n\n\n\n\nseedRandom\n\n\n\n\nvoid\n seedRandom()\n\n\nDescription\n\n\nSeed the pseudo random number generator using the hardware generator.\n\n\nExample\n\n\n uBit.seedRandom(); \n\n\n\n\n\n\nvoid\n seedRandom( \nuint32_t\n seed)\n\n\nDescription\n\n\nSeed the pseudo random number generator using the given value.\n\n\nParameters\n\n\n\n\nuint32_t\n \nseed\n - The 32-bit value to seed the generator with.\n\n\n\n\nExample\n\n\n uBit.seedRandom(0x12345678); \n\n\n\n\nrandom\n\n\n\n\nint\n random( \nint\n max)\n\n\nDescription\n\n\nGenerate a random number in the given range. We use the NRF51822 in built random number generator here TODO: Determine if we want to, given its relatively high power consumption!\n\n\nParameters\n\n\n\n\nint\n \nmax\n - the upper range to generate a number for. This number cannot be negative \n\n\n\n\nReturns\n\n\nA random, natural number between 0 and the max-1. Or MICROBIT_INVALID_PARAMETER if max is \n= 0.\n\n\nExample\n\n\n uBit.random(200); //a number between 0 and 199 \n\n\n\n\nsystemTime\n\n\n\n\nunsigned long\n systemTime()\n\n\nDescription\n\n\nDetermine the time since this  MicroBit\n\n\nReturns\n\n\nThe time since the last reset, in milliseconds. This will result in overflow after 1.6 months. TODO: handle overflow case. \n\n\nsystemVersion\n\n\n\n\nconst char *\n systemVersion()\n\n\nDescription\n\n\nDetermine the version of the micro:bit runtime currently in use.\n\n\nReturns\n\n\nA textual description of the currentlt executing micro:bit runtime. TODO: handle overflow case. \n\n\npanic\n\n\n\n\nvoid\n panic()\n\n\nDescription\n\n\nTriggers a microbit panic where an infinite loop will occur swapping between the panicFace and statusCode if provided.\n\n\n\nvoid\n panic( \nint\n statusCode)\n\n\nDescription\n\n\nTriggers a microbit panic where an infinite loop will occur swapping between the panicFace and statusCode if provided.\n\n\nParameters\n\n\n\n\nint\n \nstatusCode\n - the status code of the associated error. Status codes must be in the range 0-255.\n\n\n\n\naddSystemComponent\n\n\n\n\nint\n addSystemComponent( \nMicroBitComponent  *\n component)\n\n\nDescription\n\n\nadd a component to the array of components which invocate the systemTick member function during a systemTick \n\n\nParameters\n\n\n\n\nMicroBitComponent  \n \ncomponent* - The component to add. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success. MICROBIT_NO_RESOURCES is returned if further components cannot be supported. \n\n\n\n\nNote\n\n\nThis interface is now deprecated. See fiber_add_system_component().\n\n\n\n\nremoveSystemComponent\n\n\n\n\nint\n removeSystemComponent( \nMicroBitComponent  *\n component)\n\n\nDescription\n\n\nremove a component from the array of components \n\n\nParameters\n\n\n\n\nMicroBitComponent  \n \ncomponent* - The component to remove. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success. MICROBIT_INVALID_PARAMTER is returned if the given component has not been previous added. \n\n\n\n\nNote\n\n\nThis interface is now deprecated. See fiber_remove_system_component().\n\n\n\n\naddIdleComponent\n\n\n\n\nint\n addIdleComponent( \nMicroBitComponent  *\n component)\n\n\nDescription\n\n\nadd a component to the array of components which invocate the systemTick member function during a systemTick  fiber_add_idle_component()\n\n\nParameters\n\n\n\n\nMicroBitComponent  \n \ncomponent* - The component to add. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success. MICROBIT_NO_RESOURCES is returned if further components cannot be supported. \n\n\n\n\nNote\n\n\nThis interface is now deprecated. See  fiber_add_idle_component() .\n\n\n\n\nremoveIdleComponent\n\n\n\n\nint\n removeIdleComponent( \nMicroBitComponent  *\n component)\n\n\nDescription\n\n\nremove a component from the array of components  fiber_remove_idle_component()\n\n\nParameters\n\n\n\n\nMicroBitComponent  \n \ncomponent* - The component to remove. \n\n\n\n\nReturns\n\n\nMICROBIT_OK on success. MICROBIT_INVALID_PARAMTER is returned if the given component has not been previous added. \n\n\n\n\nNote\n\n\nThis interface is now deprecated. See  fiber_remove_idle_component() .", 
            "title": "uBit"
        }, 
        {
            "location": "/ubit/#ubit", 
            "text": "", 
            "title": "uBit"
        }, 
        {
            "location": "/ubit/#overview", 
            "text": "Although the runtime is built from lots of small components, we also provide an easy to use pre-packaged collection of the commonly used components \nall in one place. This makes it much easier to start programming your micro:bit in C. This grouping is provided by a C++ class called MicroBit.  The MicroBit class has a number of \nmember variables, that operate as device drivers to control the most commonly used features of the micro:bit.  There is an instance of the MicroBit class created as a global variable in all the sample programs, and it contains:   uBit { \n    .i2c , \n    .serial , \n    .MessageBus , \n    .buttonA , \n    .buttonB , \n    .buttonAB , \n    .display , \n    .accelerometer , \n    .compass , \n    .thermometer , \n    .io , \n    .ble , \n    .BLEManager , \n    .radio , \n   }   You can use dot operator '.' to any of these resources inside uBit, then again to access any of the functions they provide. There is a complete list of the\nfunctions available under the  uBit  menu item above.  For example, if we needed to scroll some text across the display, we simply would write the following:  uBit.display.scroll( HELLO! );  Similarly, if we wanted to send some text over serial, we could write the following\ncode:  for(int i = 3; i   0; i--)\n{\n    uBit.serial.printf( %d... , i);\n    uBit.sleep(1000);\n}\n\n// or alternatively...\nuBit.serial.sendString( Code! );  uBit also provides a number of utility functions that allow the plug and play\nof additional components that developers may create. These are namely  addSystemComponent() \nand  addIdleComponent() .  Read more about how to plug your own device drivers into the runtime.  The runtime also contains a scheduler, which uses lightweight threads (called fibers)\nto control the rate of execution.  To place the current fiber into a power efficient  sleep  write the following:  // where X is an integer in milliseconds for the amount of time you would like to sleep for.\nuBit.sleep(X);  Read more about the scheduler.", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/#message-bus-id", 
            "text": "None", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/#message-bus-events", 
            "text": "None", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/#microbit", 
            "text": "", 
            "title": "MicroBit()"
        }, 
        {
            "location": "/ubit/#description", 
            "text": "Constructor. Create a representation of a  MicroBit MicroBitMessageBus", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#example", 
            "text": "uBit.messageBus; //The message bus where events are fired. \n uBit.display; //The display object for the LED matrix. \n uBit.buttonA; //The buttonA object for button a. \n uBit.buttonB; //The buttonB object for button b. \n uBit.resetButton; //The resetButton used for soft resets. \n uBit.accelerometer; //The object that represents the inbuilt accelerometer \n uBit.compass; //The object that represents the inbuilt compass(magnetometer) \n uBit.io.P*; //Where P* is P0 to P16, P19   P20 on the edge connector", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#init", 
            "text": "", 
            "title": "init"
        }, 
        {
            "location": "/ubit/#void-init", 
            "text": "", 
            "title": "void init()"
        }, 
        {
            "location": "/ubit/#description_1", 
            "text": "Post constructor initialisation method. After", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#example_1", 
            "text": "uBit.init();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#reset", 
            "text": "", 
            "title": "reset"
        }, 
        {
            "location": "/ubit/#void-reset", 
            "text": "", 
            "title": "void reset()"
        }, 
        {
            "location": "/ubit/#description_2", 
            "text": "Will reset the micro:bit when called.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#example_2", 
            "text": "uBit.reset();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#sleep", 
            "text": "", 
            "title": "sleep"
        }, 
        {
            "location": "/ubit/#void-sleep-uint32_t-milliseconds", 
            "text": "", 
            "title": "void sleep( uint32_t milliseconds)"
        }, 
        {
            "location": "/ubit/#description_3", 
            "text": "Delay for the given amount of time. If the scheduler is running, this will deschedule the current fiber and perform a power efficent, concurrent sleep operation. If the scheduler is disabled or we're running in an interrupt context, this will revert to a busy wait.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters", 
            "text": "uint32_t   milliseconds  - the amount of time, in ms, to wait for. This number cannot be negative.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#returns", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER milliseconds is less than zero.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#example_3", 
            "text": "MicroBit::sleep(20); //sleep for 20ms    Note  Values of 6 and below tend to lose resolution - do you really need to sleep for this short amount of time?", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#seedrandom", 
            "text": "", 
            "title": "seedRandom"
        }, 
        {
            "location": "/ubit/#void-seedrandom", 
            "text": "", 
            "title": "void seedRandom()"
        }, 
        {
            "location": "/ubit/#description_4", 
            "text": "Seed the pseudo random number generator using the hardware generator.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#example_4", 
            "text": "uBit.seedRandom();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#void-seedrandom-uint32_t-seed", 
            "text": "", 
            "title": "void seedRandom( uint32_t seed)"
        }, 
        {
            "location": "/ubit/#description_5", 
            "text": "Seed the pseudo random number generator using the given value.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_1", 
            "text": "uint32_t   seed  - The 32-bit value to seed the generator with.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#example_5", 
            "text": "uBit.seedRandom(0x12345678);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#random", 
            "text": "", 
            "title": "random"
        }, 
        {
            "location": "/ubit/#int-random-int-max", 
            "text": "", 
            "title": "int random( int max)"
        }, 
        {
            "location": "/ubit/#description_6", 
            "text": "Generate a random number in the given range. We use the NRF51822 in built random number generator here TODO: Determine if we want to, given its relatively high power consumption!", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_2", 
            "text": "int   max  - the upper range to generate a number for. This number cannot be negative", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#returns_1", 
            "text": "A random, natural number between 0 and the max-1. Or MICROBIT_INVALID_PARAMETER if max is  = 0.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#example_6", 
            "text": "uBit.random(200); //a number between 0 and 199", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/#systemtime", 
            "text": "", 
            "title": "systemTime"
        }, 
        {
            "location": "/ubit/#unsigned-long-systemtime", 
            "text": "", 
            "title": "unsigned long systemTime()"
        }, 
        {
            "location": "/ubit/#description_7", 
            "text": "Determine the time since this  MicroBit", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#returns_2", 
            "text": "The time since the last reset, in milliseconds. This will result in overflow after 1.6 months. TODO: handle overflow case.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#systemversion", 
            "text": "", 
            "title": "systemVersion"
        }, 
        {
            "location": "/ubit/#const-char-systemversion", 
            "text": "", 
            "title": "const char * systemVersion()"
        }, 
        {
            "location": "/ubit/#description_8", 
            "text": "Determine the version of the micro:bit runtime currently in use.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#returns_3", 
            "text": "A textual description of the currentlt executing micro:bit runtime. TODO: handle overflow case.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#panic", 
            "text": "", 
            "title": "panic"
        }, 
        {
            "location": "/ubit/#void-panic", 
            "text": "", 
            "title": "void panic()"
        }, 
        {
            "location": "/ubit/#description_9", 
            "text": "Triggers a microbit panic where an infinite loop will occur swapping between the panicFace and statusCode if provided.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#void-panic-int-statuscode", 
            "text": "", 
            "title": "void panic( int statusCode)"
        }, 
        {
            "location": "/ubit/#description_10", 
            "text": "Triggers a microbit panic where an infinite loop will occur swapping between the panicFace and statusCode if provided.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_3", 
            "text": "int   statusCode  - the status code of the associated error. Status codes must be in the range 0-255.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#addsystemcomponent", 
            "text": "", 
            "title": "addSystemComponent"
        }, 
        {
            "location": "/ubit/#int-addsystemcomponent-microbitcomponent-component", 
            "text": "", 
            "title": "int addSystemComponent( MicroBitComponent  * component)"
        }, 
        {
            "location": "/ubit/#description_11", 
            "text": "add a component to the array of components which invocate the systemTick member function during a systemTick", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_4", 
            "text": "MicroBitComponent     component* - The component to add.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#returns_4", 
            "text": "MICROBIT_OK on success. MICROBIT_NO_RESOURCES is returned if further components cannot be supported.    Note  This interface is now deprecated. See fiber_add_system_component().", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#removesystemcomponent", 
            "text": "", 
            "title": "removeSystemComponent"
        }, 
        {
            "location": "/ubit/#int-removesystemcomponent-microbitcomponent-component", 
            "text": "", 
            "title": "int removeSystemComponent( MicroBitComponent  * component)"
        }, 
        {
            "location": "/ubit/#description_12", 
            "text": "remove a component from the array of components", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_5", 
            "text": "MicroBitComponent     component* - The component to remove.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#returns_5", 
            "text": "MICROBIT_OK on success. MICROBIT_INVALID_PARAMTER is returned if the given component has not been previous added.    Note  This interface is now deprecated. See fiber_remove_system_component().", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#addidlecomponent", 
            "text": "", 
            "title": "addIdleComponent"
        }, 
        {
            "location": "/ubit/#int-addidlecomponent-microbitcomponent-component", 
            "text": "", 
            "title": "int addIdleComponent( MicroBitComponent  * component)"
        }, 
        {
            "location": "/ubit/#description_13", 
            "text": "add a component to the array of components which invocate the systemTick member function during a systemTick  fiber_add_idle_component()", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_6", 
            "text": "MicroBitComponent     component* - The component to add.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#returns_6", 
            "text": "MICROBIT_OK on success. MICROBIT_NO_RESOURCES is returned if further components cannot be supported.    Note  This interface is now deprecated. See  fiber_add_idle_component() .", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/#removeidlecomponent", 
            "text": "", 
            "title": "removeIdleComponent"
        }, 
        {
            "location": "/ubit/#int-removeidlecomponent-microbitcomponent-component", 
            "text": "", 
            "title": "int removeIdleComponent( MicroBitComponent  * component)"
        }, 
        {
            "location": "/ubit/#description_14", 
            "text": "remove a component from the array of components  fiber_remove_idle_component()", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/#parameters_7", 
            "text": "MicroBitComponent     component* - The component to remove.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/#returns_7", 
            "text": "MICROBIT_OK on success. MICROBIT_INVALID_PARAMTER is returned if the given component has not been previous added.    Note  This interface is now deprecated. See  fiber_remove_idle_component() .", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/i2c/", 
            "text": "uBit.i2c\n\n\nOverview\n\n\ni2c is a very common, widely used protocol for communicating with other devices\nover a wire. i2c uses a very simple addressing scheme to access these other\ndevices.\n\n\nOnboard the micro:bit itself there are two components which use i2c bus as a communication\nmechanism, the \naccelerometer\n and the \ncompass\n.\n\n\nAs well as being used internally, the i2c bus is exposed on two edge connector\npins, P19 and P20. This means other accessories that use i2c to communicate\ncan be used in conjunction with the micro:bit.\n\n\nMessage Bus ID\n\n\n\n\nNone.\n\n\n\n\nMessage Bus Events\n\n\n\n\nNone.\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitI2C( \nPinName\n sda,  \nPinName\n scl)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nPinName\n \nsda\n - the Pin to be used for SDA\n\n\nPinName\n \nscl\n - the Pin to be used for SCL\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n\n\n\n\n\nNote\n\n\nThis class presents a wrapped mbed call to capture failed I2C operations caused by a known silicon bug in the nrf51822. Attempts to automatically reset and restart the I2C hardware if this case is detected.\n\n\n\n\nread\n\n\n\n\nint\n read( \nint\n address,  \nchar *\n data,  \nint\n length)\n\n\nDescription\n\n\nPerforms a complete read transaction. The bottom bit of the address is forced to 1 to indicate a read.\n\n\nParameters\n\n\n\n\nint\n \naddress\n - 8-bit I2C slave address [ addr | 1 ]\n\n\nchar \n \ndata* - A pointer to a byte buffer used for storing retrieved data.\n\n\nint\n \nlength\n - Number of bytes to read.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved read failure is detected. \n\n\n\nint\n read( \nint\n address,  \nchar *\n data,  \nint\n length,  \nbool\n repeated)\n\n\nDescription\n\n\nPerforms a complete read transaction. The bottom bit of the address is forced to 1 to indicate a read.\n\n\nParameters\n\n\n\n\nint\n \naddress\n - 8-bit I2C slave address [ addr | 1 ]\n\n\nchar \n \ndata* - A pointer to a byte buffer used for storing retrieved data.\n\n\nint\n \nlength\n - Number of bytes to read.\n\n\nbool\n \nrepeated\n - if true, stop is not sent at the end. Defaults to false.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved read failure is detected. \n\n\nwrite\n\n\n\n\nint\n write( \nint\n address,  \nconst char *\n data,  \nint\n length)\n\n\nDescription\n\n\nPerforms a complete write transaction. The bottom bit of the address is forced to 0 to indicate a write.\n\n\nParameters\n\n\n\n\nint\n \naddress\n - 8-bit I2C slave address [ addr | 0 ]\n\n\nconst char \n \ndata* - A pointer to a byte buffer containing the data to write.\n\n\nint\n \nlength\n - Number of bytes to write\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved write failure is detected. \n\n\n\nint\n write( \nint\n address,  \nconst char *\n data,  \nint\n length,  \nbool\n repeated)\n\n\nDescription\n\n\nPerforms a complete write transaction. The bottom bit of the address is forced to 0 to indicate a write.\n\n\nParameters\n\n\n\n\nint\n \naddress\n - 8-bit I2C slave address [ addr | 0 ]\n\n\nconst char \n \ndata* - A pointer to a byte buffer containing the data to write.\n\n\nint\n \nlength\n - Number of bytes to write\n\n\nbool\n \nrepeated\n - if true, stop is not sent at the end. Defaults to false.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved write failure is detected.", 
            "title": "i2c"
        }, 
        {
            "location": "/ubit/i2c/#ubiti2c", 
            "text": "", 
            "title": "uBit.i2c"
        }, 
        {
            "location": "/ubit/i2c/#overview", 
            "text": "i2c is a very common, widely used protocol for communicating with other devices\nover a wire. i2c uses a very simple addressing scheme to access these other\ndevices.  Onboard the micro:bit itself there are two components which use i2c bus as a communication\nmechanism, the  accelerometer  and the  compass .  As well as being used internally, the i2c bus is exposed on two edge connector\npins, P19 and P20. This means other accessories that use i2c to communicate\ncan be used in conjunction with the micro:bit.", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/i2c/#message-bus-id", 
            "text": "None.", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/i2c/#message-bus-events", 
            "text": "None.", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/i2c/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/i2c/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/i2c/#microbiti2c-pinname-sda-pinname-scl", 
            "text": "", 
            "title": "MicroBitI2C( PinName sda,  PinName scl)"
        }, 
        {
            "location": "/ubit/i2c/#description", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/i2c/#parameters", 
            "text": "PinName   sda  - the Pin to be used for SDA  PinName   scl  - the Pin to be used for SCL", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/i2c/#example", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0);    Note  This class presents a wrapped mbed call to capture failed I2C operations caused by a known silicon bug in the nrf51822. Attempts to automatically reset and restart the I2C hardware if this case is detected.", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/i2c/#read", 
            "text": "", 
            "title": "read"
        }, 
        {
            "location": "/ubit/i2c/#int-read-int-address-char-data-int-length", 
            "text": "", 
            "title": "int read( int address,  char * data,  int length)"
        }, 
        {
            "location": "/ubit/i2c/#description_1", 
            "text": "Performs a complete read transaction. The bottom bit of the address is forced to 1 to indicate a read.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/i2c/#parameters_1", 
            "text": "int   address  - 8-bit I2C slave address [ addr | 1 ]  char    data* - A pointer to a byte buffer used for storing retrieved data.  int   length  - Number of bytes to read.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/i2c/#returns", 
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved read failure is detected.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/i2c/#int-read-int-address-char-data-int-length-bool-repeated", 
            "text": "", 
            "title": "int read( int address,  char * data,  int length,  bool repeated)"
        }, 
        {
            "location": "/ubit/i2c/#description_2", 
            "text": "Performs a complete read transaction. The bottom bit of the address is forced to 1 to indicate a read.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/i2c/#parameters_2", 
            "text": "int   address  - 8-bit I2C slave address [ addr | 1 ]  char    data* - A pointer to a byte buffer used for storing retrieved data.  int   length  - Number of bytes to read.  bool   repeated  - if true, stop is not sent at the end. Defaults to false.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/i2c/#returns_1", 
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved read failure is detected.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/i2c/#write", 
            "text": "", 
            "title": "write"
        }, 
        {
            "location": "/ubit/i2c/#int-write-int-address-const-char-data-int-length", 
            "text": "", 
            "title": "int write( int address,  const char * data,  int length)"
        }, 
        {
            "location": "/ubit/i2c/#description_3", 
            "text": "Performs a complete write transaction. The bottom bit of the address is forced to 0 to indicate a write.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/i2c/#parameters_3", 
            "text": "int   address  - 8-bit I2C slave address [ addr | 0 ]  const char    data* - A pointer to a byte buffer containing the data to write.  int   length  - Number of bytes to write", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/i2c/#returns_2", 
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved write failure is detected.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/i2c/#int-write-int-address-const-char-data-int-length-bool-repeated", 
            "text": "", 
            "title": "int write( int address,  const char * data,  int length,  bool repeated)"
        }, 
        {
            "location": "/ubit/i2c/#description_4", 
            "text": "Performs a complete write transaction. The bottom bit of the address is forced to 0 to indicate a write.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/i2c/#parameters_4", 
            "text": "int   address  - 8-bit I2C slave address [ addr | 0 ]  const char    data* - A pointer to a byte buffer containing the data to write.  int   length  - Number of bytes to write  bool   repeated  - if true, stop is not sent at the end. Defaults to false.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/i2c/#returns_3", 
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if an unresolved write failure is detected.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/storage/", 
            "text": "uBit.storage\n\n\nOverview\n\n\nMicroBitStorage\n provides a simple way to store data on the micro:bit that persists\nthrough power cycles. It currently takes the form of a key value store which contains\na number of Key Value pairs.\n\n\nThe micro:bit has 256 kB flash memory and 16 kB random access memory (RAM). Flash memory\nis \nnon-volatile\n, which essentially means that data is not forgotten when the device\nis powered off, this is the technology that many USB sticks use.\n\n\nThe alternative, RAM (known as \nvolatile\n memory), cannot be persisted through power cycling the device as its\noperation relies upon maintaining a constant supply of power.\n\n\nTherefore, \nMicroBitStorage\n utilises the \nnon-volatile\n nature of flash memory, to\nstore its data. This class is utilised by the \ncompass\n, \naccelerometer\n\nand \nbleManager\n to improve the user experience by persisting calibration\nand bonding data.\n\n\nOperations\n\n\nYou can \nput()\n, \nget()\n and \nremove()\n key value pairs from the store.\n\n\nKey Value pairs have a fixed length key of \n16 bytes\n, and a fixed length value of\n\n32 bytes\n. This class only populates a single block (\n1024 bytes\n) in its current state,\nwhich means that \n21\n Key Value pairs can be stored.\n\n\nMessage Bus ID\n\n\n\n\nNone.\n\n\n\n\nMessage Bus Events\n\n\n\n\nNone.\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitStorage()\n\n\nDescription\n\n\nDefault constructor.\n\n\nwriteBytes\n\n\n\n\nint\n writeBytes( \nuint8_t *\n buffer,  \nuint32_t\n address,  \nint\n length)\n\n\nDescription\n\n\nWrites the given number of bytes to the address specified.\n\n\nParameters\n\n\n\n\nuint8_t \n \nbuffer* - the data to write.\n\n\nuint32_t\n \naddress\n - the location in memory to write to.\n\n\nint\n \nlength\n - the number of bytes to write.\n\n\n\n\n\n\nNote\n\n\ncurrently not implemented. \n\n\n\n\nflashPageErase\n\n\n\n\nvoid\n flashPageErase( \nuint32_t *\n page_address)\n\n\nDescription\n\n\nMethod for erasing a page in flash.\n\n\nParameters\n\n\n\n\nuint32_t \n \npage_address* - Address of the first word in the page to be erased. \n\n\n\n\nflashWordWrite\n\n\n\n\nvoid\n flashWordWrite( \nuint32_t *\n address,  \nuint32_t\n value)\n\n\nDescription\n\n\nMethod for writing a word of data in flash with a value.\n\n\nParameters\n\n\n\n\nuint32_t \n \naddress* - Address of the word to change.\n\n\nuint32_t\n \nvalue\n - Value to be written to flash. \n\n\n\n\nput\n\n\n\n\nint\n put( \nconst char \n key,  \nuint8_t \n data)\n\n\nDescription\n\n\nPlaces a given key, and it's corresponding value into flash at the earliest available point.\n\n\nParameters\n\n\n\n\nconst char \n \nkey* - the unique name that should be used as an identifier for the given data. The key is presumed to be null terminated.\n\n\nuint8_t \n \ndata* - a pointer to the beginning of the data to be persisted.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NO_RESOURCES if the storage page is full \n\n\n\nint\n put( \nManagedString\n key,  \nuint8_t *\n data)\n\n\nDescription\n\n\nPlaces a given key, and it's corresponding value into flash at the earliest available point.\n\n\nParameters\n\n\n\n\nManagedString\n \nkey\n - the unique name that should be used as an identifier for the given data.\n\n\nuint8_t \n \ndata* - a pointer to the beginning of the data to be persisted.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NO_RESOURCES if the storage page is full \n\n\nget\n\n\n\n\nKeyValuePair\n get( \nconst char *\n key)\n\n\nDescription\n\n\nRetreives a  KeyValuePair\n\n\nParameters\n\n\n\n\nconst char \n \nkey* - the unique name used to identify a  KeyValuePair  in flash.\n\n\n\n\nReturns\n\n\na pointer to a heap allocated  KeyValuePair  struct, this pointer will be NULL if the key was not found in storage.\n\n\n\n\nNote\n\n\nit is up to the user to free memory after use. \n\n\n\n\n\n\nKeyValuePair\n get( \nManagedString\n key)\n\n\nDescription\n\n\nRetreives a  KeyValuePair\n\n\nParameters\n\n\n\n\nManagedString\n \nkey\n - the unique name used to identify a  KeyValuePair  in flash.\n\n\n\n\nReturns\n\n\na pointer to a heap allocated  KeyValuePair  struct, this pointer will be NULL if the key was not found in storage.\n\n\n\n\nNote\n\n\nit is up to the user to free memory after use. \n\n\n\n\nremove\n\n\n\n\nint\n remove( \nconst char *\n key)\n\n\nDescription\n\n\nRemoves a  KeyValuePair\n\n\nParameters\n\n\n\n\nconst char \n \nkey* - the unique name used to identify a  KeyValuePair  in flash.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NO_DATA if the given key was not found in flash. \n\n\n\nint\n remove( \nManagedString\n key)\n\n\nDescription\n\n\nRemoves a  KeyValuePair\n\n\nParameters\n\n\n\n\nManagedString\n \nkey\n - the unique name used to identify a  KeyValuePair  in flash.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NO_DATA if the given key was not found in flash. \n\n\nsize\n\n\n\n\nint\n size()\n\n\nDescription\n\n\nThe size of the flash based  KeyValueStore\n\n\nReturns\n\n\nthe number of entries in the key value store", 
            "title": "storage"
        }, 
        {
            "location": "/ubit/storage/#ubitstorage", 
            "text": "", 
            "title": "uBit.storage"
        }, 
        {
            "location": "/ubit/storage/#overview", 
            "text": "MicroBitStorage  provides a simple way to store data on the micro:bit that persists\nthrough power cycles. It currently takes the form of a key value store which contains\na number of Key Value pairs.  The micro:bit has 256 kB flash memory and 16 kB random access memory (RAM). Flash memory\nis  non-volatile , which essentially means that data is not forgotten when the device\nis powered off, this is the technology that many USB sticks use.  The alternative, RAM (known as  volatile  memory), cannot be persisted through power cycling the device as its\noperation relies upon maintaining a constant supply of power.  Therefore,  MicroBitStorage  utilises the  non-volatile  nature of flash memory, to\nstore its data. This class is utilised by the  compass ,  accelerometer \nand  bleManager  to improve the user experience by persisting calibration\nand bonding data.", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/storage/#operations", 
            "text": "You can  put() ,  get()  and  remove()  key value pairs from the store.  Key Value pairs have a fixed length key of  16 bytes , and a fixed length value of 32 bytes . This class only populates a single block ( 1024 bytes ) in its current state,\nwhich means that  21  Key Value pairs can be stored.", 
            "title": "Operations"
        }, 
        {
            "location": "/ubit/storage/#message-bus-id", 
            "text": "None.", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/storage/#message-bus-events", 
            "text": "None.", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/storage/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/storage/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/storage/#microbitstorage", 
            "text": "", 
            "title": "MicroBitStorage()"
        }, 
        {
            "location": "/ubit/storage/#description", 
            "text": "Default constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/storage/#writebytes", 
            "text": "", 
            "title": "writeBytes"
        }, 
        {
            "location": "/ubit/storage/#int-writebytes-uint8_t-buffer-uint32_t-address-int-length", 
            "text": "", 
            "title": "int writeBytes( uint8_t * buffer,  uint32_t address,  int length)"
        }, 
        {
            "location": "/ubit/storage/#description_1", 
            "text": "Writes the given number of bytes to the address specified.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/storage/#parameters", 
            "text": "uint8_t    buffer* - the data to write.  uint32_t   address  - the location in memory to write to.  int   length  - the number of bytes to write.    Note  currently not implemented.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/storage/#flashpageerase", 
            "text": "", 
            "title": "flashPageErase"
        }, 
        {
            "location": "/ubit/storage/#void-flashpageerase-uint32_t-page_address", 
            "text": "", 
            "title": "void flashPageErase( uint32_t * page_address)"
        }, 
        {
            "location": "/ubit/storage/#description_2", 
            "text": "Method for erasing a page in flash.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/storage/#parameters_1", 
            "text": "uint32_t    page_address* - Address of the first word in the page to be erased.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/storage/#flashwordwrite", 
            "text": "", 
            "title": "flashWordWrite"
        }, 
        {
            "location": "/ubit/storage/#void-flashwordwrite-uint32_t-address-uint32_t-value", 
            "text": "", 
            "title": "void flashWordWrite( uint32_t * address,  uint32_t value)"
        }, 
        {
            "location": "/ubit/storage/#description_3", 
            "text": "Method for writing a word of data in flash with a value.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/storage/#parameters_2", 
            "text": "uint32_t    address* - Address of the word to change.  uint32_t   value  - Value to be written to flash.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/storage/#put", 
            "text": "", 
            "title": "put"
        }, 
        {
            "location": "/ubit/storage/#int-put-const-char-key-uint8_t-data", 
            "text": "", 
            "title": "int put( const char  key,  uint8_t  data)"
        }, 
        {
            "location": "/ubit/storage/#description_4", 
            "text": "Places a given key, and it's corresponding value into flash at the earliest available point.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/storage/#parameters_3", 
            "text": "const char    key* - the unique name that should be used as an identifier for the given data. The key is presumed to be null terminated.  uint8_t    data* - a pointer to the beginning of the data to be persisted.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/storage/#returns", 
            "text": "MICROBIT_OK on success, or MICROBIT_NO_RESOURCES if the storage page is full", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/storage/#int-put-managedstring-key-uint8_t-data", 
            "text": "", 
            "title": "int put( ManagedString key,  uint8_t * data)"
        }, 
        {
            "location": "/ubit/storage/#description_5", 
            "text": "Places a given key, and it's corresponding value into flash at the earliest available point.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/storage/#parameters_4", 
            "text": "ManagedString   key  - the unique name that should be used as an identifier for the given data.  uint8_t    data* - a pointer to the beginning of the data to be persisted.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/storage/#returns_1", 
            "text": "MICROBIT_OK on success, or MICROBIT_NO_RESOURCES if the storage page is full", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/storage/#get", 
            "text": "", 
            "title": "get"
        }, 
        {
            "location": "/ubit/storage/#keyvaluepair-get-const-char-key", 
            "text": "", 
            "title": "KeyValuePair get( const char * key)"
        }, 
        {
            "location": "/ubit/storage/#description_6", 
            "text": "Retreives a  KeyValuePair", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/storage/#parameters_5", 
            "text": "const char    key* - the unique name used to identify a  KeyValuePair  in flash.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/storage/#returns_2", 
            "text": "a pointer to a heap allocated  KeyValuePair  struct, this pointer will be NULL if the key was not found in storage.   Note  it is up to the user to free memory after use.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/storage/#keyvaluepair-get-managedstring-key", 
            "text": "", 
            "title": "KeyValuePair get( ManagedString key)"
        }, 
        {
            "location": "/ubit/storage/#description_7", 
            "text": "Retreives a  KeyValuePair", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/storage/#parameters_6", 
            "text": "ManagedString   key  - the unique name used to identify a  KeyValuePair  in flash.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/storage/#returns_3", 
            "text": "a pointer to a heap allocated  KeyValuePair  struct, this pointer will be NULL if the key was not found in storage.   Note  it is up to the user to free memory after use.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/storage/#remove", 
            "text": "", 
            "title": "remove"
        }, 
        {
            "location": "/ubit/storage/#int-remove-const-char-key", 
            "text": "", 
            "title": "int remove( const char * key)"
        }, 
        {
            "location": "/ubit/storage/#description_8", 
            "text": "Removes a  KeyValuePair", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/storage/#parameters_7", 
            "text": "const char    key* - the unique name used to identify a  KeyValuePair  in flash.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/storage/#returns_4", 
            "text": "MICROBIT_OK on success, or MICROBIT_NO_DATA if the given key was not found in flash.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/storage/#int-remove-managedstring-key", 
            "text": "", 
            "title": "int remove( ManagedString key)"
        }, 
        {
            "location": "/ubit/storage/#description_9", 
            "text": "Removes a  KeyValuePair", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/storage/#parameters_8", 
            "text": "ManagedString   key  - the unique name used to identify a  KeyValuePair  in flash.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/storage/#returns_5", 
            "text": "MICROBIT_OK on success, or MICROBIT_NO_DATA if the given key was not found in flash.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/storage/#size", 
            "text": "", 
            "title": "size"
        }, 
        {
            "location": "/ubit/storage/#int-size", 
            "text": "", 
            "title": "int size()"
        }, 
        {
            "location": "/ubit/storage/#description_10", 
            "text": "The size of the flash based  KeyValueStore", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/storage/#returns_6", 
            "text": "the number of entries in the key value store", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/", 
            "text": "uBit.serial\n\n\nOverview\n\n\nSerial communication provides a simple way to exchange a series of bytes between one computer and another.  The runtime's implementation of serial is general purpose and supports a number of different modes. It has a circular buffer for both the reception and transmission of data, and provides notifications to the user through the MessageBus.\n\n\nBy default, the baud rate for MicroBitSerial is \n115200\n and has very little overhead up until\nit is used to \nsend()\n or \nread()\n, at which point buffers are allocated in order\nto accommodate incoming or outgoing data.\n\n\nMicroBitSerial inherits from mbeds' \nRawSerial\n\nclass, which exposes a lightweight version of \nprintf()\n and incurs minimal overhead\nas MicroBitSerial's buffers will not be allocated.\n\n\nThe MicroBitSerial class supports multithreaded operation, ensuring that only\none fiber can access the Serial port at a time.\n\n\nThe USB interface on the micro:bit is the \nKL26Z\n.\n\n\n\n\nNote\n\n\nOn Mac OSX and Linux Serial communication works out of the box, however on Windows an additional\n\ndriver\n is required.\n\n\n\n\n\n\nWarning\n\n\nThe baud rate is shared across all instances of MicroBitSerial (this is enforced in hardware).\n\n\n\n\nSerial modes\n\n\nThere are three modes of operation for all \nsend()\n or \nread()\n calls:\n\n\n\n\nASYNC\n - Returns immediately after fetching any available data for a given call\n\n\nSYNC_SPINWAIT\n - Synchronously access the serial port until the selected operation is complete.\n                    This mode will lock up the processor, and isn't recommended if multiple fibers are in use.\n\n\nSYNC_SLEEP\n - Blocks the current fiber until the selected operation is complete. This mode cooperates with the\n                 Fiber scheduler, and should be used in a multi-fiber program.\n\n\n\n\nSerial debug\n\n\nIn MicroBitConfig.h, the configuration option \nMICROBIT_DEBUG\n can be used to activate serial debugging\nfor many of the components in the runtime.\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_SERIAL\n\n\n32\n\n\n\n\n\n\n\n\nMessage Bus Events\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_SERIAL_EVT_DELIM_MATCH\n\n\n1\n\n\n\n\n\n\nMICROBIT_SERIAL_EVT_HEAD_MATCH\n\n\n2\n\n\n\n\n\n\nMICROBIT_SERIAL_EVT_RX_FULL\n\n\n3\n\n\n\n\n\n\n\n\nNotify Events\n\n\nThese events use the notification channel \nMICROBIT_ID_NOTIFY\n, which provides\ngeneral purpose synchronisation.\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_SERIAL_EVT_TX_EMPTY\n\n\n2\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitSerial( \nPinName\n tx,  \nPinName\n rx)\n\n\nDescription\n\n\nConstructor. Create an instance of  MicroBitSerial\n\n\nParameters\n\n\n\n\nPinName\n \ntx\n - the Pin to be used for transmission\n\n\nPinName\n \nrx\n - the Pin to be used for receiving data\n\n\n\n\nExample\n\n\n MicroBitSerial serial(USBTX, USBRX); \n\n\n\n\n\n\nNote\n\n\nthe default baud rate is 115200. More API details can be found: -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h\n\n\n\n\n\n\nMicroBitSerial( \nPinName\n tx,  \nPinName\n rx,  \nuint8_t\n rxBufferSize)\n\n\nDescription\n\n\nConstructor. Create an instance of  MicroBitSerial\n\n\nParameters\n\n\n\n\nPinName\n \ntx\n - the Pin to be used for transmission\n\n\nPinName\n \nrx\n - the Pin to be used for receiving data\n\n\nuint8_t\n \nrxBufferSize\n - the size of the buffer to be used for receiving bytes\n\n\n\n\nExample\n\n\n MicroBitSerial serial(USBTX, USBRX); \n\n\n\n\n\n\nNote\n\n\nthe default baud rate is 115200. More API details can be found: -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h\n\n\n\n\n\n\nMicroBitSerial( \nPinName\n tx,  \nPinName\n rx,  \nuint8_t\n rxBufferSize,  \nuint8_t\n txBufferSize)\n\n\nDescription\n\n\nConstructor. Create an instance of  MicroBitSerial\n\n\nParameters\n\n\n\n\nPinName\n \ntx\n - the Pin to be used for transmission\n\n\nPinName\n \nrx\n - the Pin to be used for receiving data\n\n\nuint8_t\n \nrxBufferSize\n - the size of the buffer to be used for receiving bytes\n\n\nuint8_t\n \ntxBufferSize\n - the size of the buffer to be used for transmitting bytes\n\n\n\n\nExample\n\n\n MicroBitSerial serial(USBTX, USBRX); \n\n\n\n\n\n\nNote\n\n\nthe default baud rate is 115200. More API details can be found: -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h\n\n\n\n\nsendChar\n\n\n\n\nint\n sendChar( \nchar\n c)\n\n\nDescription\n\n\nSends a single character over the serial line.\n\n\nParameters\n\n\n\n\nchar\n \nc\n - the character to send\n\n\n\n\nReturns\n\n\nthe number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission. \n\n\n\nint\n sendChar( \nchar\n c,  \nMicroBitSerialMode\n mode)\n\n\nDescription\n\n\nSends a single character over the serial line.\n\n\nParameters\n\n\n\n\nchar\n \nc\n - the character to send\n\n\nMicroBitSerialMode\n \nmode\n - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - the character is copied into the txBuff and returns immediately.\n\n\n\n\nSYNC_SPINWAIT - the character is copied into the txBuff and this method\n                will spin (lock up the processor) until the character has\n                been sent.\n\n\nSYNC_SLEEP - the character is copied into the txBuff and the fiber sleeps\n             until the character has been sent. This allows other fibers\n             to continue execution.\n\n\nReturns\n\n\nthe number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission. \n\n\nsend\n\n\n\n\nint\n send( \nManagedString\n s)\n\n\nDescription\n\n\nSends a  ManagedString\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - the string to send\n\n\n\n\nReturns\n\n\nthe number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission. \n\n\n\nint\n send( \nManagedString\n s,  \nMicroBitSerialMode\n mode)\n\n\nDescription\n\n\nSends a  ManagedString\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - the string to send\n\n\nMicroBitSerialMode\n \nmode\n - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.\n\n\n\n\nSYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.\n\n\nSYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.\n\n\nReturns\n\n\nthe number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission. \n\n\n\nint\n send( \nuint8_t *\n buffer,  \nint\n bufferLen)\n\n\nDescription\n\n\nSends a buffer of known length over the serial line.\n\n\nParameters\n\n\n\n\nuint8_t \n \nbuffer* - a pointer to the first character of the buffer\n\n\nint\n \nbufferLen\n - a pointer to the first character of the buffer\n\n\n\n\nReturns\n\n\nthe number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission. \n\n\n\nint\n send( \nuint8_t *\n buffer,  \nint\n bufferLen,  \nMicroBitSerialMode\n mode)\n\n\nDescription\n\n\nSends a buffer of known length over the serial line.\n\n\nParameters\n\n\n\n\nuint8_t \n \nbuffer* - a pointer to the first character of the buffer\n\n\nint\n \nbufferLen\n - a pointer to the first character of the buffer\n\n\nMicroBitSerialMode\n \nmode\n - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.\n\n\n\n\nSYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.\n\n\nSYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.\n\n\nReturns\n\n\nthe number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission. \n\n\nread\n\n\n\n\nint\n read()\n\n\nDescription\n\n\nReads a single character from the rxBuff\n\n\nReturns\n\n\na character, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for reception, MICROBIT_NO_RESOURCES if buffer allocation did not complete successfully, or MICROBIT_NO_DATA if the rx buffer is empty and the mode given is ASYNC. \n\n\n\nint\n read( \nMicroBitSerialMode\n mode)\n\n\nDescription\n\n\nReads a single character from the rxBuff\n\n\nParameters\n\n\n\n\nMicroBitSerialMode\n \nmode\n - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - A character is read from the rxBuff if available, if there\n        are no characters to be read, a value of MICROBIT_NO_DATA is returned immediately.\n\n\n\n\nSYNC_SPINWAIT - A character is read from the rxBuff if available, if there\n                are no characters to be read, this method will spin\n                (lock up the processor) until a character is available.\n\n\nSYNC_SLEEP - A character is read from the rxBuff if available, if there\n             are no characters to be read, the calling fiber sleeps\n             until there is a character available.\n\n\nReturns\n\n\na character, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for reception, MICROBIT_NO_RESOURCES if buffer allocation did not complete successfully, or MICROBIT_NO_DATA if the rx buffer is empty and the mode given is ASYNC. \n\n\n\nManagedString\n read( \nint\n size)\n\n\nDescription\n\n\nReads multiple characters from the rxBuff and returns them as a  ManagedString\n\n\nParameters\n\n\n\n\nint\n \nsize\n - the number of characters to read.\n\n\n\n\nReturns\n\n\nA  ManagedString , or an empty  ManagedString  if an error was encountered during the read. \n\n\n\nManagedString\n read( \nint\n size,  \nMicroBitSerialMode\n mode)\n\n\nDescription\n\n\nReads multiple characters from the rxBuff and returns them as a  ManagedString\n\n\nParameters\n\n\n\n\nint\n \nsize\n - the number of characters to read.\n\n\nMicroBitSerialMode\n \nmode\n - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will return\n        a ManagedString with the expected size. Otherwise, it will read however\n        many characters there are available.\n\n\n\n\nSYNC_SPINWAIT - If the desired number of characters are available, this will return\n                a ManagedString with the expected size. Otherwise, this method will spin\n                (lock up the processor) until the desired number of characters have been read.\n\n\nSYNC_SLEEP - If the desired number of characters are available, this will return\n             a ManagedString with the expected size. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.\n\n\nReturns\n\n\nA  ManagedString , or an empty  ManagedString  if an error was encountered during the read. \n\n\n\nint\n read( \nuint8_t *\n buffer,  \nint\n bufferLen)\n\n\nDescription\n\n\nReads multiple characters from the rxBuff and fills a user buffer.\n\n\nParameters\n\n\n\n\nuint8_t \n \nbuffer* - a pointer to a user allocated buffer.\n\n\nint\n \nbufferLen\n - the amount of data that can be safely stored\n\n\n\n\nReturns\n\n\nthe number of characters read, or MICROBIT_SERIAL_IN_USE if another fiber is using the instance for receiving. \n\n\n\nint\n read( \nuint8_t *\n buffer,  \nint\n bufferLen,  \nMicroBitSerialMode\n mode)\n\n\nDescription\n\n\nReads multiple characters from the rxBuff and fills a user buffer.\n\n\nParameters\n\n\n\n\nuint8_t \n \nbuffer* - a pointer to a user allocated buffer.\n\n\nint\n \nbufferLen\n - the amount of data that can be safely stored\n\n\nMicroBitSerialMode\n \nmode\n - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will fill\n        the given buffer. Otherwise, it will fill the buffer with however\n        many characters there are available.\n\n\n\n\nSYNC_SPINWAIT - If the desired number of characters are available, this will fill\n                the given buffer. Otherwise, this method will spin (lock up the processor)\n                and fill the buffer until the desired number of characters have been read.\n\n\nSYNC_SLEEP - If the desired number of characters are available, this will fill\n             the given buffer. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.\n\n\nReturns\n\n\nthe number of characters read, or MICROBIT_SERIAL_IN_USE if another fiber is using the instance for receiving. \n\n\nreadUntil\n\n\n\n\nManagedString\n readUntil( \nManagedString\n delimeters)\n\n\nDescription\n\n\nReads until one of the delimeters matches a character in the rxBuff\n\n\nParameters\n\n\n\n\nManagedString\n \ndelimeters\n - a  ManagedString  containing a sequence of delimeter characters e.g.  ManagedString (\"\\r\\n\")\n\n\n\n\nReturns\n\n\nA  ManagedString  containing the characters up to a delimeter, or an Empty  ManagedString , if another fiber is currently using this instance for reception.\n\n\n\n\nNote\n\n\ndelimeters are matched on a per byte basis. \n\n\n\n\n\n\nManagedString\n readUntil( \nManagedString\n delimeters,  \nMicroBitSerialMode\n mode)\n\n\nDescription\n\n\nReads until one of the delimeters matches a character in the rxBuff\n\n\nParameters\n\n\n\n\nManagedString\n \ndelimeters\n - a  ManagedString  containing a sequence of delimeter characters e.g.  ManagedString (\"\\r\\n\")\n\n\nMicroBitSerialMode\n \nmode\n - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If one of the delimeters matches a character already in the rxBuff\n        this method will return a ManagedString up to the delimeter.\n        Otherwise, it will return an Empty ManagedString.\n\n\n\n\nSYNC_SPINWAIT - If one of the delimeters matches a character already in the rxBuff\n                this method will return a ManagedString up to the delimeter.\n                Otherwise, this method will spin (lock up the processor) until a\n                received character matches one of the delimeters.\n\n\nSYNC_SLEEP - If one of the delimeters matches a character already in the rxBuff\n             this method will return a ManagedString up to the delimeter.\n             Otherwise, the calling fiber sleeps until a character matching one\n             of the delimeters is seen.\n\n\nReturns\n\n\nA  ManagedString  containing the characters up to a delimeter, or an Empty  ManagedString , if another fiber is currently using this instance for reception.\n\n\n\n\nNote\n\n\ndelimeters are matched on a per byte basis. \n\n\n\n\nbaud\n\n\n\n\nvoid\n baud( \nint\n baudrate)\n\n\nDescription\n\n\nA wrapper around the inherited method \"baud\" so we can trap the baud rate as it changes and restore it if  redirect()\n\n\nParameters\n\n\n\n\nint\n \nbaudrate\n - the new baudrate. See: \n https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/targets/hal/TARGET_NORDIC/TARGET_MCU_NRF51822/serial_api.c  for permitted baud rates. \n\n\n\n\nReturns\n\n\nMICROBIT_INVALID_PARAMETER if baud rate is less than 0, otherwise MICROBIT_OK.\n\n\n\n\nNote\n\n\nthe underlying implementation chooses the first allowable rate at or above that requested. \n\n\n\n\nredirect\n\n\n\n\nint\n redirect( \nPinName\n tx,  \nPinName\n rx)\n\n\nDescription\n\n\nA way of dynamically configuring the serial instance to use pins other than USBTX and USBRX.\n\n\nParameters\n\n\n\n\nPinName\n \ntx\n - the new transmission pin.\n\n\nPinName\n \nrx\n - the new reception pin.\n\n\n\n\nReturns\n\n\nMICROBIT_SERIAL_IN_USE if another fiber is currently transmitting or receiving, otherwise MICROBIT_OK. \n\n\neventAfter\n\n\n\n\nint\n eventAfter( \nint\n len)\n\n\nDescription\n\n\nConfigures an event to be fired after \"len\" characters.\n\n\nParameters\n\n\n\n\nint\n \nlen\n - the number of characters to wait before triggering the event.\n\n\n\n\nReturns\n\n\nMICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK. \n\n\n\nint\n eventAfter( \nint\n len,  \nMicroBitSerialMode\n mode)\n\n\nDescription\n\n\nConfigures an event to be fired after \"len\" characters.\n\n\nParameters\n\n\n\n\nint\n \nlen\n - the number of characters to wait before triggering the event.\n\n\nMicroBitSerialMode\n \nmode\n - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - Will configure the event and return immediately.\n\n\n\n\nSYNC_SPINWAIT - will return MICROBIT_INVALID_PARAMETER\n\n\nSYNC_SLEEP - Will configure the event and block the current fiber until the\n             event is received.\n\n\nReturns\n\n\nMICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK. \n\n\neventOn\n\n\n\n\nint\n eventOn( \nManagedString\n delimeters)\n\n\nDescription\n\n\nConfigures an event to be fired on a match with one of the delimeters.\n\n\nParameters\n\n\n\n\nManagedString\n \ndelimeters\n - the characters to match received characters against e.g.  ManagedString (\"\\r\\n\")\n\n\n\n\nReturns\n\n\nMICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK.\n\n\n\n\nNote\n\n\ndelimeters are matched on a per byte basis. \n\n\n\n\n\n\nint\n eventOn( \nManagedString\n delimeters,  \nMicroBitSerialMode\n mode)\n\n\nDescription\n\n\nConfigures an event to be fired on a match with one of the delimeters.\n\n\nParameters\n\n\n\n\nManagedString\n \ndelimeters\n - the characters to match received characters against e.g.  ManagedString (\"\\r\\n\")\n\n\nMicroBitSerialMode\n \nmode\n - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - Will configure the event and return immediately.\n\n\n\n\nSYNC_SPINWAIT - will return MICROBIT_INVALID_PARAMETER\n\n\nSYNC_SLEEP - Will configure the event and block the current fiber until the\n             event is received.\n\n\nReturns\n\n\nMICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK.\n\n\n\n\nNote\n\n\ndelimeters are matched on a per byte basis. \n\n\n\n\nisReadable\n\n\n\n\nint\n isReadable()\n\n\nDescription\n\n\nDetermines whether there is any data waiting in our Rx buffer.\n\n\nReturns\n\n\n1 if we have space, 0 if we do not.\n\n\n\n\nNote\n\n\nWe do not wrap the super's readable() method as we don't want to interfere with communities that use manual calls to serial.readable(). \n\n\n\n\nisWriteable\n\n\n\n\nint\n isWriteable()\n\n\nDescription\n\n\nDetermines if we have space in our txBuff.\n\n\nReturns\n\n\n1 if we have space, 0 if we do not.\n\n\n\n\nNote\n\n\nWe do not wrap the super's writeable() method as we don't want to interfere with communities that use manual calls to serial.writeable(). \n\n\n\n\nsetRxBufferSize\n\n\n\n\nint\n setRxBufferSize( \nuint8_t\n size)\n\n\nDescription\n\n\nReconfigures the size of our rxBuff\n\n\nParameters\n\n\n\n\nuint8_t\n \nsize\n - the new size for our rxBuff\n\n\n\n\nReturns\n\n\nMICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for reception, otherwise MICROBIT_OK. \n\n\nsetTxBufferSize\n\n\n\n\nint\n setTxBufferSize( \nuint8_t\n size)\n\n\nDescription\n\n\nReconfigures the size of our txBuff\n\n\nParameters\n\n\n\n\nuint8_t\n \nsize\n - the new size for our txBuff\n\n\n\n\nReturns\n\n\nMICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for transmission, otherwise MICROBIT_OK. \n\n\ngetRxBufferSize\n\n\n\n\nint\n getRxBufferSize()\n\n\nDescription\n\n\nThe size of our rx buffer in bytes.\n\n\nReturns\n\n\nthe current size of rxBuff in bytes \n\n\ngetTxBufferSize\n\n\n\n\nint\n getTxBufferSize()\n\n\nDescription\n\n\nThe size of our tx buffer in bytes.\n\n\nReturns\n\n\nthe current size of txBuff in bytes \n\n\nclearRxBuffer\n\n\n\n\nint\n clearRxBuffer()\n\n\nDescription\n\n\nSets the tail to match the head of our circular buffer for reception, effectively clearing the reception buffer.\n\n\nReturns\n\n\nMICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for reception, otherwise MICROBIT_OK. \n\n\nclearTxBuffer\n\n\n\n\nint\n clearTxBuffer()\n\n\nDescription\n\n\nSets the tail to match the head of our circular buffer for transmission, effectively clearing the transmission buffer.\n\n\nReturns\n\n\nMICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for transmission, otherwise MICROBIT_OK. \n\n\nrxBufferedSize\n\n\n\n\nint\n rxBufferedSize()\n\n\nDescription\n\n\nThe number of bytes currently stored in our rx buffer waiting to be digested, by the user.\n\n\nReturns\n\n\nThe currently buffered number of bytes in our rxBuff. \n\n\ntxBufferedSize\n\n\n\n\nint\n txBufferedSize()\n\n\nDescription\n\n\nThe number of bytes currently stored in our tx buffer waiting to be transmitted by the hardware.\n\n\nReturns\n\n\nThe currently buffered number of bytes in our txBuff. \n\n\nrxInUse\n\n\n\n\nint\n rxInUse()\n\n\nDescription\n\n\nDetermines if the serial bus is currently in use by another fiber for reception.\n\n\nReturns\n\n\nThe state of our mutex lock for reception.\n\n\n\n\nNote\n\n\nOnly one fiber can call read at a time \n\n\n\n\ntxInUse\n\n\n\n\nint\n txInUse()\n\n\nDescription\n\n\nDetermines if the serial bus is currently in use by another fiber for transmission.\n\n\nReturns\n\n\nThe state of our mutex lock for transmition.\n\n\n\n\nNote\n\n\nOnly one fiber can call send at a time \n\n\n\n\ndetach\n\n\n\n\nvoid\n detach( \nSerial::IrqType\n interuptType)\n\n\nDescription\n\n\nDetaches a previously configured interrupt\n\n\nParameters\n\n\n\n\nSerial::IrqType\n \ninteruptType", 
            "title": "serial"
        }, 
        {
            "location": "/ubit/serial/#ubitserial", 
            "text": "", 
            "title": "uBit.serial"
        }, 
        {
            "location": "/ubit/serial/#overview", 
            "text": "Serial communication provides a simple way to exchange a series of bytes between one computer and another.  The runtime's implementation of serial is general purpose and supports a number of different modes. It has a circular buffer for both the reception and transmission of data, and provides notifications to the user through the MessageBus.  By default, the baud rate for MicroBitSerial is  115200  and has very little overhead up until\nit is used to  send()  or  read() , at which point buffers are allocated in order\nto accommodate incoming or outgoing data.  MicroBitSerial inherits from mbeds'  RawSerial \nclass, which exposes a lightweight version of  printf()  and incurs minimal overhead\nas MicroBitSerial's buffers will not be allocated.  The MicroBitSerial class supports multithreaded operation, ensuring that only\none fiber can access the Serial port at a time.  The USB interface on the micro:bit is the  KL26Z .   Note  On Mac OSX and Linux Serial communication works out of the box, however on Windows an additional driver  is required.    Warning  The baud rate is shared across all instances of MicroBitSerial (this is enforced in hardware).", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/serial/#serial-modes", 
            "text": "There are three modes of operation for all  send()  or  read()  calls:   ASYNC  - Returns immediately after fetching any available data for a given call  SYNC_SPINWAIT  - Synchronously access the serial port until the selected operation is complete.\n                    This mode will lock up the processor, and isn't recommended if multiple fibers are in use.  SYNC_SLEEP  - Blocks the current fiber until the selected operation is complete. This mode cooperates with the\n                 Fiber scheduler, and should be used in a multi-fiber program.", 
            "title": "Serial modes"
        }, 
        {
            "location": "/ubit/serial/#serial-debug", 
            "text": "In MicroBitConfig.h, the configuration option  MICROBIT_DEBUG  can be used to activate serial debugging\nfor many of the components in the runtime.", 
            "title": "Serial debug"
        }, 
        {
            "location": "/ubit/serial/#message-bus-id", 
            "text": "Constant  Value      MICROBIT_ID_SERIAL  32", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/serial/#message-bus-events", 
            "text": "Constant  Value      MICROBIT_SERIAL_EVT_DELIM_MATCH  1    MICROBIT_SERIAL_EVT_HEAD_MATCH  2    MICROBIT_SERIAL_EVT_RX_FULL  3", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/serial/#notify-events", 
            "text": "These events use the notification channel  MICROBIT_ID_NOTIFY , which provides\ngeneral purpose synchronisation.     Constant  Value      MICROBIT_SERIAL_EVT_TX_EMPTY  2", 
            "title": "Notify Events"
        }, 
        {
            "location": "/ubit/serial/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/serial/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/serial/#microbitserial-pinname-tx-pinname-rx", 
            "text": "", 
            "title": "MicroBitSerial( PinName tx,  PinName rx)"
        }, 
        {
            "location": "/ubit/serial/#description", 
            "text": "Constructor. Create an instance of  MicroBitSerial", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters", 
            "text": "PinName   tx  - the Pin to be used for transmission  PinName   rx  - the Pin to be used for receiving data", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#example", 
            "text": "MicroBitSerial serial(USBTX, USBRX);    Note  the default baud rate is 115200. More API details can be found: -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/serial/#microbitserial-pinname-tx-pinname-rx-uint8_t-rxbuffersize", 
            "text": "", 
            "title": "MicroBitSerial( PinName tx,  PinName rx,  uint8_t rxBufferSize)"
        }, 
        {
            "location": "/ubit/serial/#description_1", 
            "text": "Constructor. Create an instance of  MicroBitSerial", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_1", 
            "text": "PinName   tx  - the Pin to be used for transmission  PinName   rx  - the Pin to be used for receiving data  uint8_t   rxBufferSize  - the size of the buffer to be used for receiving bytes", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#example_1", 
            "text": "MicroBitSerial serial(USBTX, USBRX);    Note  the default baud rate is 115200. More API details can be found: -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/serial/#microbitserial-pinname-tx-pinname-rx-uint8_t-rxbuffersize-uint8_t-txbuffersize", 
            "text": "", 
            "title": "MicroBitSerial( PinName tx,  PinName rx,  uint8_t rxBufferSize,  uint8_t txBufferSize)"
        }, 
        {
            "location": "/ubit/serial/#description_2", 
            "text": "Constructor. Create an instance of  MicroBitSerial", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_2", 
            "text": "PinName   tx  - the Pin to be used for transmission  PinName   rx  - the Pin to be used for receiving data  uint8_t   rxBufferSize  - the size of the buffer to be used for receiving bytes  uint8_t   txBufferSize  - the size of the buffer to be used for transmitting bytes", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#example_2", 
            "text": "MicroBitSerial serial(USBTX, USBRX);    Note  the default baud rate is 115200. More API details can be found: -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/SerialBase.h -https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/api/RawSerial.h", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/serial/#sendchar", 
            "text": "", 
            "title": "sendChar"
        }, 
        {
            "location": "/ubit/serial/#int-sendchar-char-c", 
            "text": "", 
            "title": "int sendChar( char c)"
        }, 
        {
            "location": "/ubit/serial/#description_3", 
            "text": "Sends a single character over the serial line.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_3", 
            "text": "char   c  - the character to send", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns", 
            "text": "the number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#int-sendchar-char-c-microbitserialmode-mode", 
            "text": "", 
            "title": "int sendChar( char c,  MicroBitSerialMode mode)"
        }, 
        {
            "location": "/ubit/serial/#description_4", 
            "text": "Sends a single character over the serial line.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_4", 
            "text": "char   c  - the character to send  MicroBitSerialMode   mode  - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - the character is copied into the txBuff and returns immediately.   SYNC_SPINWAIT - the character is copied into the txBuff and this method\n                will spin (lock up the processor) until the character has\n                been sent.  SYNC_SLEEP - the character is copied into the txBuff and the fiber sleeps\n             until the character has been sent. This allows other fibers\n             to continue execution.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_1", 
            "text": "the number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#send", 
            "text": "", 
            "title": "send"
        }, 
        {
            "location": "/ubit/serial/#int-send-managedstring-s", 
            "text": "", 
            "title": "int send( ManagedString s)"
        }, 
        {
            "location": "/ubit/serial/#description_5", 
            "text": "Sends a  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_5", 
            "text": "ManagedString   s  - the string to send", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_2", 
            "text": "the number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#int-send-managedstring-s-microbitserialmode-mode", 
            "text": "", 
            "title": "int send( ManagedString s,  MicroBitSerialMode mode)"
        }, 
        {
            "location": "/ubit/serial/#description_6", 
            "text": "Sends a  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_6", 
            "text": "ManagedString   s  - the string to send  MicroBitSerialMode   mode  - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.   SYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.  SYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_3", 
            "text": "the number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#int-send-uint8_t-buffer-int-bufferlen", 
            "text": "", 
            "title": "int send( uint8_t * buffer,  int bufferLen)"
        }, 
        {
            "location": "/ubit/serial/#description_7", 
            "text": "Sends a buffer of known length over the serial line.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_7", 
            "text": "uint8_t    buffer* - a pointer to the first character of the buffer  int   bufferLen  - a pointer to the first character of the buffer", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_4", 
            "text": "the number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#int-send-uint8_t-buffer-int-bufferlen-microbitserialmode-mode", 
            "text": "", 
            "title": "int send( uint8_t * buffer,  int bufferLen,  MicroBitSerialMode mode)"
        }, 
        {
            "location": "/ubit/serial/#description_8", 
            "text": "Sends a buffer of known length over the serial line.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_8", 
            "text": "uint8_t    buffer* - a pointer to the first character of the buffer  int   bufferLen  - a pointer to the first character of the buffer  MicroBitSerialMode   mode  - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - bytes are copied into the txBuff and returns immediately.   SYNC_SPINWAIT - bytes are copied into the txBuff and this method\n                will spin (lock up the processor) until all bytes\n                have been sent.  SYNC_SLEEP - bytes are copied into the txBuff and the fiber sleeps\n             until all bytes have been sent. This allows other fibers\n             to continue execution.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_5", 
            "text": "the number of bytes written, or MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for transmission.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#read", 
            "text": "", 
            "title": "read"
        }, 
        {
            "location": "/ubit/serial/#int-read", 
            "text": "", 
            "title": "int read()"
        }, 
        {
            "location": "/ubit/serial/#description_9", 
            "text": "Reads a single character from the rxBuff", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#returns_6", 
            "text": "a character, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for reception, MICROBIT_NO_RESOURCES if buffer allocation did not complete successfully, or MICROBIT_NO_DATA if the rx buffer is empty and the mode given is ASYNC.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#int-read-microbitserialmode-mode", 
            "text": "", 
            "title": "int read( MicroBitSerialMode mode)"
        }, 
        {
            "location": "/ubit/serial/#description_10", 
            "text": "Reads a single character from the rxBuff", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_9", 
            "text": "MicroBitSerialMode   mode  - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - A character is read from the rxBuff if available, if there\n        are no characters to be read, a value of MICROBIT_NO_DATA is returned immediately.   SYNC_SPINWAIT - A character is read from the rxBuff if available, if there\n                are no characters to be read, this method will spin\n                (lock up the processor) until a character is available.  SYNC_SLEEP - A character is read from the rxBuff if available, if there\n             are no characters to be read, the calling fiber sleeps\n             until there is a character available.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_7", 
            "text": "a character, MICROBIT_SERIAL_IN_USE if another fiber is using the serial instance for reception, MICROBIT_NO_RESOURCES if buffer allocation did not complete successfully, or MICROBIT_NO_DATA if the rx buffer is empty and the mode given is ASYNC.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#managedstring-read-int-size", 
            "text": "", 
            "title": "ManagedString read( int size)"
        }, 
        {
            "location": "/ubit/serial/#description_11", 
            "text": "Reads multiple characters from the rxBuff and returns them as a  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_10", 
            "text": "int   size  - the number of characters to read.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_8", 
            "text": "A  ManagedString , or an empty  ManagedString  if an error was encountered during the read.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#managedstring-read-int-size-microbitserialmode-mode", 
            "text": "", 
            "title": "ManagedString read( int size,  MicroBitSerialMode mode)"
        }, 
        {
            "location": "/ubit/serial/#description_12", 
            "text": "Reads multiple characters from the rxBuff and returns them as a  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_11", 
            "text": "int   size  - the number of characters to read.  MicroBitSerialMode   mode  - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will return\n        a ManagedString with the expected size. Otherwise, it will read however\n        many characters there are available.   SYNC_SPINWAIT - If the desired number of characters are available, this will return\n                a ManagedString with the expected size. Otherwise, this method will spin\n                (lock up the processor) until the desired number of characters have been read.  SYNC_SLEEP - If the desired number of characters are available, this will return\n             a ManagedString with the expected size. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_9", 
            "text": "A  ManagedString , or an empty  ManagedString  if an error was encountered during the read.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#int-read-uint8_t-buffer-int-bufferlen", 
            "text": "", 
            "title": "int read( uint8_t * buffer,  int bufferLen)"
        }, 
        {
            "location": "/ubit/serial/#description_13", 
            "text": "Reads multiple characters from the rxBuff and fills a user buffer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_12", 
            "text": "uint8_t    buffer* - a pointer to a user allocated buffer.  int   bufferLen  - the amount of data that can be safely stored", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_10", 
            "text": "the number of characters read, or MICROBIT_SERIAL_IN_USE if another fiber is using the instance for receiving.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#int-read-uint8_t-buffer-int-bufferlen-microbitserialmode-mode", 
            "text": "", 
            "title": "int read( uint8_t * buffer,  int bufferLen,  MicroBitSerialMode mode)"
        }, 
        {
            "location": "/ubit/serial/#description_14", 
            "text": "Reads multiple characters from the rxBuff and fills a user buffer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_13", 
            "text": "uint8_t    buffer* - a pointer to a user allocated buffer.  int   bufferLen  - the amount of data that can be safely stored  MicroBitSerialMode   mode  - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If the desired number of characters are available, this will fill\n        the given buffer. Otherwise, it will fill the buffer with however\n        many characters there are available.   SYNC_SPINWAIT - If the desired number of characters are available, this will fill\n                the given buffer. Otherwise, this method will spin (lock up the processor)\n                and fill the buffer until the desired number of characters have been read.  SYNC_SLEEP - If the desired number of characters are available, this will fill\n             the given buffer. Otherwise, the calling fiber sleeps\n             until the desired number of characters have been read.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_11", 
            "text": "the number of characters read, or MICROBIT_SERIAL_IN_USE if another fiber is using the instance for receiving.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#readuntil", 
            "text": "", 
            "title": "readUntil"
        }, 
        {
            "location": "/ubit/serial/#managedstring-readuntil-managedstring-delimeters", 
            "text": "", 
            "title": "ManagedString readUntil( ManagedString delimeters)"
        }, 
        {
            "location": "/ubit/serial/#description_15", 
            "text": "Reads until one of the delimeters matches a character in the rxBuff", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_14", 
            "text": "ManagedString   delimeters  - a  ManagedString  containing a sequence of delimeter characters e.g.  ManagedString (\"\\r\\n\")", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_12", 
            "text": "A  ManagedString  containing the characters up to a delimeter, or an Empty  ManagedString , if another fiber is currently using this instance for reception.   Note  delimeters are matched on a per byte basis.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#managedstring-readuntil-managedstring-delimeters-microbitserialmode-mode", 
            "text": "", 
            "title": "ManagedString readUntil( ManagedString delimeters,  MicroBitSerialMode mode)"
        }, 
        {
            "location": "/ubit/serial/#description_16", 
            "text": "Reads until one of the delimeters matches a character in the rxBuff", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_15", 
            "text": "ManagedString   delimeters  - a  ManagedString  containing a sequence of delimeter characters e.g.  ManagedString (\"\\r\\n\")  MicroBitSerialMode   mode  - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - If one of the delimeters matches a character already in the rxBuff\n        this method will return a ManagedString up to the delimeter.\n        Otherwise, it will return an Empty ManagedString.   SYNC_SPINWAIT - If one of the delimeters matches a character already in the rxBuff\n                this method will return a ManagedString up to the delimeter.\n                Otherwise, this method will spin (lock up the processor) until a\n                received character matches one of the delimeters.  SYNC_SLEEP - If one of the delimeters matches a character already in the rxBuff\n             this method will return a ManagedString up to the delimeter.\n             Otherwise, the calling fiber sleeps until a character matching one\n             of the delimeters is seen.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_13", 
            "text": "A  ManagedString  containing the characters up to a delimeter, or an Empty  ManagedString , if another fiber is currently using this instance for reception.   Note  delimeters are matched on a per byte basis.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#baud", 
            "text": "", 
            "title": "baud"
        }, 
        {
            "location": "/ubit/serial/#void-baud-int-baudrate", 
            "text": "", 
            "title": "void baud( int baudrate)"
        }, 
        {
            "location": "/ubit/serial/#description_17", 
            "text": "A wrapper around the inherited method \"baud\" so we can trap the baud rate as it changes and restore it if  redirect()", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_16", 
            "text": "int   baudrate  - the new baudrate. See: \n https://github.com/mbedmicro/mbed/blob/master/libraries/mbed/targets/hal/TARGET_NORDIC/TARGET_MCU_NRF51822/serial_api.c  for permitted baud rates.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_14", 
            "text": "MICROBIT_INVALID_PARAMETER if baud rate is less than 0, otherwise MICROBIT_OK.   Note  the underlying implementation chooses the first allowable rate at or above that requested.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#redirect", 
            "text": "", 
            "title": "redirect"
        }, 
        {
            "location": "/ubit/serial/#int-redirect-pinname-tx-pinname-rx", 
            "text": "", 
            "title": "int redirect( PinName tx,  PinName rx)"
        }, 
        {
            "location": "/ubit/serial/#description_18", 
            "text": "A way of dynamically configuring the serial instance to use pins other than USBTX and USBRX.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_17", 
            "text": "PinName   tx  - the new transmission pin.  PinName   rx  - the new reception pin.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_15", 
            "text": "MICROBIT_SERIAL_IN_USE if another fiber is currently transmitting or receiving, otherwise MICROBIT_OK.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#eventafter", 
            "text": "", 
            "title": "eventAfter"
        }, 
        {
            "location": "/ubit/serial/#int-eventafter-int-len", 
            "text": "", 
            "title": "int eventAfter( int len)"
        }, 
        {
            "location": "/ubit/serial/#description_19", 
            "text": "Configures an event to be fired after \"len\" characters.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_18", 
            "text": "int   len  - the number of characters to wait before triggering the event.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_16", 
            "text": "MICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#int-eventafter-int-len-microbitserialmode-mode", 
            "text": "", 
            "title": "int eventAfter( int len,  MicroBitSerialMode mode)"
        }, 
        {
            "location": "/ubit/serial/#description_20", 
            "text": "Configures an event to be fired after \"len\" characters.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_19", 
            "text": "int   len  - the number of characters to wait before triggering the event.  MicroBitSerialMode   mode  - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - Will configure the event and return immediately.   SYNC_SPINWAIT - will return MICROBIT_INVALID_PARAMETER  SYNC_SLEEP - Will configure the event and block the current fiber until the\n             event is received.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_17", 
            "text": "MICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#eventon", 
            "text": "", 
            "title": "eventOn"
        }, 
        {
            "location": "/ubit/serial/#int-eventon-managedstring-delimeters", 
            "text": "", 
            "title": "int eventOn( ManagedString delimeters)"
        }, 
        {
            "location": "/ubit/serial/#description_21", 
            "text": "Configures an event to be fired on a match with one of the delimeters.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_20", 
            "text": "ManagedString   delimeters  - the characters to match received characters against e.g.  ManagedString (\"\\r\\n\")", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_18", 
            "text": "MICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK.   Note  delimeters are matched on a per byte basis.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#int-eventon-managedstring-delimeters-microbitserialmode-mode", 
            "text": "", 
            "title": "int eventOn( ManagedString delimeters,  MicroBitSerialMode mode)"
        }, 
        {
            "location": "/ubit/serial/#description_22", 
            "text": "Configures an event to be fired on a match with one of the delimeters.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_21", 
            "text": "ManagedString   delimeters  - the characters to match received characters against e.g.  ManagedString (\"\\r\\n\")  MicroBitSerialMode   mode  - the selected mode, one of: ASYNC, SYNC_SPINWAIT, SYNC_SLEEP. Each mode gives a different behaviour:  ASYNC - Will configure the event and return immediately.   SYNC_SPINWAIT - will return MICROBIT_INVALID_PARAMETER  SYNC_SLEEP - Will configure the event and block the current fiber until the\n             event is received.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_19", 
            "text": "MICROBIT_INVALID_PARAMETER if the mode given is SYNC_SPINWAIT, otherwise MICROBIT_OK.   Note  delimeters are matched on a per byte basis.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#isreadable", 
            "text": "", 
            "title": "isReadable"
        }, 
        {
            "location": "/ubit/serial/#int-isreadable", 
            "text": "", 
            "title": "int isReadable()"
        }, 
        {
            "location": "/ubit/serial/#description_23", 
            "text": "Determines whether there is any data waiting in our Rx buffer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#returns_20", 
            "text": "1 if we have space, 0 if we do not.   Note  We do not wrap the super's readable() method as we don't want to interfere with communities that use manual calls to serial.readable().", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#iswriteable", 
            "text": "", 
            "title": "isWriteable"
        }, 
        {
            "location": "/ubit/serial/#int-iswriteable", 
            "text": "", 
            "title": "int isWriteable()"
        }, 
        {
            "location": "/ubit/serial/#description_24", 
            "text": "Determines if we have space in our txBuff.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#returns_21", 
            "text": "1 if we have space, 0 if we do not.   Note  We do not wrap the super's writeable() method as we don't want to interfere with communities that use manual calls to serial.writeable().", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#setrxbuffersize", 
            "text": "", 
            "title": "setRxBufferSize"
        }, 
        {
            "location": "/ubit/serial/#int-setrxbuffersize-uint8_t-size", 
            "text": "", 
            "title": "int setRxBufferSize( uint8_t size)"
        }, 
        {
            "location": "/ubit/serial/#description_25", 
            "text": "Reconfigures the size of our rxBuff", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_22", 
            "text": "uint8_t   size  - the new size for our rxBuff", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_22", 
            "text": "MICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for reception, otherwise MICROBIT_OK.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#settxbuffersize", 
            "text": "", 
            "title": "setTxBufferSize"
        }, 
        {
            "location": "/ubit/serial/#int-settxbuffersize-uint8_t-size", 
            "text": "", 
            "title": "int setTxBufferSize( uint8_t size)"
        }, 
        {
            "location": "/ubit/serial/#description_26", 
            "text": "Reconfigures the size of our txBuff", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_23", 
            "text": "uint8_t   size  - the new size for our txBuff", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/serial/#returns_23", 
            "text": "MICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for transmission, otherwise MICROBIT_OK.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#getrxbuffersize", 
            "text": "", 
            "title": "getRxBufferSize"
        }, 
        {
            "location": "/ubit/serial/#int-getrxbuffersize", 
            "text": "", 
            "title": "int getRxBufferSize()"
        }, 
        {
            "location": "/ubit/serial/#description_27", 
            "text": "The size of our rx buffer in bytes.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#returns_24", 
            "text": "the current size of rxBuff in bytes", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#gettxbuffersize", 
            "text": "", 
            "title": "getTxBufferSize"
        }, 
        {
            "location": "/ubit/serial/#int-gettxbuffersize", 
            "text": "", 
            "title": "int getTxBufferSize()"
        }, 
        {
            "location": "/ubit/serial/#description_28", 
            "text": "The size of our tx buffer in bytes.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#returns_25", 
            "text": "the current size of txBuff in bytes", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#clearrxbuffer", 
            "text": "", 
            "title": "clearRxBuffer"
        }, 
        {
            "location": "/ubit/serial/#int-clearrxbuffer", 
            "text": "", 
            "title": "int clearRxBuffer()"
        }, 
        {
            "location": "/ubit/serial/#description_29", 
            "text": "Sets the tail to match the head of our circular buffer for reception, effectively clearing the reception buffer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#returns_26", 
            "text": "MICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for reception, otherwise MICROBIT_OK.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#cleartxbuffer", 
            "text": "", 
            "title": "clearTxBuffer"
        }, 
        {
            "location": "/ubit/serial/#int-cleartxbuffer", 
            "text": "", 
            "title": "int clearTxBuffer()"
        }, 
        {
            "location": "/ubit/serial/#description_30", 
            "text": "Sets the tail to match the head of our circular buffer for transmission, effectively clearing the transmission buffer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#returns_27", 
            "text": "MICROBIT_SERIAL_IN_USE if another fiber is currently using this instance for transmission, otherwise MICROBIT_OK.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#rxbufferedsize", 
            "text": "", 
            "title": "rxBufferedSize"
        }, 
        {
            "location": "/ubit/serial/#int-rxbufferedsize", 
            "text": "", 
            "title": "int rxBufferedSize()"
        }, 
        {
            "location": "/ubit/serial/#description_31", 
            "text": "The number of bytes currently stored in our rx buffer waiting to be digested, by the user.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#returns_28", 
            "text": "The currently buffered number of bytes in our rxBuff.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#txbufferedsize", 
            "text": "", 
            "title": "txBufferedSize"
        }, 
        {
            "location": "/ubit/serial/#int-txbufferedsize", 
            "text": "", 
            "title": "int txBufferedSize()"
        }, 
        {
            "location": "/ubit/serial/#description_32", 
            "text": "The number of bytes currently stored in our tx buffer waiting to be transmitted by the hardware.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#returns_29", 
            "text": "The currently buffered number of bytes in our txBuff.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#rxinuse", 
            "text": "", 
            "title": "rxInUse"
        }, 
        {
            "location": "/ubit/serial/#int-rxinuse", 
            "text": "", 
            "title": "int rxInUse()"
        }, 
        {
            "location": "/ubit/serial/#description_33", 
            "text": "Determines if the serial bus is currently in use by another fiber for reception.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#returns_30", 
            "text": "The state of our mutex lock for reception.   Note  Only one fiber can call read at a time", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#txinuse", 
            "text": "", 
            "title": "txInUse"
        }, 
        {
            "location": "/ubit/serial/#int-txinuse", 
            "text": "", 
            "title": "int txInUse()"
        }, 
        {
            "location": "/ubit/serial/#description_34", 
            "text": "Determines if the serial bus is currently in use by another fiber for transmission.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#returns_31", 
            "text": "The state of our mutex lock for transmition.   Note  Only one fiber can call send at a time", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/serial/#detach", 
            "text": "", 
            "title": "detach"
        }, 
        {
            "location": "/ubit/serial/#void-detach-serialirqtype-interupttype", 
            "text": "", 
            "title": "void detach( Serial::IrqType interuptType)"
        }, 
        {
            "location": "/ubit/serial/#description_35", 
            "text": "Detaches a previously configured interrupt", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/serial/#parameters_24", 
            "text": "Serial::IrqType   interuptType", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/", 
            "text": "uBit.messageBus\n\n\nOverview\n\n\nThe micro:bit has an eventing model that can notfy user code when specific things happen on the micro:bit. For \nexample, the MicroBitAccelerometer will raise events to indicate that the\nmicro:bit has be been shaken, or is in freefall. MicroBitButton will send events on a range of button up, down, click and hold events. \nProgrammers are also free (in fact, encouraged!) to send their own events whenever they feel it would be useful. \n\n\nRegistering an event handler\n\n\nThe MicroBitMessgeBus records which events your program is interested in, and delivers those MicroBitEvents to your program as they occur\nthrough a defined \nevent handler\n.  You do this through the MicroBitMessageBus \nlisten\n function. This lets you attach a callback\nto a funciton when a specified event (or events) occur. You can also control the queuing and threading model used for your callbck funciton\non a per event handler basis.\n\n\nThis may sound complex at first, but it is actually very simple. For example, to find out when button A is clicked, write some code like this:\n\n\nvoid onButtonA(MicroBitEvent e)\n{\n    uBit.display.print(\nA\n);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n}\n\n\n\n\nNow, whenever the MICROBIT_BUTTON_EVT_CLICK event is raise by MICROBIT_ID_BUTTON_A, your code inside function 'onButtonA' will be automatically run.\n\nYou can call listen as many times as you want to attached functions to each of the events that are useful for your program. \n\n\nWildcard Events\n\n\nSometimes though, you want to capture all events genareted by some component. For example, you might want to know when any chages in a button has happened. \nIn this case, there is a special event value called 'MICROBIT_EVT_ANY'. If you call listen with this value, then ALL events from the given source component will be delivered to your function.\nYou can find out which ones by looking at the MicroBitEvent delivered to your function - it contains the source and value variable of the event. For example, you could write\na program like this:\n\n\nvoid onButtonA(MicroBitEvent e)\n{\n    if (e.value == MICROBIT_BUTTON_EVT_CLICK)\n        uBit.display.scroll(\nCLICK\n);\n\n    if (e.value == MICROBIT_BUTTON_EVT_DOWN)\n        uBit.display.scroll(\nDOWN\n);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY, onButtonA);\n}\n\n\n\n\nIf you \nREALLY\n want even more events, there is also a MICROBIT_ID_ANY source, that allows you to attach a function to event generated from any component... Use this\nsparingly though, as this could be quite a lot of events! e.g. The following code would attach the onEvent function to receive all the events from the whole runtime:\n\n\nvoid onEvent(MicroBitEvent e)\n{\n    uBit.display.scroll(\nSOMETHING HAPPENED!\n);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_ANY, MICROBIT_EVT_ANY, onEvent);\n}\n\n\n\n\nDefining a Threading Mode\n\n\nWhenever you register a listener, you may choose the threading mode used with that handler. Every event handler can have its own threading mode, that defines when your handler\nwill be executed, and how it will react to receiving multiple events. There are four permissable modes for event handlers. These are:\n\n\n\n\n\n\n\n\nThreading mode\n\n\nBrief Description\n\n\n\n\n\n\n\n\n\n\nMESSAGE_BUS_LISTENER_IMMEDIATE\n\n\nHandler is called directly from the code raising the event. Event handler is \nnot\n permitted to block.\n\n\n\n\n\n\nMESSAGE_BUS_LISTENER_DROP_IF_BUSY\n\n\nHandler is executed through its own fiber. If another event arrives whilst the previous event is still being proessed, the new event will be silently dropped.\n\n\n\n\n\n\nMESSAGE_BUS_LISTENER_QUEUE_IF_BUSY\n\n\nHandler is executed though its own fiber. If another event arrives, it is queued, and the event handler will immediately be called again once processing is complete. (default)\n\n\n\n\n\n\nMESSAGE_BUS_LISTENER_REENTRANT\n\n\nEvery event is executed in its own fiber. if another event arrives, it is handled concurrently in its own fiber.\n\n\n\n\n\n\n\n\nThese various modes provide great flexibility in how the runtime can be used to support higher level languages and applications. For example, MESSAGE_BUS_LISTENER_IMMEDIATE is ideal for very simple, lightweight handlers, as this will provide very timely response to events with a low processing overhead. However, it is easy to cause side effects on other parts of the code if it doesn not return promptly. MESSAGE_BUS_LISTENER_DROP_IF_BUSY provide semantics identical to the Scratch programming language, so can be used to build easy to understand, asynchronous environmnets. MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY provides similar semantics, but with tolerance to avoiding loss of high frequency events. MESSAGE_BUS_LISTENER_REENTRANT provides guaranteed causal ordering and improved concurrency, but at the cost of additonal complexity and RAM.\n\n\nYou can define the threading mode you want to use on a per event handler basis as an optional final parameter to the listen funciton. For example:\n\n\nbool pressed = false;\n\nvoid onButtonA(MicroBitEvent e)\n{\n    pressed = true;\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA, MESSAGE_BUS_LISTENER_IMMEDIATE);\n}\n\n\n\n\nC++ Event Handlers\n\n\nIt is also posible to write event handlers as C++ member functions. If you don't know what this means, then don't worry, as that also means you won't need it. :-)\nFor those programmers who do like to write C++, you can use a variation of the \nlisten\n funciton to register you member funciton event handler. This takes the same form as\nthe examples above, but with an adiditonal parameter to specify the object to call the method on. You also need to specifiy your event handler using legal C++ syntax. \n\n\nFor example, you can write code like this to register an event handler in your own class:\n\n\nMyCoolObject::onButtonPressed(MicroBitEvent e)\n{\n    uBit.display.print(\nA\n);\n}\n\nMyCoolObject::MyCoolObject()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, this, \nMyCoolObject::onButtonPressed);\n}\n\n\n\n\nAgain, it is also possible to a threading mode as an optional final parameter:\n\n\nMyCoolObject::onButtonPressed(MicroBitEvent e)\n{\n    uBit.display.print(\nA\n);\n}\n\nMyCoolObject::MyCoolObject()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, this, \nMyCoolObject::onButtonPressed, MESSAGE_BUS_LISTENER_IMMEDIATE);\n}\n\n\n\n\nRemoving Event Handlers\n\n\nEvent handlers can be dynamically removed from the message bus as well as added. To do this, use the \nignore\n function. This takes precisely the same parameters as the\nlisten function, except that the threading mode argument is never used.\n\n\nFor example, to remove the event handlers shown above:\n\n\n    uBit.messageBus.ignore(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n    uBit.messageBus.ignore(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, this, \nMyCoolObject::onButtonPressed);\n\n\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_MESSAGE_BUS_LISTENER\n\n\n1021\n\n\n\n\n\n\n\n\n\n\nThe message bus will send a MICROBIT_ID_MESSAGE_BUS_LISTENER event whenever a new listener is added to the message bus. This event allows other parts of the system to detect when interactions are\ntaking place with a component. This is primarily used as a power management mechanism - allowing on demand activation of hardware when necessary.\n\n\n\n\nMessage Bus Events\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMessage Bus ID of listener\n\n\n1-65535\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitMessageBus()\n\n\nDescription\n\n\nDefault constructor.\n\n\nsend\n\n\n\n\nint\n send( \nMicroBitEvent\n evt)\n\n\nDescription\n\n\nQueues the given event to be sent to all registered recipients.\n\n\nParameters\n\n\n\n\nMicroBitEvent\n \nevt\n - The event to send.\n\n\n\n\nExample\n\n\n MicroBitMessageBus bus; \n\n // Creates and sends the MicroBitEvent using bus. \n MicrobitEvent evt(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK); \n\n // Creates the MicrobitEvent, but delays the sending of that event. \n MicrobitEvent evt1(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, CREATE_ONLY); \n\n bus.send(evt1); \n\n // This has the same effect! \n evt1.fire() \n\n\n\n\nprocess\n\n\n\n\nint\n process( \nMicroBitEvent  \n evt)\n\n\nDescription\n\n\nInternal function, used to deliver the given event to all relevant recipients. Normally, this is called once an event has been removed from the event queue.\n\n\nParameters\n\n\n\n\nMicroBitEvent  \n \nevt\n - The event to send.\n\n\n\n\nReturns\n\n\n1 if all matching listeners were processed, 0 if further processing is required.\n\n\n\n\nNote\n\n\nIt is recommended that all external code uses the  send()  function instead of this function, or the constructors provided by MicrobitEvent. \n\n\n\n\n\n\nint\n process( \nMicroBitEvent  \n evt,  \nbool\n urgent)\n\n\nDescription\n\n\nInternal function, used to deliver the given event to all relevant recipients. Normally, this is called once an event has been removed from the event queue.\n\n\nParameters\n\n\n\n\nMicroBitEvent  \n \nevt\n - The event to send.\n\n\nbool\n \nurgent\n - The type of listeners to process (optional). If set to true, only listeners defined as urgent and non-blocking will be processed otherwise, all other (standard) listeners will be processed. Defaults to false.\n\n\n\n\nReturns\n\n\n1 if all matching listeners were processed, 0 if further processing is required.\n\n\n\n\nNote\n\n\nIt is recommended that all external code uses the  send()  function instead of this function, or the constructors provided by MicrobitEvent. \n\n\n\n\nelementAt\n\n\n\n\nMicroBitListener\n elementAt( \nint\n n)\n\n\nDescription\n\n\nReturns the microBitListener with the given position in our list.\n\n\nParameters\n\n\n\n\nint\n \nn\n - The position in the list to return.\n\n\n\n\nReturns\n\n\nthe  MicroBitListener  at postion n in the list, or NULL if the position is invalid. \n\n\nadd\n\n\n\n\nint\n add( \nMicroBitListener  *\n newListener)\n\n\nDescription\n\n\nAdd the given  MicroBitListener\n\n\nParameters\n\n\n\n\nMicroBitListener  \n \nnewListener*\n\n\n\n\nReturns\n\n\nMICROBIT_OK if the listener is valid, MICROBIT_INVALID_PARAMETER otherwise. \n\n\nremove\n\n\n\n\nint\n remove( \nMicroBitListener  *\n newListener)\n\n\nDescription\n\n\nRemove the given  MicroBitListener\n\n\nParameters\n\n\n\n\nMicroBitListener  \n \nnewListener*\n\n\n\n\nReturns\n\n\nMICROBIT_OK if the listener is valid, MICROBIT_INVALID_PARAMETER otherwise.", 
            "title": "messageBus"
        }, 
        {
            "location": "/ubit/messageBus/#ubitmessagebus", 
            "text": "", 
            "title": "uBit.messageBus"
        }, 
        {
            "location": "/ubit/messageBus/#overview", 
            "text": "The micro:bit has an eventing model that can notfy user code when specific things happen on the micro:bit. For \nexample, the MicroBitAccelerometer will raise events to indicate that the\nmicro:bit has be been shaken, or is in freefall. MicroBitButton will send events on a range of button up, down, click and hold events. \nProgrammers are also free (in fact, encouraged!) to send their own events whenever they feel it would be useful.", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/messageBus/#registering-an-event-handler", 
            "text": "The MicroBitMessgeBus records which events your program is interested in, and delivers those MicroBitEvents to your program as they occur\nthrough a defined  event handler .  You do this through the MicroBitMessageBus  listen  function. This lets you attach a callback\nto a funciton when a specified event (or events) occur. You can also control the queuing and threading model used for your callbck funciton\non a per event handler basis.  This may sound complex at first, but it is actually very simple. For example, to find out when button A is clicked, write some code like this:  void onButtonA(MicroBitEvent e)\n{\n    uBit.display.print( A );\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n}  Now, whenever the MICROBIT_BUTTON_EVT_CLICK event is raise by MICROBIT_ID_BUTTON_A, your code inside function 'onButtonA' will be automatically run. \nYou can call listen as many times as you want to attached functions to each of the events that are useful for your program.", 
            "title": "Registering an event handler"
        }, 
        {
            "location": "/ubit/messageBus/#wildcard-events", 
            "text": "Sometimes though, you want to capture all events genareted by some component. For example, you might want to know when any chages in a button has happened. \nIn this case, there is a special event value called 'MICROBIT_EVT_ANY'. If you call listen with this value, then ALL events from the given source component will be delivered to your function.\nYou can find out which ones by looking at the MicroBitEvent delivered to your function - it contains the source and value variable of the event. For example, you could write\na program like this:  void onButtonA(MicroBitEvent e)\n{\n    if (e.value == MICROBIT_BUTTON_EVT_CLICK)\n        uBit.display.scroll( CLICK );\n\n    if (e.value == MICROBIT_BUTTON_EVT_DOWN)\n        uBit.display.scroll( DOWN );\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_EVT_ANY, onButtonA);\n}  If you  REALLY  want even more events, there is also a MICROBIT_ID_ANY source, that allows you to attach a function to event generated from any component... Use this\nsparingly though, as this could be quite a lot of events! e.g. The following code would attach the onEvent function to receive all the events from the whole runtime:  void onEvent(MicroBitEvent e)\n{\n    uBit.display.scroll( SOMETHING HAPPENED! );\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_ANY, MICROBIT_EVT_ANY, onEvent);\n}", 
            "title": "Wildcard Events"
        }, 
        {
            "location": "/ubit/messageBus/#defining-a-threading-mode", 
            "text": "Whenever you register a listener, you may choose the threading mode used with that handler. Every event handler can have its own threading mode, that defines when your handler\nwill be executed, and how it will react to receiving multiple events. There are four permissable modes for event handlers. These are:     Threading mode  Brief Description      MESSAGE_BUS_LISTENER_IMMEDIATE  Handler is called directly from the code raising the event. Event handler is  not  permitted to block.    MESSAGE_BUS_LISTENER_DROP_IF_BUSY  Handler is executed through its own fiber. If another event arrives whilst the previous event is still being proessed, the new event will be silently dropped.    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY  Handler is executed though its own fiber. If another event arrives, it is queued, and the event handler will immediately be called again once processing is complete. (default)    MESSAGE_BUS_LISTENER_REENTRANT  Every event is executed in its own fiber. if another event arrives, it is handled concurrently in its own fiber.     These various modes provide great flexibility in how the runtime can be used to support higher level languages and applications. For example, MESSAGE_BUS_LISTENER_IMMEDIATE is ideal for very simple, lightweight handlers, as this will provide very timely response to events with a low processing overhead. However, it is easy to cause side effects on other parts of the code if it doesn not return promptly. MESSAGE_BUS_LISTENER_DROP_IF_BUSY provide semantics identical to the Scratch programming language, so can be used to build easy to understand, asynchronous environmnets. MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY provides similar semantics, but with tolerance to avoiding loss of high frequency events. MESSAGE_BUS_LISTENER_REENTRANT provides guaranteed causal ordering and improved concurrency, but at the cost of additonal complexity and RAM.  You can define the threading mode you want to use on a per event handler basis as an optional final parameter to the listen funciton. For example:  bool pressed = false;\n\nvoid onButtonA(MicroBitEvent e)\n{\n    pressed = true;\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA, MESSAGE_BUS_LISTENER_IMMEDIATE);\n}", 
            "title": "Defining a Threading Mode"
        }, 
        {
            "location": "/ubit/messageBus/#c-event-handlers", 
            "text": "It is also posible to write event handlers as C++ member functions. If you don't know what this means, then don't worry, as that also means you won't need it. :-)\nFor those programmers who do like to write C++, you can use a variation of the  listen  funciton to register you member funciton event handler. This takes the same form as\nthe examples above, but with an adiditonal parameter to specify the object to call the method on. You also need to specifiy your event handler using legal C++ syntax.   For example, you can write code like this to register an event handler in your own class:  MyCoolObject::onButtonPressed(MicroBitEvent e)\n{\n    uBit.display.print( A );\n}\n\nMyCoolObject::MyCoolObject()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, this,  MyCoolObject::onButtonPressed);\n}  Again, it is also possible to a threading mode as an optional final parameter:  MyCoolObject::onButtonPressed(MicroBitEvent e)\n{\n    uBit.display.print( A );\n}\n\nMyCoolObject::MyCoolObject()\n{\n    uBit.messageBus.listen(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, this,  MyCoolObject::onButtonPressed, MESSAGE_BUS_LISTENER_IMMEDIATE);\n}", 
            "title": "C++ Event Handlers"
        }, 
        {
            "location": "/ubit/messageBus/#removing-event-handlers", 
            "text": "Event handlers can be dynamically removed from the message bus as well as added. To do this, use the  ignore  function. This takes precisely the same parameters as the\nlisten function, except that the threading mode argument is never used.  For example, to remove the event handlers shown above:      uBit.messageBus.ignore(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, onButtonA);\n    uBit.messageBus.ignore(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, this,  MyCoolObject::onButtonPressed);", 
            "title": "Removing Event Handlers"
        }, 
        {
            "location": "/ubit/messageBus/#message-bus-id", 
            "text": "Constant  Value      MICROBIT_ID_MESSAGE_BUS_LISTENER  1021      The message bus will send a MICROBIT_ID_MESSAGE_BUS_LISTENER event whenever a new listener is added to the message bus. This event allows other parts of the system to detect when interactions are\ntaking place with a component. This is primarily used as a power management mechanism - allowing on demand activation of hardware when necessary.", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/messageBus/#message-bus-events", 
            "text": "Constant  Value      Message Bus ID of listener  1-65535", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/messageBus/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/messageBus/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/messageBus/#microbitmessagebus", 
            "text": "", 
            "title": "MicroBitMessageBus()"
        }, 
        {
            "location": "/ubit/messageBus/#description", 
            "text": "Default constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#send", 
            "text": "", 
            "title": "send"
        }, 
        {
            "location": "/ubit/messageBus/#int-send-microbitevent-evt", 
            "text": "", 
            "title": "int send( MicroBitEvent evt)"
        }, 
        {
            "location": "/ubit/messageBus/#description_1", 
            "text": "Queues the given event to be sent to all registered recipients.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters", 
            "text": "MicroBitEvent   evt  - The event to send.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#example", 
            "text": "MicroBitMessageBus bus; \n\n // Creates and sends the MicroBitEvent using bus. \n MicrobitEvent evt(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK); \n\n // Creates the MicrobitEvent, but delays the sending of that event. \n MicrobitEvent evt1(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK, CREATE_ONLY); \n\n bus.send(evt1); \n\n // This has the same effect! \n evt1.fire()", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/messageBus/#process", 
            "text": "", 
            "title": "process"
        }, 
        {
            "location": "/ubit/messageBus/#int-process-microbitevent-evt", 
            "text": "", 
            "title": "int process( MicroBitEvent  &amp; evt)"
        }, 
        {
            "location": "/ubit/messageBus/#description_2", 
            "text": "Internal function, used to deliver the given event to all relevant recipients. Normally, this is called once an event has been removed from the event queue.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_1", 
            "text": "MicroBitEvent     evt  - The event to send.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns", 
            "text": "1 if all matching listeners were processed, 0 if further processing is required.   Note  It is recommended that all external code uses the  send()  function instead of this function, or the constructors provided by MicrobitEvent.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#int-process-microbitevent-evt-bool-urgent", 
            "text": "", 
            "title": "int process( MicroBitEvent  &amp; evt,  bool urgent)"
        }, 
        {
            "location": "/ubit/messageBus/#description_3", 
            "text": "Internal function, used to deliver the given event to all relevant recipients. Normally, this is called once an event has been removed from the event queue.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_2", 
            "text": "MicroBitEvent     evt  - The event to send.  bool   urgent  - The type of listeners to process (optional). If set to true, only listeners defined as urgent and non-blocking will be processed otherwise, all other (standard) listeners will be processed. Defaults to false.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_1", 
            "text": "1 if all matching listeners were processed, 0 if further processing is required.   Note  It is recommended that all external code uses the  send()  function instead of this function, or the constructors provided by MicrobitEvent.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#elementat", 
            "text": "", 
            "title": "elementAt"
        }, 
        {
            "location": "/ubit/messageBus/#microbitlistener-elementat-int-n", 
            "text": "", 
            "title": "MicroBitListener elementAt( int n)"
        }, 
        {
            "location": "/ubit/messageBus/#description_4", 
            "text": "Returns the microBitListener with the given position in our list.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_3", 
            "text": "int   n  - The position in the list to return.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_2", 
            "text": "the  MicroBitListener  at postion n in the list, or NULL if the position is invalid.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#add", 
            "text": "", 
            "title": "add"
        }, 
        {
            "location": "/ubit/messageBus/#int-add-microbitlistener-newlistener", 
            "text": "", 
            "title": "int add( MicroBitListener  * newListener)"
        }, 
        {
            "location": "/ubit/messageBus/#description_5", 
            "text": "Add the given  MicroBitListener", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_4", 
            "text": "MicroBitListener     newListener*", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_3", 
            "text": "MICROBIT_OK if the listener is valid, MICROBIT_INVALID_PARAMETER otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/messageBus/#remove", 
            "text": "", 
            "title": "remove"
        }, 
        {
            "location": "/ubit/messageBus/#int-remove-microbitlistener-newlistener", 
            "text": "", 
            "title": "int remove( MicroBitListener  * newListener)"
        }, 
        {
            "location": "/ubit/messageBus/#description_6", 
            "text": "Remove the given  MicroBitListener", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/messageBus/#parameters_5", 
            "text": "MicroBitListener     newListener*", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/messageBus/#returns_4", 
            "text": "MICROBIT_OK if the listener is valid, MICROBIT_INVALID_PARAMETER otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/button/", 
            "text": "Buttons\n\n\nOverview\n\n\nThe micro:bit has two forward facing buttons either side of the display, \nbuttonA\n\nand \nbuttonB\n. These are intuitively exposed on the \nMicroBit\n object as \nuBit.buttonA\n\nand \nuBit.buttonB\n. A third button, \nuBit.buttonAB\n is used to detect the combined\ninput of \nbuttonA\n and \nbuttonB\n, and is an instance of the class \nMicroBitMultiButton\n.\n\n\nHardware buttons are notoriously renowned for generating multiple open/close transitions\nfor what a user perceives as a single press, which can make depending on the raw input\nof a button unreliable. To combat this, a technique called 'debouncing' is used, which\nperiodically polls the state of the button, when a transition from open to close\n(and vice versa) is detected. Through periodically polling the button, we get a\nmore accurate representation of the state of a button.\n\n\nMicroBitButton\ns and \nMicroBitMultiButton\ns are debounced in\nsoftware and provide a number of events that can be used to detect different\nvariations of presses.\n\n\nThe \nMicroBitButton\n debouncing mechanism is used to provide resistive touch sensing on \nMicroBitPin\ns\nand could also be used on external 'button-like' input if required.\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_BUTTON_A\n\n\n1\n\n\n\n\n\n\nMICROBIT_ID_BUTTON_B\n\n\n2\n\n\n\n\n\n\n\n\nMessage Bus Events\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOWN\n\n\n1\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_UP\n\n\n2\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_CLICK\n\n\n3\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_LONG_CLICK\n\n\n4\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_HOLD\n\n\n5\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOUBLE_CLICK\n\n\n6\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitButton( \nPinName\n name,  \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nPinName\n \nname\n - the physical pin on the processor that should be used as input.\n\n\nuint16_t\n \nid\n - the ID of the new  MicroBitButton  object.\n\n\n\n\nExample\n\n\n buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A); \n\n\n\n\n\n\nMicroBitButton( \nPinName\n name,  \nuint16_t\n id,  \nMicroBitButtonEventConfiguration\n eventConfiguration)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nPinName\n \nname\n - the physical pin on the processor that should be used as input.\n\n\nuint16_t\n \nid\n - the ID of the new  MicroBitButton  object.\n\n\nMicroBitButtonEventConfiguration\n \neventConfiguration\n - Configures the events that will be generated by this  MicroBitButton  instance. Defaults to MICROBIT_BUTTON_ALL_EVENTS.\n\n\n\n\nExample\n\n\n buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A); \n\n\n\n\n\n\nMicroBitButton( \nPinName\n name,  \nuint16_t\n id,  \nMicroBitButtonEventConfiguration\n eventConfiguration,  \nPinMode\n mode)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nPinName\n \nname\n - the physical pin on the processor that should be used as input.\n\n\nuint16_t\n \nid\n - the ID of the new  MicroBitButton  object.\n\n\nMicroBitButtonEventConfiguration\n \neventConfiguration\n - Configures the events that will be generated by this  MicroBitButton  instance. Defaults to MICROBIT_BUTTON_ALL_EVENTS.\n\n\nPinMode\n \nmode\n - the configuration of internal pullups/pulldowns, as defined in the mbed PinMode class. PullNone by default.\n\n\n\n\nExample\n\n\n buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A); \n\n\n\n\nisPressed\n\n\n\n\nint\n isPressed()\n\n\nDescription\n\n\nTests if this Button is currently pressed.\n\n\nReturns\n\n\n1 if this button is pressed, 0 otherwise. \n\n\nExample\n\n\n if(buttonA.isPressed()) \n display.scroll(\nPressed!\n); \n\n\n\n\nsetEventConfiguration\n\n\n\n\nvoid\n setEventConfiguration( \nMicroBitButtonEventConfiguration\n config)\n\n\nDescription\n\n\nChanges the event configuration used by this button to the given MicroBitButtonEventConfiguration.\n\n\nParameters\n\n\n\n\nMicroBitButtonEventConfiguration\n \nconfig\n - The new configuration for this button. Legal values are MICROBIT_BUTTON_ALL_EVENTS or MICROBIT_BUTTON_SIMPLE_EVENTS.\n\n\n\n\nExample\n\n\n // Configure a button to generate all possible events. \n buttonA.setEventConfiguration(MICROBIT_BUTTON_ALL_EVENTS); \n\n // Configure a button to suppress MICROBIT_BUTTON_EVT_CLICK and MICROBIT_BUTTON_EVT_LONG_CLICK events. \n buttonA.setEventConfiguration(MICROBIT_BUTTON_SIMPLE_EVENTS);", 
            "title": "buttons"
        }, 
        {
            "location": "/ubit/button/#buttons", 
            "text": "", 
            "title": "Buttons"
        }, 
        {
            "location": "/ubit/button/#overview", 
            "text": "The micro:bit has two forward facing buttons either side of the display,  buttonA \nand  buttonB . These are intuitively exposed on the  MicroBit  object as  uBit.buttonA \nand  uBit.buttonB . A third button,  uBit.buttonAB  is used to detect the combined\ninput of  buttonA  and  buttonB , and is an instance of the class  MicroBitMultiButton .  Hardware buttons are notoriously renowned for generating multiple open/close transitions\nfor what a user perceives as a single press, which can make depending on the raw input\nof a button unreliable. To combat this, a technique called 'debouncing' is used, which\nperiodically polls the state of the button, when a transition from open to close\n(and vice versa) is detected. Through periodically polling the button, we get a\nmore accurate representation of the state of a button.  MicroBitButton s and  MicroBitMultiButton s are debounced in\nsoftware and provide a number of events that can be used to detect different\nvariations of presses.  The  MicroBitButton  debouncing mechanism is used to provide resistive touch sensing on  MicroBitPin s\nand could also be used on external 'button-like' input if required.", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/button/#message-bus-id", 
            "text": "Constant  Value      MICROBIT_ID_BUTTON_A  1    MICROBIT_ID_BUTTON_B  2", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/button/#message-bus-events", 
            "text": "Constant  Value      MICROBIT_BUTTON_EVT_DOWN  1    MICROBIT_BUTTON_EVT_UP  2    MICROBIT_BUTTON_EVT_CLICK  3    MICROBIT_BUTTON_EVT_LONG_CLICK  4    MICROBIT_BUTTON_EVT_HOLD  5    MICROBIT_BUTTON_EVT_DOUBLE_CLICK  6", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/button/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/button/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/button/#microbitbutton-pinname-name-uint16_t-id", 
            "text": "", 
            "title": "MicroBitButton( PinName name,  uint16_t id)"
        }, 
        {
            "location": "/ubit/button/#description", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/button/#parameters", 
            "text": "PinName   name  - the physical pin on the processor that should be used as input.  uint16_t   id  - the ID of the new  MicroBitButton  object.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/button/#example", 
            "text": "buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/button/#microbitbutton-pinname-name-uint16_t-id-microbitbuttoneventconfiguration-eventconfiguration", 
            "text": "", 
            "title": "MicroBitButton( PinName name,  uint16_t id,  MicroBitButtonEventConfiguration eventConfiguration)"
        }, 
        {
            "location": "/ubit/button/#description_1", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/button/#parameters_1", 
            "text": "PinName   name  - the physical pin on the processor that should be used as input.  uint16_t   id  - the ID of the new  MicroBitButton  object.  MicroBitButtonEventConfiguration   eventConfiguration  - Configures the events that will be generated by this  MicroBitButton  instance. Defaults to MICROBIT_BUTTON_ALL_EVENTS.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/button/#example_1", 
            "text": "buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/button/#microbitbutton-pinname-name-uint16_t-id-microbitbuttoneventconfiguration-eventconfiguration-pinmode-mode", 
            "text": "", 
            "title": "MicroBitButton( PinName name,  uint16_t id,  MicroBitButtonEventConfiguration eventConfiguration,  PinMode mode)"
        }, 
        {
            "location": "/ubit/button/#description_2", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/button/#parameters_2", 
            "text": "PinName   name  - the physical pin on the processor that should be used as input.  uint16_t   id  - the ID of the new  MicroBitButton  object.  MicroBitButtonEventConfiguration   eventConfiguration  - Configures the events that will be generated by this  MicroBitButton  instance. Defaults to MICROBIT_BUTTON_ALL_EVENTS.  PinMode   mode  - the configuration of internal pullups/pulldowns, as defined in the mbed PinMode class. PullNone by default.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/button/#example_2", 
            "text": "buttonA(MICROBIT_PIN_BUTTON_A, MICROBIT_ID_BUTTON_A);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/button/#ispressed", 
            "text": "", 
            "title": "isPressed"
        }, 
        {
            "location": "/ubit/button/#int-ispressed", 
            "text": "", 
            "title": "int isPressed()"
        }, 
        {
            "location": "/ubit/button/#description_3", 
            "text": "Tests if this Button is currently pressed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/button/#returns", 
            "text": "1 if this button is pressed, 0 otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/button/#example_3", 
            "text": "if(buttonA.isPressed()) \n display.scroll( Pressed! );", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/button/#seteventconfiguration", 
            "text": "", 
            "title": "setEventConfiguration"
        }, 
        {
            "location": "/ubit/button/#void-seteventconfiguration-microbitbuttoneventconfiguration-config", 
            "text": "", 
            "title": "void setEventConfiguration( MicroBitButtonEventConfiguration config)"
        }, 
        {
            "location": "/ubit/button/#description_4", 
            "text": "Changes the event configuration used by this button to the given MicroBitButtonEventConfiguration.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/button/#parameters_3", 
            "text": "MicroBitButtonEventConfiguration   config  - The new configuration for this button. Legal values are MICROBIT_BUTTON_ALL_EVENTS or MICROBIT_BUTTON_SIMPLE_EVENTS.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/button/#example_4", 
            "text": "// Configure a button to generate all possible events. \n buttonA.setEventConfiguration(MICROBIT_BUTTON_ALL_EVENTS); \n\n // Configure a button to suppress MICROBIT_BUTTON_EVT_CLICK and MICROBIT_BUTTON_EVT_LONG_CLICK events. \n buttonA.setEventConfiguration(MICROBIT_BUTTON_SIMPLE_EVENTS);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/", 
            "text": "uBit.display\n\n\nOverview\n\n\nThe MicroBitDisplay class is a general purpose device driver for controlling LED matrix displays.\nLED matrix displays are simple, inexpensive devices that use a single LED as a display pixel. They therefore\ntend to be of relatively low resolution, but often provide visually attractive displays due to the high coherence and brightness \nof the LEDs.\n\n\nLEDs in matrix displays are connected to general purpose I/O (GPIO) pins on CPU. Although they \ncould\n be connected such that each \nLED has its own GPIO pin, this is not usually the case, as the scarce resource of GPIO pins would soon be used up.  For example, \non the micro:bit, the LED matix has 25 LEDs. If this required 25 GPIO pins, then there would be none left for anything else! \n\n\nInstead, these LEDs are controlled by 12 GPIO pins. Three of those pins provide power to LEDs, the other \nnine provide a route to ground. The pins that source power are called \nrows\n. The pins that sink power are called \ncolumns\n. \nThe following diagram shows how the 5x5 grid is connected into 3 logical 'rows' and 9 'columns': \n\n\n\n\nWhere the format is: \nROW\n.\nCOLUMN\n\n\nSo, if we wanted to light up the middle LED, we would need to put a HIGH voltage (logic 1) on row 2, and a LOW voltage (logic 0) on column 3. Notice that when row 2 is\nHIGH, we the value we write to the 9 column pins affect all of the LEDs 2.1 to 2.7, without affecting any of the LEDS on row 1 or row 3. Sharing GPIO pins in this way is known as multiplexing. \nMoreover, if we scan throuh the different rows fast enough - faster than the eye can see - then we can provide the illusion of all the LEDS being on at the same time! This is a technique\nknown as \npersistance of vision\n... and was also the same basis of the very first TV sets (although that did not use LEDs!).\n\n\nCapabilities\n\n\nThe MicroBitDisplay class provides a driver for a general purpose matrix display, and also several high level features that make creating animations and visual effects on the \nmicro:bit LED display easy and fun! This class lets you:\n\n\n\n\nControl the LED matrix on the micro:bit.\n\n\nUse an optimised typeface (font) so you can show upper and lower case letters, numbers of symbols on the display.\n\n\nSet Display wide or \nper-pixel\n brightness control up to 256 level per pixel.\n\n\nCreate, move, paste and animate images.\n\n\nScroll and print images and text.\n\n\nAccess the screen buffer directly, so you can manipulate individual pixels.\n\n\n\n\nUsing the Display\n\n\nWhen using the uBit obbject, the display is automatically set up, and ready for you to use. Use any or all of the functions listed in the API section below to create effects on the\nLED display. Here are a few examples to get you started though!\n\n\nScrolling Text\n\n\nSimply use the scroll function specify the message you want to scroll, and sit back and watch the result. The messgae you provide will be scrolled, pixel by pixel across the display from right to left.\nIf you take a look at the documentation for the scroll function in the API below, you will notice that you can also specify the speed of the scroll as an optional final parameter. The lower the delay, the \nfaster your text will scroll across the screen.\n\n\nuBit.display.scroll(\nHELLO!\n);\nuBit.display.scroll(\nHELLO!\n, 100);\n\n\n\n\nNotice that you can also scroll numbers (either constants of variables):\n\n\nint c = 42;\nuBit.display.scroll(c);\n\n\n\n\nPrinting Text\n\n\nSometimes it is better to show the letters/numbers in turn on the screen rather than scrolling them. If you want to do this, the 'print' function has exactly the same parameters as 'scroll', but\nwith this behaviour.  e.g.\n\n\nuBit.display.print(\nHELLO!\n);\nuBit.display.print(\nHELLO!\n, 100);\nuBit.display.print(42);\n\n\n\n\nDo notice that print behaves slightly differently if you provide a single character or numeric digit though. if you do this, the value you proviode will sty on the screen until you explicitly \nchange the screen. if you ask the runtime to print a strong with two or more characters, then each will appear in turn, then disappear. e.g. try this and you will find it stays on the screen:\n\n\nuBit.display.print(7);\n\n\n\n\nShowing Images\n\n\nIt is also possible to print and scroll bitmap images on the display. Images are represented in the runtime by using a \nMicroBitImage\n. These can easily be created, just as\nyou create any variable. Onve created, you can then provide them as a parameter to the scroll and print functions. Unlike the text based animation functions, you can also specif exactly\nwhere in the screen you would like to the image to appear - and you can even treat pixel values of zero as transparent if you like!\nSee the \nMicroBitImage page\n for more details on images, but here are a few simple examples:\n\n\n// show your smiley on the screen...\nMicroBitImage smiley(\n0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n\n);\nuBit.display.print(smiley);\n\n\n\n\n// make your smiley peep up from the bottom of the screen...\nMicroBitImage smiley(\n0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n\n);\nfor (int y=4; i\n=0; y--)\n{\n    uBit.display.paste(smiley,0,y);\n    uBit.sleep(500);\n}\n\n\n\n\n\n// scroll your smiley across the screen...\nMicroBitImage smiley(\n0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n\n);\nuBit.display.scroll(smiley);\n\n\n\n\nRunning in the Background...\n\n\nBy now you have probably noticed that the scroll, print and animate functions all wait for the effect requested to finished before returning. This is by design, to allow you to easily synchronise your programs.\nHowever, sometimes you want to launch an effect, and let it run in the background while your program does something else. For this, you can use the \nAsync\n variations of the scroll, print and animate functions. \nThese all have identical parameters and capabilities, but will return immediately. Try some of the examples above with their Async equivalents to understand this different behaviour.  For example:\n\n\n// scroll your smiley across the screen, without waiting for it to finish...\nMicroBitImage smiley(\n0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n\n);\nuBit.display.scrollAsync(smiley);\n\n\n\n\nChanging Display Mode\n\n\nThe MicroBitDisplay class supports either on/off LED disiplay, or displays where each pixel has an individual brightness value between 0 and 255. The former cost much less processor time and battery power to \noperate, so is the default. The latter does provide more useful effect though, so you can change between these modes by using the  'setDiplayMode' funciton. Valid values are:\n\n\n\n\n\n\n\n\nDisplay mode\n\n\nBrief Description\n\n\n\n\n\n\n\n\n\n\nDISPLAY_MODE_BLACK_AND_WHITE\n\n\nEach pixel can be just on or off. The brightness of all pixels is controlled by the setBrightness function.\n\n\n\n\n\n\nDISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE\n\n\nEach pixel can be just on or off, and the display driver will also sense the ambient brightness from the LEDs.\n\n\n\n\n\n\nDISPLAY_MODE_GREYSCALE\n\n\nEach pixel can independently have 256 levels of brightness.\n\n\n\n\n\n\n\n\nfor example:\n\n\n// show a smiley with bright eyes!\nMicroBitImage smiley(\n0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n32,0,0,0,32\\n0,32,32,32,0\\n\n);\nuBit.display.setDisplayMode(DISPLAY_MODE_GREYSCALE);\nuBit.display.print(smiley);\n\n\n\n\nAccessing the Display Buffer\n\n\nThe memory buffer that is used to drive the LEDs is itself a \nMicroBitImage\n. This means that you can also access and call any of the functions listed in the \nMicroBitImage API documentation\n \ndirectly on the dipslay buffer. Examples here include setPixelValue, as illustrated below, but read the above documentation link for full details. \n\n\n// set a single pixel by co-ordinate\nuBit.display.image.setPixelValue(2,2,255);\n\n\n\n\nOther Useful Functions\n\n\n\n\n'clear' will clear the screen immediately.\n\n\n'stopAnimtion' will terminate any ongoing print, scroll or animate functions.\n\n\n'setBrightness' lets you set the overall maximum brightness of the display, as a value between 1 and 255.\n\n\n'enable' and 'disable' turn on and off the display. When disabled, you can reuse many if the GPIO pins. See the \nMicroBitIO\n class for more information.\n\n\n'rotateTo' even lets you specify the orientation of the display - in case you need to use your micro:bit the wrong way up. :-)\n\n\n'readLightLevel' runs the LEDs backwards as photodiodes and tells you how bright your room is... see \nLight Sensing\n for more info!\n\n\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_DISPLAY\n\n\n6\n\n\n\n\n\n\n\n\nMessage Bus Events\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_DISPLAY_EVT_ANIMATION_COMPLETE\n\n\n1\n\n\n\n\n\n\nMICROBIT_DISPLAY_EVT_LIGHT_SENSE\n\n\n2\n\n\n\n\n\n\n\n\nNotify Events\n\n\nThese events use the notification channel \nMICROBIT_ID_NOTIFY\n, which provides\ngeneral purpose synchronisation.\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_DISPLAY_EVT_FREE\n\n\n1\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitDisplay()\n\n\nDescription\n\n\nConstructor.\n\n\nExample\n\n\n MicroBitDisplay display; \n\n\n\n\n\n\nMicroBitDisplay( \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nuint16_t\n \nid\n - The id the display should use when sending events on the MessageBus. Defaults to MICROBIT_ID_DISPLAY.\n\n\n\n\nExample\n\n\n MicroBitDisplay display; \n\n\n\n\n\n\nMicroBitDisplay( \nuint16_t\n id,  \nconst  MatrixMap  \n map)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nuint16_t\n \nid\n - The id the display should use when sending events on the MessageBus. Defaults to MICROBIT_ID_DISPLAY.\n\n\nconst  MatrixMap  \n \nmap\n - The mapping information that relates pin inputs/outputs to physical screen coordinates. Defaults to microbitMatrixMap, defined in  MicroBitMatrixMaps.h .\n\n\n\n\nExample\n\n\n MicroBitDisplay display; \n\n\n\n\nstopAnimation\n\n\n\n\nvoid\n stopAnimation()\n\n\nDescription\n\n\nStops any currently running animation, and any that are waiting to be displayed. \n\n\nprintCharAsync\n\n\n\n\nint\n printCharAsync( \nchar\n c)\n\n\nDescription\n\n\nPrints the given character to the display, if it is not in use.\n\n\nParameters\n\n\n\n\nchar\n \nc\n - The character to display.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY is the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n display.printAsync('p'); \n display.printAsync('p',100); \n\n\n\n\n\n\nint\n printCharAsync( \nchar\n c,  \nint\n delay)\n\n\nDescription\n\n\nPrints the given character to the display, if it is not in use.\n\n\nParameters\n\n\n\n\nchar\n \nc\n - The character to display.\n\n\nint\n \ndelay\n - Optional parameter - the time for which to show the character. Zero displays the character forever, or until the Displays next use.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY is the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n display.printAsync('p'); \n display.printAsync('p',100); \n\n\n\n\nprintAsync\n\n\n\n\nint\n printAsync( \nManagedString\n s)\n\n\nDescription\n\n\nPrints the given  ManagedString\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n display.printAsync(\nabc123\n,400); \n\n\n\n\n\n\nint\n printAsync( \nManagedString\n s,  \nint\n delay)\n\n\nDescription\n\n\nPrints the given  ManagedString\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display.\n\n\nint\n \ndelay\n - The time to delay between characters, in milliseconds. Must be \n 0. Defaults to: MICROBIT_DEFAULT_PRINT_SPEED.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n display.printAsync(\nabc123\n,400); \n\n\n\n\n\n\nint\n printAsync( \nMicroBitImage\n i)\n\n\nDescription\n\n\nPrints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display.\n\n\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.print(i,400); \n\n\n\n\n\n\nint\n printAsync( \nMicroBitImage\n i,  \nint\n x)\n\n\nDescription\n\n\nPrints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display.\n\n\nint\n \nx\n - The horizontal position on the screen to display the image. Defaults to 0.\n\n\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.print(i,400); \n\n\n\n\n\n\nint\n printAsync( \nMicroBitImage\n i,  \nint\n x,  \nint\n y)\n\n\nDescription\n\n\nPrints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display.\n\n\nint\n \nx\n - The horizontal position on the screen to display the image. Defaults to 0.\n\n\nint\n \ny\n - The vertical position on the screen to display the image. Defaults to 0.\n\n\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.print(i,400); \n\n\n\n\n\n\nint\n printAsync( \nMicroBitImage\n i,  \nint\n x,  \nint\n y,  \nint\n alpha)\n\n\nDescription\n\n\nPrints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display.\n\n\nint\n \nx\n - The horizontal position on the screen to display the image. Defaults to 0.\n\n\nint\n \ny\n - The vertical position on the screen to display the image. Defaults to 0.\n\n\nint\n \nalpha\n - Treats the brightness level '0' as transparent. Defaults to 0.\n\n\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.print(i,400); \n\n\n\n\n\n\nint\n printAsync( \nMicroBitImage\n i,  \nint\n x,  \nint\n y,  \nint\n alpha,  \nint\n delay)\n\n\nDescription\n\n\nPrints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display.\n\n\nint\n \nx\n - The horizontal position on the screen to display the image. Defaults to 0.\n\n\nint\n \ny\n - The vertical position on the screen to display the image. Defaults to 0.\n\n\nint\n \nalpha\n - Treats the brightness level '0' as transparent. Defaults to 0.\n\n\nint\n \ndelay\n - The time to delay between characters, in milliseconds. Defaults to 0.\n\n\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.print(i,400); \n\n\n\n\nprintChar\n\n\n\n\nint\n printChar( \nchar\n c)\n\n\nDescription\n\n\nPrints the given character to the display.\n\n\nParameters\n\n\n\n\nchar\n \nc\n - The character to display.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n display.printAsync('p'); \n display.printAsync('p',100); \n\n\n\n\n\n\nint\n printChar( \nchar\n c,  \nint\n delay)\n\n\nDescription\n\n\nPrints the given character to the display.\n\n\nParameters\n\n\n\n\nchar\n \nc\n - The character to display.\n\n\nint\n \ndelay\n - Optional parameter - the time for which to show the character. Zero displays the character forever, or until the Displays next use.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n display.printAsync('p'); \n display.printAsync('p',100); \n\n\n\n\nprint\n\n\n\n\nint\n print( \nManagedString\n s)\n\n\nDescription\n\n\nPrints the given string to the display, one character at a time.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n display.print(\nabc123\n,400); \n\n\n\n\n\n\nint\n print( \nManagedString\n s,  \nint\n delay)\n\n\nDescription\n\n\nPrints the given string to the display, one character at a time.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display.\n\n\nint\n \ndelay\n - The time to delay between characters, in milliseconds. Defaults to: MICROBIT_DEFAULT_PRINT_SPEED.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n display.print(\nabc123\n,400); \n\n\n\n\n\n\nint\n print( \nMicroBitImage\n i)\n\n\nDescription\n\n\nPrints the given image to the display. Blocks the calling thread until all the image has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.print(i,400); \n\n\n\n\n\n\nint\n print( \nMicroBitImage\n i,  \nint\n x)\n\n\nDescription\n\n\nPrints the given image to the display. Blocks the calling thread until all the image has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display.\n\n\nint\n \nx\n - The horizontal position on the screen to display the image. Defaults to 0.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.print(i,400); \n\n\n\n\n\n\nint\n print( \nMicroBitImage\n i,  \nint\n x,  \nint\n y)\n\n\nDescription\n\n\nPrints the given image to the display. Blocks the calling thread until all the image has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display.\n\n\nint\n \nx\n - The horizontal position on the screen to display the image. Defaults to 0.\n\n\nint\n \ny\n - The vertical position on the screen to display the image. Defaults to 0.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.print(i,400); \n\n\n\n\n\n\nint\n print( \nMicroBitImage\n i,  \nint\n x,  \nint\n y,  \nint\n alpha)\n\n\nDescription\n\n\nPrints the given image to the display. Blocks the calling thread until all the image has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display.\n\n\nint\n \nx\n - The horizontal position on the screen to display the image. Defaults to 0.\n\n\nint\n \ny\n - The vertical position on the screen to display the image. Defaults to 0.\n\n\nint\n \nalpha\n - Treats the brightness level '0' as transparent. Defaults to 0.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.print(i,400); \n\n\n\n\n\n\nint\n print( \nMicroBitImage\n i,  \nint\n x,  \nint\n y,  \nint\n alpha,  \nint\n delay)\n\n\nDescription\n\n\nPrints the given image to the display. Blocks the calling thread until all the image has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \ni\n - The image to display.\n\n\nint\n \nx\n - The horizontal position on the screen to display the image. Defaults to 0.\n\n\nint\n \ny\n - The vertical position on the screen to display the image. Defaults to 0.\n\n\nint\n \nalpha\n - Treats the brightness level '0' as transparent. Defaults to 0.\n\n\nint\n \ndelay\n - The time to display the image for, or zero to show the image forever. Defaults to 0.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.print(i,400); \n\n\n\n\nscrollAsync\n\n\n\n\nint\n scrollAsync( \nManagedString\n s)\n\n\nDescription\n\n\nScrolls the given string to the display, from right to left. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n display.scrollAsync(\nabc123\n,100); \n\n\n\n\n\n\nint\n scrollAsync( \nManagedString\n s,  \nint\n delay)\n\n\nDescription\n\n\nScrolls the given string to the display, from right to left. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display.\n\n\nint\n \ndelay\n - The time to delay between characters, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n display.scrollAsync(\nabc123\n,100); \n\n\n\n\n\n\nint\n scrollAsync( \nMicroBitImage\n image)\n\n\nDescription\n\n\nScrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.scrollAsync(i,100,1); \n\n\n\n\n\n\nint\n scrollAsync( \nMicroBitImage\n image,  \nint\n delay)\n\n\nDescription\n\n\nScrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display.\n\n\nint\n \ndelay\n - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.scrollAsync(i,100,1); \n\n\n\n\n\n\nint\n scrollAsync( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride)\n\n\nDescription\n\n\nScrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display.\n\n\nint\n \ndelay\n - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.\n\n\nint\n \nstride\n - The number of pixels to shift by in each update. Defaults to MICROBIT_DEFAULT_SCROLL_STRIDE.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.scrollAsync(i,100,1); \n\n\n\n\nscroll\n\n\n\n\nint\n scroll( \nManagedString\n s)\n\n\nDescription\n\n\nScrolls the given string across the display, from right to left. Blocks the calling thread until all text has been displayed.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n display.scroll(\nabc123\n,100); \n\n\n\n\n\n\nint\n scroll( \nManagedString\n s,  \nint\n delay)\n\n\nDescription\n\n\nScrolls the given string across the display, from right to left. Blocks the calling thread until all text has been displayed.\n\n\nParameters\n\n\n\n\nManagedString\n \ns\n - The string to display.\n\n\nint\n \ndelay\n - The time to delay between characters, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n display.scroll(\nabc123\n,100); \n\n\n\n\n\n\nint\n scroll( \nMicroBitImage\n image)\n\n\nDescription\n\n\nScrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.scroll(i,100,1); \n\n\n\n\n\n\nint\n scroll( \nMicroBitImage\n image,  \nint\n delay)\n\n\nDescription\n\n\nScrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display.\n\n\nint\n \ndelay\n - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.scroll(i,100,1); \n\n\n\n\n\n\nint\n scroll( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride)\n\n\nDescription\n\n\nScrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display.\n\n\nint\n \ndelay\n - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.\n\n\nint\n \nstride\n - The number of pixels to shift by in each update. Defaults to MICROBIT_DEFAULT_SCROLL_STRIDE.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicrobitImage i(\n1,1,1,1,1\\n1,1,1,1,1\\n\n); \n display.scroll(i,100,1); \n\n\n\n\nanimateAsync\n\n\n\n\nint\n animateAsync( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride)\n\n\nDescription\n\n\n\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display.\n\n\nint\n \ndelay\n - The time to delay between each update of the display, in milliseconds.\n\n\nint\n \nstride\n - The number of pixels to shift by in each update.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animateAsync(i,100,5); \n\n\n\n\n\n\nint\n animateAsync( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride,  \nint\n startingPosition)\n\n\nDescription\n\n\n\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n - The image to display.\n\n\nint\n \ndelay\n - The time to delay between each update of the display, in milliseconds.\n\n\nint\n \nstride\n - The number of pixels to shift by in each update.\n\n\nint\n \nstartingPosition\n - the starting position on the display for the animation to begin at. Defaults to MICROBIT_DISPLAY_ANIMATE_DEFAULT_POS.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animateAsync(i,100,5); \n\n\n\n\nanimate\n\n\n\n\nint\n animate( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride)\n\n\nDescription\n\n\n\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n\n\nint\n \ndelay\n - The time to delay between each update of the display, in milliseconds.\n\n\nint\n \nstride\n - The number of pixels to shift by in each update.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animate(i,100,5); \n\n\n\n\n\n\nint\n animate( \nMicroBitImage\n image,  \nint\n delay,  \nint\n stride,  \nint\n startingPosition)\n\n\nDescription\n\n\n\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.\n\n\nParameters\n\n\n\n\nMicroBitImage\n \nimage\n\n\nint\n \ndelay\n - The time to delay between each update of the display, in milliseconds.\n\n\nint\n \nstride\n - The number of pixels to shift by in each update.\n\n\nint\n \nstartingPosition\n - the starting position on the display for the animation to begin at. Defaults to MICROBIT_DISPLAY_ANIMATE_DEFAULT_POS.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animate(i,100,5); \n\n\n\n\nsetBrightness\n\n\n\n\nint\n setBrightness( \nint\n b)\n\n\nDescription\n\n\nConfigures the brightness of the display.\n\n\nParameters\n\n\n\n\nint\n \nb\n - The brightness to set the brightness to, in the range 0 - 255.\n\n\n\n\nReturns\n\n\nMICROBIT_OK, or MICROBIT_INVALID_PARAMETER\n\n\nExample\n\n\n display.setBrightness(255); //max brightness \n\n\n\n\nsetDisplayMode\n\n\n\n\nvoid\n setDisplayMode( \nDisplayMode\n mode)\n\n\nDescription\n\n\nConfigures the mode of the display.\n\n\nParameters\n\n\n\n\nDisplayMode\n \nmode\n - The mode to swap the display into. One of: DISPLAY_MODE_GREYSCALE, DISPLAY_MODE_BLACK_AND_WHITE, DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE\n\n\n\n\nExample\n\n\n display.setDisplayMode(DISPLAY_MODE_GREYSCALE); //per pixel brightness \n\n\n\n\ngetDisplayMode\n\n\n\n\nint\n getDisplayMode()\n\n\nDescription\n\n\nRetrieves the mode of the display.\n\n\nReturns\n\n\nthe current mode of the display \n\n\ngetBrightness\n\n\n\n\nint\n getBrightness()\n\n\nDescription\n\n\nFetches the current brightness of this display.\n\n\nReturns\n\n\nthe brightness of this display, in the range 0..255.\n\n\nExample\n\n\n display.getBrightness(); //the current brightness \n\n\n\n\nrotateTo\n\n\n\n\nvoid\n rotateTo( \nDisplayRotation\n position)\n\n\nDescription\n\n\nRotates the display to the given position.\n\n\nParameters\n\n\n\n\nDisplayRotation\n \nposition\n\n\n\n\nExample\n\n\n display.rotateTo(MICROBIT_DISPLAY_ROTATION_180); //rotates 180 degrees from original orientation \n\n\n\n\nenable\n\n\n\n\nvoid\n enable()\n\n\nDescription\n\n\nEnables the display, should only be called if the display is disabled.\n\n\nExample\n\n\n display.enable(); //Enables the display mechanics \n\n\n\n\n\n\nNote\n\n\nOnly enables the display if the display is currently disabled. \n\n\n\n\ndisable\n\n\n\n\nvoid\n disable()\n\n\nDescription\n\n\nDisables the display, which releases control of the GPIO pins used by the display, which are exposed on the edge connector.\n\n\nExample\n\n\n display.disable(); //disables the display \n\n\n\n\n\n\nNote\n\n\nOnly disables the display if the display is currently enabled. \n\n\n\n\nclear\n\n\n\n\nvoid\n clear()\n\n\nDescription\n\n\nClears the display of any remaining pixels.\n\n\nExample\n\n\n display.clear(); //clears the display \n\n\n\n\nsetFont\n\n\n\n\nvoid\n setFont( \nMicroBitFont\n font)\n\n\nDescription\n\n\nUpdates the font that will be used for display operations.\n\n\nParameters\n\n\n\n\nMicroBitFont\n \nfont\n - the new font that will be used to render characters.\n\n\n\n\n\n\nNote\n\n\nDEPRECATED! Please use  MicroBitFont::setSystemFont()  instead. \n\n\n\n\ngetFont\n\n\n\n\nMicroBitFont\n getFont()\n\n\nDescription\n\n\nRetrieves the font object used for rendering characters on the display.\n\n\n\n\nNote\n\n\nDEPRECATED! Please use  MicroBitFont::getSystemFont()  instead. \n\n\n\n\nscreenShot\n\n\n\n\nMicroBitImage\n screenShot()\n\n\nDescription\n\n\nCaptures the bitmap currently being rendered on the display.\n\n\nReturns\n\n\na  MicroBitImage  containing the captured data. \n\n\nreadLightLevel\n\n\n\n\nint\n readLightLevel()\n\n\nDescription\n\n\nGives a representative figure of the light level in the current environment where are micro:bit is situated.\n\n\nReturns\n\n\nan indicative light level in the range 0 - 255.\n\n\n\n\nNote\n\n\nthis will return 0 on the first call to this method, a light reading will be available after the display has activated the light sensor for the first time.", 
            "title": "display"
        }, 
        {
            "location": "/ubit/display/#ubitdisplay", 
            "text": "", 
            "title": "uBit.display"
        }, 
        {
            "location": "/ubit/display/#overview", 
            "text": "The MicroBitDisplay class is a general purpose device driver for controlling LED matrix displays.\nLED matrix displays are simple, inexpensive devices that use a single LED as a display pixel. They therefore\ntend to be of relatively low resolution, but often provide visually attractive displays due to the high coherence and brightness \nof the LEDs.  LEDs in matrix displays are connected to general purpose I/O (GPIO) pins on CPU. Although they  could  be connected such that each \nLED has its own GPIO pin, this is not usually the case, as the scarce resource of GPIO pins would soon be used up.  For example, \non the micro:bit, the LED matix has 25 LEDs. If this required 25 GPIO pins, then there would be none left for anything else!   Instead, these LEDs are controlled by 12 GPIO pins. Three of those pins provide power to LEDs, the other \nnine provide a route to ground. The pins that source power are called  rows . The pins that sink power are called  columns . \nThe following diagram shows how the 5x5 grid is connected into 3 logical 'rows' and 9 'columns':    Where the format is:  ROW . COLUMN  So, if we wanted to light up the middle LED, we would need to put a HIGH voltage (logic 1) on row 2, and a LOW voltage (logic 0) on column 3. Notice that when row 2 is\nHIGH, we the value we write to the 9 column pins affect all of the LEDs 2.1 to 2.7, without affecting any of the LEDS on row 1 or row 3. Sharing GPIO pins in this way is known as multiplexing. \nMoreover, if we scan throuh the different rows fast enough - faster than the eye can see - then we can provide the illusion of all the LEDS being on at the same time! This is a technique\nknown as  persistance of vision ... and was also the same basis of the very first TV sets (although that did not use LEDs!).", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/display/#capabilities", 
            "text": "The MicroBitDisplay class provides a driver for a general purpose matrix display, and also several high level features that make creating animations and visual effects on the \nmicro:bit LED display easy and fun! This class lets you:   Control the LED matrix on the micro:bit.  Use an optimised typeface (font) so you can show upper and lower case letters, numbers of symbols on the display.  Set Display wide or  per-pixel  brightness control up to 256 level per pixel.  Create, move, paste and animate images.  Scroll and print images and text.  Access the screen buffer directly, so you can manipulate individual pixels.", 
            "title": "Capabilities"
        }, 
        {
            "location": "/ubit/display/#using-the-display", 
            "text": "When using the uBit obbject, the display is automatically set up, and ready for you to use. Use any or all of the functions listed in the API section below to create effects on the\nLED display. Here are a few examples to get you started though!", 
            "title": "Using the Display"
        }, 
        {
            "location": "/ubit/display/#scrolling-text", 
            "text": "Simply use the scroll function specify the message you want to scroll, and sit back and watch the result. The messgae you provide will be scrolled, pixel by pixel across the display from right to left.\nIf you take a look at the documentation for the scroll function in the API below, you will notice that you can also specify the speed of the scroll as an optional final parameter. The lower the delay, the \nfaster your text will scroll across the screen.  uBit.display.scroll( HELLO! );\nuBit.display.scroll( HELLO! , 100);  Notice that you can also scroll numbers (either constants of variables):  int c = 42;\nuBit.display.scroll(c);", 
            "title": "Scrolling Text"
        }, 
        {
            "location": "/ubit/display/#printing-text", 
            "text": "Sometimes it is better to show the letters/numbers in turn on the screen rather than scrolling them. If you want to do this, the 'print' function has exactly the same parameters as 'scroll', but\nwith this behaviour.  e.g.  uBit.display.print( HELLO! );\nuBit.display.print( HELLO! , 100);\nuBit.display.print(42);  Do notice that print behaves slightly differently if you provide a single character or numeric digit though. if you do this, the value you proviode will sty on the screen until you explicitly \nchange the screen. if you ask the runtime to print a strong with two or more characters, then each will appear in turn, then disappear. e.g. try this and you will find it stays on the screen:  uBit.display.print(7);", 
            "title": "Printing Text"
        }, 
        {
            "location": "/ubit/display/#showing-images", 
            "text": "It is also possible to print and scroll bitmap images on the display. Images are represented in the runtime by using a  MicroBitImage . These can easily be created, just as\nyou create any variable. Onve created, you can then provide them as a parameter to the scroll and print functions. Unlike the text based animation functions, you can also specif exactly\nwhere in the screen you would like to the image to appear - and you can even treat pixel values of zero as transparent if you like!\nSee the  MicroBitImage page  for more details on images, but here are a few simple examples:  // show your smiley on the screen...\nMicroBitImage smiley( 0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n );\nuBit.display.print(smiley);  // make your smiley peep up from the bottom of the screen...\nMicroBitImage smiley( 0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n );\nfor (int y=4; i =0; y--)\n{\n    uBit.display.paste(smiley,0,y);\n    uBit.sleep(500);\n}  // scroll your smiley across the screen...\nMicroBitImage smiley( 0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n );\nuBit.display.scroll(smiley);", 
            "title": "Showing Images"
        }, 
        {
            "location": "/ubit/display/#running-in-the-background", 
            "text": "By now you have probably noticed that the scroll, print and animate functions all wait for the effect requested to finished before returning. This is by design, to allow you to easily synchronise your programs.\nHowever, sometimes you want to launch an effect, and let it run in the background while your program does something else. For this, you can use the  Async  variations of the scroll, print and animate functions. \nThese all have identical parameters and capabilities, but will return immediately. Try some of the examples above with their Async equivalents to understand this different behaviour.  For example:  // scroll your smiley across the screen, without waiting for it to finish...\nMicroBitImage smiley( 0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n255,0,0,0,255\\n0,255,255,255,0\\n );\nuBit.display.scrollAsync(smiley);", 
            "title": "Running in the Background..."
        }, 
        {
            "location": "/ubit/display/#changing-display-mode", 
            "text": "The MicroBitDisplay class supports either on/off LED disiplay, or displays where each pixel has an individual brightness value between 0 and 255. The former cost much less processor time and battery power to \noperate, so is the default. The latter does provide more useful effect though, so you can change between these modes by using the  'setDiplayMode' funciton. Valid values are:     Display mode  Brief Description      DISPLAY_MODE_BLACK_AND_WHITE  Each pixel can be just on or off. The brightness of all pixels is controlled by the setBrightness function.    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE  Each pixel can be just on or off, and the display driver will also sense the ambient brightness from the LEDs.    DISPLAY_MODE_GREYSCALE  Each pixel can independently have 256 levels of brightness.     for example:  // show a smiley with bright eyes!\nMicroBitImage smiley( 0,255,0,255, 0\\n0,255,0,255,0\\n0,0,0,0,0\\n32,0,0,0,32\\n0,32,32,32,0\\n );\nuBit.display.setDisplayMode(DISPLAY_MODE_GREYSCALE);\nuBit.display.print(smiley);", 
            "title": "Changing Display Mode"
        }, 
        {
            "location": "/ubit/display/#accessing-the-display-buffer", 
            "text": "The memory buffer that is used to drive the LEDs is itself a  MicroBitImage . This means that you can also access and call any of the functions listed in the  MicroBitImage API documentation  \ndirectly on the dipslay buffer. Examples here include setPixelValue, as illustrated below, but read the above documentation link for full details.   // set a single pixel by co-ordinate\nuBit.display.image.setPixelValue(2,2,255);", 
            "title": "Accessing the Display Buffer"
        }, 
        {
            "location": "/ubit/display/#other-useful-functions", 
            "text": "'clear' will clear the screen immediately.  'stopAnimtion' will terminate any ongoing print, scroll or animate functions.  'setBrightness' lets you set the overall maximum brightness of the display, as a value between 1 and 255.  'enable' and 'disable' turn on and off the display. When disabled, you can reuse many if the GPIO pins. See the  MicroBitIO  class for more information.  'rotateTo' even lets you specify the orientation of the display - in case you need to use your micro:bit the wrong way up. :-)  'readLightLevel' runs the LEDs backwards as photodiodes and tells you how bright your room is... see  Light Sensing  for more info!", 
            "title": "Other Useful Functions"
        }, 
        {
            "location": "/ubit/display/#message-bus-id", 
            "text": "Constant  Value      MICROBIT_ID_DISPLAY  6", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/display/#message-bus-events", 
            "text": "Constant  Value      MICROBIT_DISPLAY_EVT_ANIMATION_COMPLETE  1    MICROBIT_DISPLAY_EVT_LIGHT_SENSE  2", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/display/#notify-events", 
            "text": "These events use the notification channel  MICROBIT_ID_NOTIFY , which provides\ngeneral purpose synchronisation.     Constant  Value      MICROBIT_DISPLAY_EVT_FREE  1", 
            "title": "Notify Events"
        }, 
        {
            "location": "/ubit/display/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/display/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/display/#microbitdisplay", 
            "text": "", 
            "title": "MicroBitDisplay()"
        }, 
        {
            "location": "/ubit/display/#description", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#example", 
            "text": "MicroBitDisplay display;", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#microbitdisplay-uint16_t-id", 
            "text": "", 
            "title": "MicroBitDisplay( uint16_t id)"
        }, 
        {
            "location": "/ubit/display/#description_1", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters", 
            "text": "uint16_t   id  - The id the display should use when sending events on the MessageBus. Defaults to MICROBIT_ID_DISPLAY.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_1", 
            "text": "MicroBitDisplay display;", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#microbitdisplay-uint16_t-id-const-matrixmap-map", 
            "text": "", 
            "title": "MicroBitDisplay( uint16_t id,  const  MatrixMap  &amp; map)"
        }, 
        {
            "location": "/ubit/display/#description_2", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_1", 
            "text": "uint16_t   id  - The id the display should use when sending events on the MessageBus. Defaults to MICROBIT_ID_DISPLAY.  const  MatrixMap     map  - The mapping information that relates pin inputs/outputs to physical screen coordinates. Defaults to microbitMatrixMap, defined in  MicroBitMatrixMaps.h .", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_2", 
            "text": "MicroBitDisplay display;", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#stopanimation", 
            "text": "", 
            "title": "stopAnimation"
        }, 
        {
            "location": "/ubit/display/#void-stopanimation", 
            "text": "", 
            "title": "void stopAnimation()"
        }, 
        {
            "location": "/ubit/display/#description_3", 
            "text": "Stops any currently running animation, and any that are waiting to be displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#printcharasync", 
            "text": "", 
            "title": "printCharAsync"
        }, 
        {
            "location": "/ubit/display/#int-printcharasync-char-c", 
            "text": "", 
            "title": "int printCharAsync( char c)"
        }, 
        {
            "location": "/ubit/display/#description_4", 
            "text": "Prints the given character to the display, if it is not in use.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_2", 
            "text": "char   c  - The character to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns", 
            "text": "MICROBIT_OK, MICROBIT_BUSY is the screen is in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_3", 
            "text": "display.printAsync('p'); \n display.printAsync('p',100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printcharasync-char-c-int-delay", 
            "text": "", 
            "title": "int printCharAsync( char c,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_5", 
            "text": "Prints the given character to the display, if it is not in use.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_3", 
            "text": "char   c  - The character to display.  int   delay  - Optional parameter - the time for which to show the character. Zero displays the character forever, or until the Displays next use.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_1", 
            "text": "MICROBIT_OK, MICROBIT_BUSY is the screen is in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_4", 
            "text": "display.printAsync('p'); \n display.printAsync('p',100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#printasync", 
            "text": "", 
            "title": "printAsync"
        }, 
        {
            "location": "/ubit/display/#int-printasync-managedstring-s", 
            "text": "", 
            "title": "int printAsync( ManagedString s)"
        }, 
        {
            "location": "/ubit/display/#description_6", 
            "text": "Prints the given  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_4", 
            "text": "ManagedString   s  - The string to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_2", 
            "text": "MICROBIT_OK, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_5", 
            "text": "display.printAsync( abc123 ,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printasync-managedstring-s-int-delay", 
            "text": "", 
            "title": "int printAsync( ManagedString s,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_7", 
            "text": "Prints the given  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_5", 
            "text": "ManagedString   s  - The string to display.  int   delay  - The time to delay between characters, in milliseconds. Must be   0. Defaults to: MICROBIT_DEFAULT_PRINT_SPEED.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_3", 
            "text": "MICROBIT_OK, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_6", 
            "text": "display.printAsync( abc123 ,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printasync-microbitimage-i", 
            "text": "", 
            "title": "int printAsync( MicroBitImage i)"
        }, 
        {
            "location": "/ubit/display/#description_8", 
            "text": "Prints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_6", 
            "text": "MicroBitImage   i  - The image to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_7", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printasync-microbitimage-i-int-x", 
            "text": "", 
            "title": "int printAsync( MicroBitImage i,  int x)"
        }, 
        {
            "location": "/ubit/display/#description_9", 
            "text": "Prints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_7", 
            "text": "MicroBitImage   i  - The image to display.  int   x  - The horizontal position on the screen to display the image. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_8", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printasync-microbitimage-i-int-x-int-y", 
            "text": "", 
            "title": "int printAsync( MicroBitImage i,  int x,  int y)"
        }, 
        {
            "location": "/ubit/display/#description_10", 
            "text": "Prints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_8", 
            "text": "MicroBitImage   i  - The image to display.  int   x  - The horizontal position on the screen to display the image. Defaults to 0.  int   y  - The vertical position on the screen to display the image. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_9", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printasync-microbitimage-i-int-x-int-y-int-alpha", 
            "text": "", 
            "title": "int printAsync( MicroBitImage i,  int x,  int y,  int alpha)"
        }, 
        {
            "location": "/ubit/display/#description_11", 
            "text": "Prints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_9", 
            "text": "MicroBitImage   i  - The image to display.  int   x  - The horizontal position on the screen to display the image. Defaults to 0.  int   y  - The vertical position on the screen to display the image. Defaults to 0.  int   alpha  - Treats the brightness level '0' as transparent. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_10", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printasync-microbitimage-i-int-x-int-y-int-alpha-int-delay", 
            "text": "", 
            "title": "int printAsync( MicroBitImage i,  int x,  int y,  int alpha,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_12", 
            "text": "Prints the given image to the display, if the display is not in use. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_10", 
            "text": "MicroBitImage   i  - The image to display.  int   x  - The horizontal position on the screen to display the image. Defaults to 0.  int   y  - The vertical position on the screen to display the image. Defaults to 0.  int   alpha  - Treats the brightness level '0' as transparent. Defaults to 0.  int   delay  - The time to delay between characters, in milliseconds. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_11", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#printchar", 
            "text": "", 
            "title": "printChar"
        }, 
        {
            "location": "/ubit/display/#int-printchar-char-c", 
            "text": "", 
            "title": "int printChar( char c)"
        }, 
        {
            "location": "/ubit/display/#description_13", 
            "text": "Prints the given character to the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_11", 
            "text": "char   c  - The character to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_4", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_12", 
            "text": "display.printAsync('p'); \n display.printAsync('p',100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-printchar-char-c-int-delay", 
            "text": "", 
            "title": "int printChar( char c,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_14", 
            "text": "Prints the given character to the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_12", 
            "text": "char   c  - The character to display.  int   delay  - Optional parameter - the time for which to show the character. Zero displays the character forever, or until the Displays next use.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_5", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_13", 
            "text": "display.printAsync('p'); \n display.printAsync('p',100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#print", 
            "text": "", 
            "title": "print"
        }, 
        {
            "location": "/ubit/display/#int-print-managedstring-s", 
            "text": "", 
            "title": "int print( ManagedString s)"
        }, 
        {
            "location": "/ubit/display/#description_15", 
            "text": "Prints the given string to the display, one character at a time.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_13", 
            "text": "ManagedString   s  - The string to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_6", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_14", 
            "text": "display.print( abc123 ,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-print-managedstring-s-int-delay", 
            "text": "", 
            "title": "int print( ManagedString s,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_16", 
            "text": "Prints the given string to the display, one character at a time.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_14", 
            "text": "ManagedString   s  - The string to display.  int   delay  - The time to delay between characters, in milliseconds. Defaults to: MICROBIT_DEFAULT_PRINT_SPEED.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_7", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_15", 
            "text": "display.print( abc123 ,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-print-microbitimage-i", 
            "text": "", 
            "title": "int print( MicroBitImage i)"
        }, 
        {
            "location": "/ubit/display/#description_17", 
            "text": "Prints the given image to the display. Blocks the calling thread until all the image has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_15", 
            "text": "MicroBitImage   i  - The image to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_8", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_16", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-print-microbitimage-i-int-x", 
            "text": "", 
            "title": "int print( MicroBitImage i,  int x)"
        }, 
        {
            "location": "/ubit/display/#description_18", 
            "text": "Prints the given image to the display. Blocks the calling thread until all the image has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_16", 
            "text": "MicroBitImage   i  - The image to display.  int   x  - The horizontal position on the screen to display the image. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_9", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_17", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-print-microbitimage-i-int-x-int-y", 
            "text": "", 
            "title": "int print( MicroBitImage i,  int x,  int y)"
        }, 
        {
            "location": "/ubit/display/#description_19", 
            "text": "Prints the given image to the display. Blocks the calling thread until all the image has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_17", 
            "text": "MicroBitImage   i  - The image to display.  int   x  - The horizontal position on the screen to display the image. Defaults to 0.  int   y  - The vertical position on the screen to display the image. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_10", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_18", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-print-microbitimage-i-int-x-int-y-int-alpha", 
            "text": "", 
            "title": "int print( MicroBitImage i,  int x,  int y,  int alpha)"
        }, 
        {
            "location": "/ubit/display/#description_20", 
            "text": "Prints the given image to the display. Blocks the calling thread until all the image has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_18", 
            "text": "MicroBitImage   i  - The image to display.  int   x  - The horizontal position on the screen to display the image. Defaults to 0.  int   y  - The vertical position on the screen to display the image. Defaults to 0.  int   alpha  - Treats the brightness level '0' as transparent. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_11", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_19", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-print-microbitimage-i-int-x-int-y-int-alpha-int-delay", 
            "text": "", 
            "title": "int print( MicroBitImage i,  int x,  int y,  int alpha,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_21", 
            "text": "Prints the given image to the display. Blocks the calling thread until all the image has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_19", 
            "text": "MicroBitImage   i  - The image to display.  int   x  - The horizontal position on the screen to display the image. Defaults to 0.  int   y  - The vertical position on the screen to display the image. Defaults to 0.  int   alpha  - Treats the brightness level '0' as transparent. Defaults to 0.  int   delay  - The time to display the image for, or zero to show the image forever. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_12", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_20", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.print(i,400);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#scrollasync", 
            "text": "", 
            "title": "scrollAsync"
        }, 
        {
            "location": "/ubit/display/#int-scrollasync-managedstring-s", 
            "text": "", 
            "title": "int scrollAsync( ManagedString s)"
        }, 
        {
            "location": "/ubit/display/#description_22", 
            "text": "Scrolls the given string to the display, from right to left. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_20", 
            "text": "ManagedString   s  - The string to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_13", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_21", 
            "text": "display.scrollAsync( abc123 ,100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scrollasync-managedstring-s-int-delay", 
            "text": "", 
            "title": "int scrollAsync( ManagedString s,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_23", 
            "text": "Scrolls the given string to the display, from right to left. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_21", 
            "text": "ManagedString   s  - The string to display.  int   delay  - The time to delay between characters, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_14", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_22", 
            "text": "display.scrollAsync( abc123 ,100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scrollasync-microbitimage-image", 
            "text": "", 
            "title": "int scrollAsync( MicroBitImage image)"
        }, 
        {
            "location": "/ubit/display/#description_24", 
            "text": "Scrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_22", 
            "text": "MicroBitImage   image  - The image to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_15", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_23", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.scrollAsync(i,100,1);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scrollasync-microbitimage-image-int-delay", 
            "text": "", 
            "title": "int scrollAsync( MicroBitImage image,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_25", 
            "text": "Scrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_23", 
            "text": "MicroBitImage   image  - The image to display.  int   delay  - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_16", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_24", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.scrollAsync(i,100,1);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scrollasync-microbitimage-image-int-delay-int-stride", 
            "text": "", 
            "title": "int scrollAsync( MicroBitImage image,  int delay,  int stride)"
        }, 
        {
            "location": "/ubit/display/#description_26", 
            "text": "Scrolls the given image across the display, from right to left. Returns immediately, and executes the animation asynchronously.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_24", 
            "text": "MicroBitImage   image  - The image to display.  int   delay  - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.  int   stride  - The number of pixels to shift by in each update. Defaults to MICROBIT_DEFAULT_SCROLL_STRIDE.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_17", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the display is already in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_25", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.scrollAsync(i,100,1);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#scroll", 
            "text": "", 
            "title": "scroll"
        }, 
        {
            "location": "/ubit/display/#int-scroll-managedstring-s", 
            "text": "", 
            "title": "int scroll( ManagedString s)"
        }, 
        {
            "location": "/ubit/display/#description_27", 
            "text": "Scrolls the given string across the display, from right to left. Blocks the calling thread until all text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_25", 
            "text": "ManagedString   s  - The string to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_18", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_26", 
            "text": "display.scroll( abc123 ,100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scroll-managedstring-s-int-delay", 
            "text": "", 
            "title": "int scroll( ManagedString s,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_28", 
            "text": "Scrolls the given string across the display, from right to left. Blocks the calling thread until all text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_26", 
            "text": "ManagedString   s  - The string to display.  int   delay  - The time to delay between characters, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_19", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_27", 
            "text": "display.scroll( abc123 ,100);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scroll-microbitimage-image", 
            "text": "", 
            "title": "int scroll( MicroBitImage image)"
        }, 
        {
            "location": "/ubit/display/#description_29", 
            "text": "Scrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_27", 
            "text": "MicroBitImage   image  - The image to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_20", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_28", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.scroll(i,100,1);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scroll-microbitimage-image-int-delay", 
            "text": "", 
            "title": "int scroll( MicroBitImage image,  int delay)"
        }, 
        {
            "location": "/ubit/display/#description_30", 
            "text": "Scrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_28", 
            "text": "MicroBitImage   image  - The image to display.  int   delay  - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_21", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_29", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.scroll(i,100,1);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-scroll-microbitimage-image-int-delay-int-stride", 
            "text": "", 
            "title": "int scroll( MicroBitImage image,  int delay,  int stride)"
        }, 
        {
            "location": "/ubit/display/#description_31", 
            "text": "Scrolls the given image across the display, from right to left. Blocks the calling thread until all the text has been displayed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_29", 
            "text": "MicroBitImage   image  - The image to display.  int   delay  - The time between updates, in milliseconds. Defaults to: MICROBIT_DEFAULT_SCROLL_SPEED.  int   stride  - The number of pixels to shift by in each update. Defaults to MICROBIT_DEFAULT_SCROLL_STRIDE.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_22", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_30", 
            "text": "MicrobitImage i( 1,1,1,1,1\\n1,1,1,1,1\\n ); \n display.scroll(i,100,1);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#animateasync", 
            "text": "", 
            "title": "animateAsync"
        }, 
        {
            "location": "/ubit/display/#int-animateasync-microbitimage-image-int-delay-int-stride", 
            "text": "", 
            "title": "int animateAsync( MicroBitImage image,  int delay,  int stride)"
        }, 
        {
            "location": "/ubit/display/#description_32", 
            "text": "\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_30", 
            "text": "MicroBitImage   image  - The image to display.  int   delay  - The time to delay between each update of the display, in milliseconds.  int   stride  - The number of pixels to shift by in each update.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_23", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_31", 
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animateAsync(i,100,5);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-animateasync-microbitimage-image-int-delay-int-stride-int-startingposition", 
            "text": "", 
            "title": "int animateAsync( MicroBitImage image,  int delay,  int stride,  int startingPosition)"
        }, 
        {
            "location": "/ubit/display/#description_33", 
            "text": "\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Returns immediately.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_31", 
            "text": "MicroBitImage   image  - The image to display.  int   delay  - The time to delay between each update of the display, in milliseconds.  int   stride  - The number of pixels to shift by in each update.  int   startingPosition  - the starting position on the display for the animation to begin at. Defaults to MICROBIT_DISPLAY_ANIMATE_DEFAULT_POS.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_24", 
            "text": "MICROBIT_OK, MICROBIT_BUSY if the screen is in use, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_32", 
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animateAsync(i,100,5);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#animate", 
            "text": "", 
            "title": "animate"
        }, 
        {
            "location": "/ubit/display/#int-animate-microbitimage-image-int-delay-int-stride", 
            "text": "", 
            "title": "int animate( MicroBitImage image,  int delay,  int stride)"
        }, 
        {
            "location": "/ubit/display/#description_34", 
            "text": "\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_32", 
            "text": "MicroBitImage   image  int   delay  - The time to delay between each update of the display, in milliseconds.  int   stride  - The number of pixels to shift by in each update.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_25", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_33", 
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animate(i,100,5);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#int-animate-microbitimage-image-int-delay-int-stride-int-startingposition", 
            "text": "", 
            "title": "int animate( MicroBitImage image,  int delay,  int stride,  int startingPosition)"
        }, 
        {
            "location": "/ubit/display/#description_35", 
            "text": "\"Animates\" the current image across the display with a given stride, finishing on the last frame of the animation. Blocks the calling thread until the animation is complete.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_33", 
            "text": "MicroBitImage   image  int   delay  - The time to delay between each update of the display, in milliseconds.  int   stride  - The number of pixels to shift by in each update.  int   startingPosition  - the starting position on the display for the animation to begin at. Defaults to MICROBIT_DISPLAY_ANIMATE_DEFAULT_POS.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_26", 
            "text": "MICROBIT_OK, MICROBIT_CANCELLED or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_34", 
            "text": "const int heart_w = 10; \n const int heart_h = 5; \n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; \n\n MicroBitImage i(heart_w,heart_h,heart); \n display.animate(i,100,5);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#setbrightness", 
            "text": "", 
            "title": "setBrightness"
        }, 
        {
            "location": "/ubit/display/#int-setbrightness-int-b", 
            "text": "", 
            "title": "int setBrightness( int b)"
        }, 
        {
            "location": "/ubit/display/#description_36", 
            "text": "Configures the brightness of the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_34", 
            "text": "int   b  - The brightness to set the brightness to, in the range 0 - 255.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#returns_27", 
            "text": "MICROBIT_OK, or MICROBIT_INVALID_PARAMETER", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_35", 
            "text": "display.setBrightness(255); //max brightness", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#setdisplaymode", 
            "text": "", 
            "title": "setDisplayMode"
        }, 
        {
            "location": "/ubit/display/#void-setdisplaymode-displaymode-mode", 
            "text": "", 
            "title": "void setDisplayMode( DisplayMode mode)"
        }, 
        {
            "location": "/ubit/display/#description_37", 
            "text": "Configures the mode of the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_35", 
            "text": "DisplayMode   mode  - The mode to swap the display into. One of: DISPLAY_MODE_GREYSCALE, DISPLAY_MODE_BLACK_AND_WHITE, DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_36", 
            "text": "display.setDisplayMode(DISPLAY_MODE_GREYSCALE); //per pixel brightness", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#getdisplaymode", 
            "text": "", 
            "title": "getDisplayMode"
        }, 
        {
            "location": "/ubit/display/#int-getdisplaymode", 
            "text": "", 
            "title": "int getDisplayMode()"
        }, 
        {
            "location": "/ubit/display/#description_38", 
            "text": "Retrieves the mode of the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#returns_28", 
            "text": "the current mode of the display", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#getbrightness", 
            "text": "", 
            "title": "getBrightness"
        }, 
        {
            "location": "/ubit/display/#int-getbrightness", 
            "text": "", 
            "title": "int getBrightness()"
        }, 
        {
            "location": "/ubit/display/#description_39", 
            "text": "Fetches the current brightness of this display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#returns_29", 
            "text": "the brightness of this display, in the range 0..255.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#example_37", 
            "text": "display.getBrightness(); //the current brightness", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#rotateto", 
            "text": "", 
            "title": "rotateTo"
        }, 
        {
            "location": "/ubit/display/#void-rotateto-displayrotation-position", 
            "text": "", 
            "title": "void rotateTo( DisplayRotation position)"
        }, 
        {
            "location": "/ubit/display/#description_40", 
            "text": "Rotates the display to the given position.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_36", 
            "text": "DisplayRotation   position", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#example_38", 
            "text": "display.rotateTo(MICROBIT_DISPLAY_ROTATION_180); //rotates 180 degrees from original orientation", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#enable", 
            "text": "", 
            "title": "enable"
        }, 
        {
            "location": "/ubit/display/#void-enable", 
            "text": "", 
            "title": "void enable()"
        }, 
        {
            "location": "/ubit/display/#description_41", 
            "text": "Enables the display, should only be called if the display is disabled.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#example_39", 
            "text": "display.enable(); //Enables the display mechanics    Note  Only enables the display if the display is currently disabled.", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#disable", 
            "text": "", 
            "title": "disable"
        }, 
        {
            "location": "/ubit/display/#void-disable", 
            "text": "", 
            "title": "void disable()"
        }, 
        {
            "location": "/ubit/display/#description_42", 
            "text": "Disables the display, which releases control of the GPIO pins used by the display, which are exposed on the edge connector.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#example_40", 
            "text": "display.disable(); //disables the display    Note  Only disables the display if the display is currently enabled.", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#clear", 
            "text": "", 
            "title": "clear"
        }, 
        {
            "location": "/ubit/display/#void-clear", 
            "text": "", 
            "title": "void clear()"
        }, 
        {
            "location": "/ubit/display/#description_43", 
            "text": "Clears the display of any remaining pixels.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#example_41", 
            "text": "display.clear(); //clears the display", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/display/#setfont", 
            "text": "", 
            "title": "setFont"
        }, 
        {
            "location": "/ubit/display/#void-setfont-microbitfont-font", 
            "text": "", 
            "title": "void setFont( MicroBitFont font)"
        }, 
        {
            "location": "/ubit/display/#description_44", 
            "text": "Updates the font that will be used for display operations.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#parameters_37", 
            "text": "MicroBitFont   font  - the new font that will be used to render characters.    Note  DEPRECATED! Please use  MicroBitFont::setSystemFont()  instead.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/display/#getfont", 
            "text": "", 
            "title": "getFont"
        }, 
        {
            "location": "/ubit/display/#microbitfont-getfont", 
            "text": "", 
            "title": "MicroBitFont getFont()"
        }, 
        {
            "location": "/ubit/display/#description_45", 
            "text": "Retrieves the font object used for rendering characters on the display.   Note  DEPRECATED! Please use  MicroBitFont::getSystemFont()  instead.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#screenshot", 
            "text": "", 
            "title": "screenShot"
        }, 
        {
            "location": "/ubit/display/#microbitimage-screenshot", 
            "text": "", 
            "title": "MicroBitImage screenShot()"
        }, 
        {
            "location": "/ubit/display/#description_46", 
            "text": "Captures the bitmap currently being rendered on the display.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#returns_30", 
            "text": "a  MicroBitImage  containing the captured data.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/display/#readlightlevel", 
            "text": "", 
            "title": "readLightLevel"
        }, 
        {
            "location": "/ubit/display/#int-readlightlevel", 
            "text": "", 
            "title": "int readLightLevel()"
        }, 
        {
            "location": "/ubit/display/#description_47", 
            "text": "Gives a representative figure of the light level in the current environment where are micro:bit is situated.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/display/#returns_31", 
            "text": "an indicative light level in the range 0 - 255.   Note  this will return 0 on the first call to this method, a light reading will be available after the display has activated the light sensor for the first time.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/", 
            "text": "uBit.accelerometer\n\n\nOverview\n\n\nOnboard the micro:bit is an accelerometer, and it is linked to the\n\ni2c\n bus which is used to read data from the accelerometer.\n\n\nThe accelerometer on the micro:bit detects the acceleration (\nin milli-g\n) in 3 planes: x and y\n(\nthe horizontal planes\n), and z (\nthe vertical plane\n).\n\n\nAs well as detecting acceleration, accelerometers can also detect orientation, which\nis used in smart phones and tablets to rotate content as you tilt the device. This means\nthat the micro:bit can infer its own orientation as well!\n\n\nAs well as being used to detect acceleration, accelerometers are also used to detect\nthe rate of deceleration. A great example of an application of accelerometers are\nairbags in modern vehicles, where an accelerometer is used to detect the rapid deceleration\nof a vehicle. If rapid deceleration were to occur, the airbags are deployed.\n\n\nAccelerometers can also be used to detect when an object is in free fall, which is\nwhen only the force gravity is acting upon an object. If you were to throw a ball directly\ninto the air, free fall would begin as soon as the ball begins its decent after the\nacceleration from your throw has subsided.\n\n\nThe micro:bit uses the \nNXP MMA8653 accelerometer\n.\n\n\nReal time updates\n\n\nWhen using the standard uBit presentation, the accelerometer is continuously updated\nin the background using an idle thread (after it is first used), which is executed\nwhenever the micro:bit has no other tasks to perform..\n\n\nIf there is no scheduler running, the values are synchronously read on \nget[X,Y,Z]()\n\ncalls. Additionally, if you would like to drive accelerometer updates manually \nupdateSample()\n\ncan be used.\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_ACCELEROMETER\n\n\n4\n\n\n\n\n\n\n\n\nMessage Bus Events\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_TILT_UP\n\n\n1\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_TILT_DOWN\n\n\n2\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_TILT_LEFT\n\n\n3\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_TILT_RIGHT\n\n\n4\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_FACE_UP\n\n\n5\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_FACE_DOWN\n\n\n6\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_FREEFALL\n\n\n7\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_3G\n\n\n8\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_6G\n\n\n9\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_8G\n\n\n10\n\n\n\n\n\n\nMICROBIT_ACCELEROMETER_EVT_SHAKE\n\n\n11\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitAccelerometer( \nMicroBitI2C  \n _i2c)\n\n\nDescription\n\n\nConstructor. Create a software abstraction of an accelerometer.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of  MicroBitI2C  used to communicate with the onboard accelerometer.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c); \n\n\n\n\n\n\nMicroBitAccelerometer( \nMicroBitI2C  \n _i2c,  \nuint16_t\n address)\n\n\nDescription\n\n\nConstructor. Create a software abstraction of an accelerometer.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of  MicroBitI2C  used to communicate with the onboard accelerometer.\n\n\nuint16_t\n \naddress\n - the default I2C address of the accelerometer. Defaults to: MMA8653_DEFAULT_ADDR.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c); \n\n\n\n\n\n\nMicroBitAccelerometer( \nMicroBitI2C  \n _i2c,  \nuint16_t\n address,  \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor. Create a software abstraction of an accelerometer.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of  MicroBitI2C  used to communicate with the onboard accelerometer.\n\n\nuint16_t\n \naddress\n - the default I2C address of the accelerometer. Defaults to: MMA8653_DEFAULT_ADDR.\n\n\nuint16_t\n \nid\n - the unique  EventModel  id of this component. Defaults to: MICROBIT_ID_ACCELEROMETER\n\n\n\n\nExample\n\n\n MicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c); \n\n\n\n\nconfigure\n\n\n\n\nint\n configure()\n\n\nDescription\n\n\nConfigures the accelerometer for G range and sample rate defined in this object. The nearest values are chosen to those defined that are supported by the hardware. The instance variables are then updated to reflect reality.\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if the accelerometer could not be configured. \n\n\nupdateSample\n\n\n\n\nint\n updateSample()\n\n\nDescription\n\n\nReads the acceleration data from the accelerometer, and stores it in our buffer. This only happens if the accelerometer indicates that it has new data via int1.\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR if the read request fails. \n\n\nsetPeriod\n\n\n\n\nint\n setPeriod( \nint\n period)\n\n\nDescription\n\n\nAttempts to set the sample rate of the accelerometer to the specified value (in ms).\n\n\nParameters\n\n\n\n\nint\n \nperiod\n - the requested time between samples, in milliseconds.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR is the request fails.\n\n\nExample\n\n\n // sample rate is now 20 ms. \n accelerometer.setPeriod(20); \n\n\n\n\n\n\nNote\n\n\nThe requested rate may not be possible on the hardware. In this case, the nearest lower rate is chosen. \n\n\n\n\ngetPeriod\n\n\n\n\nint\n getPeriod()\n\n\nDescription\n\n\nReads the currently configured sample rate of the accelerometer.\n\n\nReturns\n\n\nThe time between samples, in milliseconds. \n\n\nsetRange\n\n\n\n\nint\n setRange( \nint\n range)\n\n\nDescription\n\n\nAttempts to set the sample range of the accelerometer to the specified value (in g).\n\n\nParameters\n\n\n\n\nint\n \nrange\n - The requested sample range of samples, in g.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_I2C_ERROR is the request fails.\n\n\nExample\n\n\n // the sample range of the accelerometer is now 8G. \n accelerometer.setRange(8); \n\n\n\n\n\n\nNote\n\n\nThe requested range may not be possible on the hardware. In this case, the nearest lower range is chosen. \n\n\n\n\ngetRange\n\n\n\n\nint\n getRange()\n\n\nDescription\n\n\nReads the currently configured sample range of the accelerometer.\n\n\nReturns\n\n\nThe sample range, in g. \n\n\nwhoAmI\n\n\n\n\nint\n whoAmI()\n\n\nDescription\n\n\nAttempts to read the 8 bit ID from the accelerometer, this can be used for validation purposes.\n\n\nReturns\n\n\nthe 8 bit ID returned by the accelerometer, or MICROBIT_I2C_ERROR if the request fails.\n\n\nExample\n\n\n accelerometer.whoAmI(); \n\n\n\n\ngetX\n\n\n\n\nint\n getX()\n\n\nDescription\n\n\nReads the value of the X axis from the latest update retrieved from the accelerometer.\n\n\nReturns\n\n\nThe force measured in the X axis, in milli-g.\n\n\nExample\n\n\n accelerometer.getX(); \n\n\n\n\n\n\nint\n getX( \nMicroBitCoordinateSystem\n system)\n\n\nDescription\n\n\nReads the value of the X axis from the latest update retrieved from the accelerometer.\n\n\nParameters\n\n\n\n\nMicroBitCoordinateSystem\n \nsystem\n - The coordinate system to use. By default, a simple cartesian system is provided.\n\n\n\n\nReturns\n\n\nThe force measured in the X axis, in milli-g.\n\n\nExample\n\n\n accelerometer.getX(); \n\n\n\n\ngetY\n\n\n\n\nint\n getY()\n\n\nDescription\n\n\nReads the value of the Y axis from the latest update retrieved from the accelerometer.\n\n\nReturns\n\n\nThe force measured in the Y axis, in milli-g.\n\n\nExample\n\n\n accelerometer.getY(); \n\n\n\n\n\n\nint\n getY( \nMicroBitCoordinateSystem\n system)\n\n\nDescription\n\n\nReads the value of the Y axis from the latest update retrieved from the accelerometer.\n\n\nParameters\n\n\n\n\nMicroBitCoordinateSystem\n \nsystem\n\n\n\n\nReturns\n\n\nThe force measured in the Y axis, in milli-g.\n\n\nExample\n\n\n accelerometer.getY(); \n\n\n\n\ngetZ\n\n\n\n\nint\n getZ()\n\n\nDescription\n\n\nReads the value of the Z axis from the latest update retrieved from the accelerometer.\n\n\nReturns\n\n\nThe force measured in the Z axis, in milli-g.\n\n\nExample\n\n\n accelerometer.getZ(); \n\n\n\n\n\n\nint\n getZ( \nMicroBitCoordinateSystem\n system)\n\n\nDescription\n\n\nReads the value of the Z axis from the latest update retrieved from the accelerometer.\n\n\nParameters\n\n\n\n\nMicroBitCoordinateSystem\n \nsystem\n\n\n\n\nReturns\n\n\nThe force measured in the Z axis, in milli-g.\n\n\nExample\n\n\n accelerometer.getZ(); \n\n\n\n\ngetPitch\n\n\n\n\nint\n getPitch()\n\n\nDescription\n\n\nProvides a rotation compensated pitch of the device, based on the latest update retrieved from the accelerometer.\n\n\nReturns\n\n\nThe pitch of the device, in degrees.\n\n\nExample\n\n\n accelerometer.getPitch(); \n\n\n\n\ngetPitchRadians\n\n\n\n\nfloat\n getPitchRadians()\n\n\nDescription\n\n\nProvides a rotation compensated pitch of the device, based on the latest update retrieved from the accelerometer.\n\n\nReturns\n\n\nThe pitch of the device, in radians.\n\n\nExample\n\n\n accelerometer.getPitchRadians(); \n\n\n\n\ngetRoll\n\n\n\n\nint\n getRoll()\n\n\nDescription\n\n\nProvides a rotation compensated roll of the device, based on the latest update retrieved from the accelerometer.\n\n\nReturns\n\n\nThe roll of the device, in degrees.\n\n\nExample\n\n\n accelerometer.getRoll(); \n\n\n\n\ngetRollRadians\n\n\n\n\nfloat\n getRollRadians()\n\n\nDescription\n\n\nProvides a rotation compensated roll of the device, based on the latest update retrieved from the accelerometer.\n\n\nReturns\n\n\nThe roll of the device, in radians.\n\n\nExample\n\n\n accelerometer.getRollRadians(); \n\n\n\n\ngetGesture\n\n\n\n\nBasicGesture\n getGesture()\n\n\nDescription\n\n\nRetrieves the last recorded gesture.\n\n\nReturns\n\n\nThe last gesture that was detected.\n\n\nExample\n\n\n MicroBitDisplay display; \n\n if (accelerometer.getGesture() == SHAKE) \n display.scroll(\nSHAKE!\n); \n\n\n\n\nisIdleCallbackNeeded\n\n\n\n\nint\n isIdleCallbackNeeded()\n\n\nDescription\n\n\nReturns 0 or 1. 1 indicates data is waiting to be read, zero means data is not ready to be read.", 
            "title": "accelerometer"
        }, 
        {
            "location": "/ubit/accelerometer/#ubitaccelerometer", 
            "text": "", 
            "title": "uBit.accelerometer"
        }, 
        {
            "location": "/ubit/accelerometer/#overview", 
            "text": "Onboard the micro:bit is an accelerometer, and it is linked to the i2c  bus which is used to read data from the accelerometer.  The accelerometer on the micro:bit detects the acceleration ( in milli-g ) in 3 planes: x and y\n( the horizontal planes ), and z ( the vertical plane ).  As well as detecting acceleration, accelerometers can also detect orientation, which\nis used in smart phones and tablets to rotate content as you tilt the device. This means\nthat the micro:bit can infer its own orientation as well!  As well as being used to detect acceleration, accelerometers are also used to detect\nthe rate of deceleration. A great example of an application of accelerometers are\nairbags in modern vehicles, where an accelerometer is used to detect the rapid deceleration\nof a vehicle. If rapid deceleration were to occur, the airbags are deployed.  Accelerometers can also be used to detect when an object is in free fall, which is\nwhen only the force gravity is acting upon an object. If you were to throw a ball directly\ninto the air, free fall would begin as soon as the ball begins its decent after the\nacceleration from your throw has subsided.  The micro:bit uses the  NXP MMA8653 accelerometer .", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/accelerometer/#real-time-updates", 
            "text": "When using the standard uBit presentation, the accelerometer is continuously updated\nin the background using an idle thread (after it is first used), which is executed\nwhenever the micro:bit has no other tasks to perform..  If there is no scheduler running, the values are synchronously read on  get[X,Y,Z]() \ncalls. Additionally, if you would like to drive accelerometer updates manually  updateSample() \ncan be used.", 
            "title": "Real time updates"
        }, 
        {
            "location": "/ubit/accelerometer/#message-bus-id", 
            "text": "Constant  Value      MICROBIT_ID_ACCELEROMETER  4", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/accelerometer/#message-bus-events", 
            "text": "Constant  Value      MICROBIT_ACCELEROMETER_EVT_TILT_UP  1    MICROBIT_ACCELEROMETER_EVT_TILT_DOWN  2    MICROBIT_ACCELEROMETER_EVT_TILT_LEFT  3    MICROBIT_ACCELEROMETER_EVT_TILT_RIGHT  4    MICROBIT_ACCELEROMETER_EVT_FACE_UP  5    MICROBIT_ACCELEROMETER_EVT_FACE_DOWN  6    MICROBIT_ACCELEROMETER_EVT_FREEFALL  7    MICROBIT_ACCELEROMETER_EVT_3G  8    MICROBIT_ACCELEROMETER_EVT_6G  9    MICROBIT_ACCELEROMETER_EVT_8G  10    MICROBIT_ACCELEROMETER_EVT_SHAKE  11", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/accelerometer/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/accelerometer/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/accelerometer/#microbitaccelerometer-microbiti2c-_i2c", 
            "text": "", 
            "title": "MicroBitAccelerometer( MicroBitI2C  &amp; _i2c)"
        }, 
        {
            "location": "/ubit/accelerometer/#description", 
            "text": "Constructor. Create a software abstraction of an accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters", 
            "text": "MicroBitI2C     _i2c  - an instance of  MicroBitI2C  used to communicate with the onboard accelerometer.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#example", 
            "text": "MicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#microbitaccelerometer-microbiti2c-_i2c-uint16_t-address", 
            "text": "", 
            "title": "MicroBitAccelerometer( MicroBitI2C  &amp; _i2c,  uint16_t address)"
        }, 
        {
            "location": "/ubit/accelerometer/#description_1", 
            "text": "Constructor. Create a software abstraction of an accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters_1", 
            "text": "MicroBitI2C     _i2c  - an instance of  MicroBitI2C  used to communicate with the onboard accelerometer.  uint16_t   address  - the default I2C address of the accelerometer. Defaults to: MMA8653_DEFAULT_ADDR.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#example_1", 
            "text": "MicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#microbitaccelerometer-microbiti2c-_i2c-uint16_t-address-uint16_t-id", 
            "text": "", 
            "title": "MicroBitAccelerometer( MicroBitI2C  &amp; _i2c,  uint16_t address,  uint16_t id)"
        }, 
        {
            "location": "/ubit/accelerometer/#description_2", 
            "text": "Constructor. Create a software abstraction of an accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters_2", 
            "text": "MicroBitI2C     _i2c  - an instance of  MicroBitI2C  used to communicate with the onboard accelerometer.  uint16_t   address  - the default I2C address of the accelerometer. Defaults to: MMA8653_DEFAULT_ADDR.  uint16_t   id  - the unique  EventModel  id of this component. Defaults to: MICROBIT_ID_ACCELEROMETER", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#example_2", 
            "text": "MicroBitI2C i2c = MicroBitI2C(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer = MicroBitAccelerometer(i2c);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#configure", 
            "text": "", 
            "title": "configure"
        }, 
        {
            "location": "/ubit/accelerometer/#int-configure", 
            "text": "", 
            "title": "int configure()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_3", 
            "text": "Configures the accelerometer for G range and sample rate defined in this object. The nearest values are chosen to those defined that are supported by the hardware. The instance variables are then updated to reflect reality.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns", 
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if the accelerometer could not be configured.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#updatesample", 
            "text": "", 
            "title": "updateSample"
        }, 
        {
            "location": "/ubit/accelerometer/#int-updatesample", 
            "text": "", 
            "title": "int updateSample()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_4", 
            "text": "Reads the acceleration data from the accelerometer, and stores it in our buffer. This only happens if the accelerometer indicates that it has new data via int1.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_1", 
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR if the read request fails.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#setperiod", 
            "text": "", 
            "title": "setPeriod"
        }, 
        {
            "location": "/ubit/accelerometer/#int-setperiod-int-period", 
            "text": "", 
            "title": "int setPeriod( int period)"
        }, 
        {
            "location": "/ubit/accelerometer/#description_5", 
            "text": "Attempts to set the sample rate of the accelerometer to the specified value (in ms).", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters_3", 
            "text": "int   period  - the requested time between samples, in milliseconds.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_2", 
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR is the request fails.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_3", 
            "text": "// sample rate is now 20 ms. \n accelerometer.setPeriod(20);    Note  The requested rate may not be possible on the hardware. In this case, the nearest lower rate is chosen.", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getperiod", 
            "text": "", 
            "title": "getPeriod"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getperiod", 
            "text": "", 
            "title": "int getPeriod()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_6", 
            "text": "Reads the currently configured sample rate of the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_3", 
            "text": "The time between samples, in milliseconds.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#setrange", 
            "text": "", 
            "title": "setRange"
        }, 
        {
            "location": "/ubit/accelerometer/#int-setrange-int-range", 
            "text": "", 
            "title": "int setRange( int range)"
        }, 
        {
            "location": "/ubit/accelerometer/#description_7", 
            "text": "Attempts to set the sample range of the accelerometer to the specified value (in g).", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters_4", 
            "text": "int   range  - The requested sample range of samples, in g.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_4", 
            "text": "MICROBIT_OK on success, MICROBIT_I2C_ERROR is the request fails.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_4", 
            "text": "// the sample range of the accelerometer is now 8G. \n accelerometer.setRange(8);    Note  The requested range may not be possible on the hardware. In this case, the nearest lower range is chosen.", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getrange", 
            "text": "", 
            "title": "getRange"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getrange", 
            "text": "", 
            "title": "int getRange()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_8", 
            "text": "Reads the currently configured sample range of the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_5", 
            "text": "The sample range, in g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#whoami", 
            "text": "", 
            "title": "whoAmI"
        }, 
        {
            "location": "/ubit/accelerometer/#int-whoami", 
            "text": "", 
            "title": "int whoAmI()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_9", 
            "text": "Attempts to read the 8 bit ID from the accelerometer, this can be used for validation purposes.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_6", 
            "text": "the 8 bit ID returned by the accelerometer, or MICROBIT_I2C_ERROR if the request fails.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_5", 
            "text": "accelerometer.whoAmI();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getx", 
            "text": "", 
            "title": "getX"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getx", 
            "text": "", 
            "title": "int getX()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_10", 
            "text": "Reads the value of the X axis from the latest update retrieved from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_7", 
            "text": "The force measured in the X axis, in milli-g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_6", 
            "text": "accelerometer.getX();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getx-microbitcoordinatesystem-system", 
            "text": "", 
            "title": "int getX( MicroBitCoordinateSystem system)"
        }, 
        {
            "location": "/ubit/accelerometer/#description_11", 
            "text": "Reads the value of the X axis from the latest update retrieved from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters_5", 
            "text": "MicroBitCoordinateSystem   system  - The coordinate system to use. By default, a simple cartesian system is provided.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_8", 
            "text": "The force measured in the X axis, in milli-g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_7", 
            "text": "accelerometer.getX();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#gety", 
            "text": "", 
            "title": "getY"
        }, 
        {
            "location": "/ubit/accelerometer/#int-gety", 
            "text": "", 
            "title": "int getY()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_12", 
            "text": "Reads the value of the Y axis from the latest update retrieved from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_9", 
            "text": "The force measured in the Y axis, in milli-g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_8", 
            "text": "accelerometer.getY();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#int-gety-microbitcoordinatesystem-system", 
            "text": "", 
            "title": "int getY( MicroBitCoordinateSystem system)"
        }, 
        {
            "location": "/ubit/accelerometer/#description_13", 
            "text": "Reads the value of the Y axis from the latest update retrieved from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters_6", 
            "text": "MicroBitCoordinateSystem   system", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_10", 
            "text": "The force measured in the Y axis, in milli-g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_9", 
            "text": "accelerometer.getY();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getz", 
            "text": "", 
            "title": "getZ"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getz", 
            "text": "", 
            "title": "int getZ()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_14", 
            "text": "Reads the value of the Z axis from the latest update retrieved from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_11", 
            "text": "The force measured in the Z axis, in milli-g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_10", 
            "text": "accelerometer.getZ();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getz-microbitcoordinatesystem-system", 
            "text": "", 
            "title": "int getZ( MicroBitCoordinateSystem system)"
        }, 
        {
            "location": "/ubit/accelerometer/#description_15", 
            "text": "Reads the value of the Z axis from the latest update retrieved from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#parameters_7", 
            "text": "MicroBitCoordinateSystem   system", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_12", 
            "text": "The force measured in the Z axis, in milli-g.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_11", 
            "text": "accelerometer.getZ();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getpitch", 
            "text": "", 
            "title": "getPitch"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getpitch", 
            "text": "", 
            "title": "int getPitch()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_16", 
            "text": "Provides a rotation compensated pitch of the device, based on the latest update retrieved from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_13", 
            "text": "The pitch of the device, in degrees.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_12", 
            "text": "accelerometer.getPitch();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getpitchradians", 
            "text": "", 
            "title": "getPitchRadians"
        }, 
        {
            "location": "/ubit/accelerometer/#float-getpitchradians", 
            "text": "", 
            "title": "float getPitchRadians()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_17", 
            "text": "Provides a rotation compensated pitch of the device, based on the latest update retrieved from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_14", 
            "text": "The pitch of the device, in radians.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_13", 
            "text": "accelerometer.getPitchRadians();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getroll", 
            "text": "", 
            "title": "getRoll"
        }, 
        {
            "location": "/ubit/accelerometer/#int-getroll", 
            "text": "", 
            "title": "int getRoll()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_18", 
            "text": "Provides a rotation compensated roll of the device, based on the latest update retrieved from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_15", 
            "text": "The roll of the device, in degrees.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_14", 
            "text": "accelerometer.getRoll();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getrollradians", 
            "text": "", 
            "title": "getRollRadians"
        }, 
        {
            "location": "/ubit/accelerometer/#float-getrollradians", 
            "text": "", 
            "title": "float getRollRadians()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_19", 
            "text": "Provides a rotation compensated roll of the device, based on the latest update retrieved from the accelerometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_16", 
            "text": "The roll of the device, in radians.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_15", 
            "text": "accelerometer.getRollRadians();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#getgesture", 
            "text": "", 
            "title": "getGesture"
        }, 
        {
            "location": "/ubit/accelerometer/#basicgesture-getgesture", 
            "text": "", 
            "title": "BasicGesture getGesture()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_20", 
            "text": "Retrieves the last recorded gesture.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/accelerometer/#returns_17", 
            "text": "The last gesture that was detected.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/accelerometer/#example_16", 
            "text": "MicroBitDisplay display; \n\n if (accelerometer.getGesture() == SHAKE) \n display.scroll( SHAKE! );", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/accelerometer/#isidlecallbackneeded", 
            "text": "", 
            "title": "isIdleCallbackNeeded"
        }, 
        {
            "location": "/ubit/accelerometer/#int-isidlecallbackneeded", 
            "text": "", 
            "title": "int isIdleCallbackNeeded()"
        }, 
        {
            "location": "/ubit/accelerometer/#description_21", 
            "text": "Returns 0 or 1. 1 indicates data is waiting to be read, zero means data is not ready to be read.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/", 
            "text": "uBit.compass\n\n\nOverview\n\n\nOnboard the micro:bit is an electronic magnetometer. Like the \naccelerometer\n, the\n\nmagnetometer is linked to the \ni2c\n bus, which is used to access data\non the magnetometer.\n\n\nThe magnetometer provides information about the magnetic field where a micro:bit\nis situated, crucially providing an indication of where magnetic North is located.\n\n\nRaw magnetic field information alone is not enough to provide accurate\ncompass headings. Therefore, the \naccelerometer\n is used in\nconjunction with the magnetometer to reduce the inaccuracy of the magnetometer reading.\n\n\nThe magnetometer is inaccurate because it considers all 3 planes: x, y and z.\nThe heading North only exists in the horizontal planes (x and y), therefore we only\nneed values in these planes. The accelerometer is used to filter out the vertical plane (z)\nto make our headings far more accurate. You can see this in action when calibrating the compass.\n\n\nAfter calibration has been performed, the end product is an e-compass!\n\n\nThe micro:bit uses the \nNXP MAG3110\n.\n\n\nReal time updates\n\n\nWhen using the standard uBit presentation, the compass is continuously updated\nin the background using an idle thread (after it is first used), which is executed\nwhenever the micro:bit has no other tasks to perform.\n\n\nIf there is no scheduler running, the values are synchronously read on \nget[X,Y,Z]()\n and \nheading()\n\ncalls. Additionally, if you would like to drive compass updates manually \nupdateSample()\n\ncan be used.\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_COMPASS\n\n\n5\n\n\n\n\n\n\n\n\nMessage Bus Events\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CAL_REQUIRED\n\n\n1 \n(DEPRECATED)\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CAL_START\n\n\n2 \n(DEPRECATED)\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CAL_END\n\n\n3 \n(DEPRECATED)\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_DATA_UPDATE\n\n\n4\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CONFIG_NEEDED\n\n\n5\n\n\n\n\n\n\nMICROBIT_COMPASS_EVT_CALIBRATE\n\n\n6\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  \n _i2c,  \nMicroBitAccelerometer  \n _accelerometer,  \nMicroBitStorage  \n _storage)\n\n\nDescription\n\n\nConstructor. Create a software representation of an e-compass.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitAccelerometer  \n \n_accelerometer\n - an instance of the accelerometer, used for tilt compensation.\n\n\nMicroBitStorage  \n \n_storage\n - an instance of  MicroBitStorage , used to persist calibration data across resets.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, accelerometer, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  \n _i2c,  \nMicroBitAccelerometer  \n _accelerometer,  \nMicroBitStorage  \n _storage,  \nuint16_t\n address)\n\n\nDescription\n\n\nConstructor. Create a software representation of an e-compass.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitAccelerometer  \n \n_accelerometer\n - an instance of the accelerometer, used for tilt compensation.\n\n\nMicroBitStorage  \n \n_storage\n - an instance of  MicroBitStorage , used to persist calibration data across resets.\n\n\nuint16_t\n \naddress\n - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, accelerometer, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  \n _i2c,  \nMicroBitAccelerometer  \n _accelerometer,  \nMicroBitStorage  \n _storage,  \nuint16_t\n address,  \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor. Create a software representation of an e-compass.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitAccelerometer  \n \n_accelerometer\n - an instance of the accelerometer, used for tilt compensation.\n\n\nMicroBitStorage  \n \n_storage\n - an instance of  MicroBitStorage , used to persist calibration data across resets.\n\n\nuint16_t\n \naddress\n - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\nuint16_t\n \nid\n - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, accelerometer, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  \n _i2c,  \nMicroBitAccelerometer  \n _accelerometer)\n\n\nDescription\n\n\nConstructor. Create a software representation of an e-compass.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitAccelerometer  \n \n_accelerometer\n - an instance of the accelerometer, used for tilt compensation.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitCompass compass(i2c, accelerometer, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  \n _i2c,  \nMicroBitAccelerometer  \n _accelerometer,  \nuint16_t\n address)\n\n\nDescription\n\n\nConstructor. Create a software representation of an e-compass.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitAccelerometer  \n \n_accelerometer\n - an instance of the accelerometer, used for tilt compensation.\n\n\nuint16_t\n \naddress\n - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitCompass compass(i2c, accelerometer, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  \n _i2c,  \nMicroBitAccelerometer  \n _accelerometer,  \nuint16_t\n address,  \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor. Create a software representation of an e-compass.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitAccelerometer  \n \n_accelerometer\n - an instance of the accelerometer, used for tilt compensation.\n\n\nuint16_t\n \naddress\n - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\nuint16_t\n \nid\n - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitCompass compass(i2c, accelerometer, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  \n _i2c,  \nMicroBitStorage  \n _storage)\n\n\nDescription\n\n\nConstructor. Create a software representation of an e-compass.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitStorage  \n \n_storage\n - an instance of  MicroBitStorage , used to persist calibration data across resets.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  \n _i2c,  \nMicroBitStorage  \n _storage,  \nuint16_t\n address)\n\n\nDescription\n\n\nConstructor. Create a software representation of an e-compass.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitStorage  \n \n_storage\n - an instance of  MicroBitStorage , used to persist calibration data across resets.\n\n\nuint16_t\n \naddress\n - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  \n _i2c,  \nMicroBitStorage  \n _storage,  \nuint16_t\n address,  \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor. Create a software representation of an e-compass.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of i2c, which the compass is accessible from.\n\n\nMicroBitStorage  \n \n_storage\n - an instance of  MicroBitStorage , used to persist calibration data across resets.\n\n\nuint16_t\n \naddress\n - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\nuint16_t\n \nid\n - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, storage); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  \n _i2c)\n\n\nDescription\n\n\nConstructor. Create a software representation of an e-compass.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of i2c, which the compass is accessible from.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitCompass compass(i2c); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  \n _i2c,  \nuint16_t\n address)\n\n\nDescription\n\n\nConstructor. Create a software representation of an e-compass.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of i2c, which the compass is accessible from.\n\n\nuint16_t\n \naddress\n - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitCompass compass(i2c); \n\n\n\n\n\n\nMicroBitCompass( \nMicroBitI2C  \n _i2c,  \nuint16_t\n address,  \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor. Create a software representation of an e-compass.\n\n\nParameters\n\n\n\n\nMicroBitI2C  \n \n_i2c\n - an instance of i2c, which the compass is accessible from.\n\n\nuint16_t\n \naddress\n - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.\n\n\nuint16_t\n \nid\n - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.\n\n\n\n\nExample\n\n\n MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitCompass compass(i2c); \n\n\n\n\nconfigure\n\n\n\n\nint\n configure()\n\n\nDescription\n\n\nConfigures the compass for the sample rate defined in this object. The nearest values are chosen to those defined that are supported by the hardware. The instance variables are then updated to reflect reality.\n\n\nReturns\n\n\nMICROBIT_OK or MICROBIT_I2C_ERROR if the magnetometer could not be configured. \n\n\nsetPeriod\n\n\n\n\nint\n setPeriod( \nint\n period)\n\n\nDescription\n\n\nAttempts to set the sample rate of the compass to the specified value (in ms).\n\n\nParameters\n\n\n\n\nint\n \nperiod\n - the requested time between samples, in milliseconds.\n\n\n\n\nReturns\n\n\nMICROBIT_OK or MICROBIT_I2C_ERROR if the magnetometer could not be updated.\n\n\nExample\n\n\n // sample rate is now 20 ms. \n compass.setPeriod(20); \n\n\n\n\n\n\nNote\n\n\nThe requested rate may not be possible on the hardware. In this case, the nearest lower rate is chosen. \n\n\n\n\ngetPeriod\n\n\n\n\nint\n getPeriod()\n\n\nDescription\n\n\nReads the currently configured sample rate of the compass.\n\n\nReturns\n\n\nThe time between samples, in milliseconds. \n\n\nheading\n\n\n\n\nint\n heading()\n\n\nDescription\n\n\nGets the current heading of the device, relative to magnetic north.\n\n\nReturns\n\n\nthe current heading, in degrees. Or MICROBIT_CALIBRATION_IN_PROGRESS if the compass is calibrating.\n\n\nExample\n\n\n compass.heading(); \n\n\n\n\nwhoAmI\n\n\n\n\nint\n whoAmI()\n\n\nDescription\n\n\nAttempts to read the 8 bit ID from the magnetometer, this can be used for validation purposes.\n\n\nReturns\n\n\nthe 8 bit ID returned by the magnetometer, or MICROBIT_I2C_ERROR if the request fails.\n\n\nExample\n\n\n compass.whoAmI(); \n\n\n\n\ngetX\n\n\n\n\nint\n getX()\n\n\nDescription\n\n\nReads the value of the X axis from the latest update retrieved from the magnetometer.\n\n\nReturns\n\n\nThe magnetic force measured in the X axis, in nano teslas.\n\n\nExample\n\n\n compass.getX(); \n\n\n\n\n\n\nint\n getX( \nMicroBitCoordinateSystem\n system)\n\n\nDescription\n\n\nReads the value of the X axis from the latest update retrieved from the magnetometer.\n\n\nParameters\n\n\n\n\nMicroBitCoordinateSystem\n \nsystem\n - The coordinate system to use. By default, a simple cartesian system is provided.\n\n\n\n\nReturns\n\n\nThe magnetic force measured in the X axis, in nano teslas.\n\n\nExample\n\n\n compass.getX(); \n\n\n\n\ngetY\n\n\n\n\nint\n getY()\n\n\nDescription\n\n\nReads the value of the Y axis from the latest update retrieved from the magnetometer.\n\n\nReturns\n\n\nThe magnetic force measured in the Y axis, in nano teslas.\n\n\nExample\n\n\n compass.getY(); \n\n\n\n\n\n\nint\n getY( \nMicroBitCoordinateSystem\n system)\n\n\nDescription\n\n\nReads the value of the Y axis from the latest update retrieved from the magnetometer.\n\n\nParameters\n\n\n\n\nMicroBitCoordinateSystem\n \nsystem\n - The coordinate system to use. By default, a simple cartesian system is provided.\n\n\n\n\nReturns\n\n\nThe magnetic force measured in the Y axis, in nano teslas.\n\n\nExample\n\n\n compass.getY(); \n\n\n\n\ngetZ\n\n\n\n\nint\n getZ()\n\n\nDescription\n\n\nReads the value of the Z axis from the latest update retrieved from the magnetometer.\n\n\nReturns\n\n\nThe magnetic force measured in the Z axis, in nano teslas.\n\n\nExample\n\n\n compass.getZ(); \n\n\n\n\n\n\nint\n getZ( \nMicroBitCoordinateSystem\n system)\n\n\nDescription\n\n\nReads the value of the Z axis from the latest update retrieved from the magnetometer.\n\n\nParameters\n\n\n\n\nMicroBitCoordinateSystem\n \nsystem\n - The coordinate system to use. By default, a simple cartesian system is provided.\n\n\n\n\nReturns\n\n\nThe magnetic force measured in the Z axis, in nano teslas.\n\n\nExample\n\n\n compass.getZ(); \n\n\n\n\ngetFieldStrength\n\n\n\n\nint\n getFieldStrength()\n\n\nDescription\n\n\nDetermines the overall magnetic field strength based on the latest update from the magnetometer.\n\n\nReturns\n\n\nThe magnetic force measured across all axis, in nano teslas.\n\n\nExample\n\n\n compass.getFieldStrength(); \n\n\n\n\nreadTemperature\n\n\n\n\nint\n readTemperature()\n\n\nDescription\n\n\nReads the current die temperature of the compass.\n\n\nReturns\n\n\nthe temperature in degrees celsius, or MICROBIT_I2C_ERROR if the temperature reading could not be retreived from the accelerometer. \n\n\ncalibrate\n\n\n\n\nint\n calibrate()\n\n\nDescription\n\n\nPerform a calibration of the compass.\n\n\nReturns\n\n\nMICROBIT_OK, MICROBIT_I2C_ERROR if the magnetometer could not be accessed, or MICROBIT_CALIBRATION_REQUIRED if the calibration algorithm failed to complete successfully.\n\n\n\n\nNote\n\n\nTHIS MUST BE CALLED TO GAIN RELIABLE VALUES FROM THE COMPASS \n\n\n\n\nsetCalibration\n\n\n\n\nvoid\n setCalibration( \nCompassSample\n calibration)\n\n\nDescription\n\n\nConfigure the compass to use the calibration data that is supplied to this call.\n\n\nParameters\n\n\n\n\nCompassSample\n \ncalibration\n - A  CompassSample  containing the offsets for the x, y and z axis. \n\n\n\n\ngetCalibration\n\n\n\n\nCompassSample\n getCalibration()\n\n\nDescription\n\n\nProvides the calibration data currently in use by the compass.\n\n\nReturns\n\n\ncalibration A  CompassSample  containing the offsets for the x, y and z axis. \n\n\nupdateSample\n\n\n\n\nint\n updateSample()\n\n\nDescription\n\n\nUpdates the local sample, only if the compass indicates that data is stale.\n\n\n\n\nNote\n\n\nCan be used to trigger manual updates, if the device is running without a scheduler. Also called internally by all get\nX,Y,Z\n member functions. \n\n\n\n\nisCalibrated\n\n\n\n\nint\n isCalibrated()\n\n\nDescription\n\n\nReturns 0 or 1. 1 indicates that the compass is calibrated, zero means the compass requires calibration. \n\n\nisCalibrating\n\n\n\n\nint\n isCalibrating()\n\n\nDescription\n\n\nReturns 0 or 1. 1 indicates that the compass is calibrating, zero means the compass is not currently calibrating. \n\n\nclearCalibration\n\n\n\n\nvoid\n clearCalibration()\n\n\nDescription\n\n\nClears the calibration held in persistent storage, and sets the calibrated flag to zero. \n\n\nisIdleCallbackNeeded\n\n\n\n\nint\n isIdleCallbackNeeded()\n\n\nDescription\n\n\nReturns 0 or 1. 1 indicates data is waiting to be read, zero means data is not ready to be read.", 
            "title": "compass"
        }, 
        {
            "location": "/ubit/compass/#ubitcompass", 
            "text": "", 
            "title": "uBit.compass"
        }, 
        {
            "location": "/ubit/compass/#overview", 
            "text": "Onboard the micro:bit is an electronic magnetometer. Like the  accelerometer , the \nmagnetometer is linked to the  i2c  bus, which is used to access data\non the magnetometer.  The magnetometer provides information about the magnetic field where a micro:bit\nis situated, crucially providing an indication of where magnetic North is located.  Raw magnetic field information alone is not enough to provide accurate\ncompass headings. Therefore, the  accelerometer  is used in\nconjunction with the magnetometer to reduce the inaccuracy of the magnetometer reading.  The magnetometer is inaccurate because it considers all 3 planes: x, y and z.\nThe heading North only exists in the horizontal planes (x and y), therefore we only\nneed values in these planes. The accelerometer is used to filter out the vertical plane (z)\nto make our headings far more accurate. You can see this in action when calibrating the compass.  After calibration has been performed, the end product is an e-compass!  The micro:bit uses the  NXP MAG3110 .", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/compass/#real-time-updates", 
            "text": "When using the standard uBit presentation, the compass is continuously updated\nin the background using an idle thread (after it is first used), which is executed\nwhenever the micro:bit has no other tasks to perform.  If there is no scheduler running, the values are synchronously read on  get[X,Y,Z]()  and  heading() \ncalls. Additionally, if you would like to drive compass updates manually  updateSample() \ncan be used.", 
            "title": "Real time updates"
        }, 
        {
            "location": "/ubit/compass/#message-bus-id", 
            "text": "Constant  Value      MICROBIT_ID_COMPASS  5", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/compass/#message-bus-events", 
            "text": "Constant  Value      MICROBIT_COMPASS_EVT_CAL_REQUIRED  1  (DEPRECATED)    MICROBIT_COMPASS_EVT_CAL_START  2  (DEPRECATED)    MICROBIT_COMPASS_EVT_CAL_END  3  (DEPRECATED)    MICROBIT_COMPASS_EVT_DATA_UPDATE  4    MICROBIT_COMPASS_EVT_CONFIG_NEEDED  5    MICROBIT_COMPASS_EVT_CALIBRATE  6", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/compass/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/compass/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitaccelerometer-_accelerometer-microbitstorage-_storage", 
            "text": "", 
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitAccelerometer  &amp; _accelerometer,  MicroBitStorage  &amp; _storage)"
        }, 
        {
            "location": "/ubit/compass/#description", 
            "text": "Constructor. Create a software representation of an e-compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters", 
            "text": "MicroBitI2C     _i2c  - an instance of i2c, which the compass is accessible from.  MicroBitAccelerometer     _accelerometer  - an instance of the accelerometer, used for tilt compensation.  MicroBitStorage     _storage  - an instance of  MicroBitStorage , used to persist calibration data across resets.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, accelerometer, storage);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitaccelerometer-_accelerometer-microbitstorage-_storage-uint16_t-address", 
            "text": "", 
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitAccelerometer  &amp; _accelerometer,  MicroBitStorage  &amp; _storage,  uint16_t address)"
        }, 
        {
            "location": "/ubit/compass/#description_1", 
            "text": "Constructor. Create a software representation of an e-compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_1", 
            "text": "MicroBitI2C     _i2c  - an instance of i2c, which the compass is accessible from.  MicroBitAccelerometer     _accelerometer  - an instance of the accelerometer, used for tilt compensation.  MicroBitStorage     _storage  - an instance of  MicroBitStorage , used to persist calibration data across resets.  uint16_t   address  - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example_1", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, accelerometer, storage);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitaccelerometer-_accelerometer-microbitstorage-_storage-uint16_t-address-uint16_t-id", 
            "text": "", 
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitAccelerometer  &amp; _accelerometer,  MicroBitStorage  &amp; _storage,  uint16_t address,  uint16_t id)"
        }, 
        {
            "location": "/ubit/compass/#description_2", 
            "text": "Constructor. Create a software representation of an e-compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_2", 
            "text": "MicroBitI2C     _i2c  - an instance of i2c, which the compass is accessible from.  MicroBitAccelerometer     _accelerometer  - an instance of the accelerometer, used for tilt compensation.  MicroBitStorage     _storage  - an instance of  MicroBitStorage , used to persist calibration data across resets.  uint16_t   address  - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.  uint16_t   id  - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example_2", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, accelerometer, storage);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitaccelerometer-_accelerometer", 
            "text": "", 
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitAccelerometer  &amp; _accelerometer)"
        }, 
        {
            "location": "/ubit/compass/#description_3", 
            "text": "Constructor. Create a software representation of an e-compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_3", 
            "text": "MicroBitI2C     _i2c  - an instance of i2c, which the compass is accessible from.  MicroBitAccelerometer     _accelerometer  - an instance of the accelerometer, used for tilt compensation.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example_3", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitCompass compass(i2c, accelerometer, storage);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitaccelerometer-_accelerometer-uint16_t-address", 
            "text": "", 
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitAccelerometer  &amp; _accelerometer,  uint16_t address)"
        }, 
        {
            "location": "/ubit/compass/#description_4", 
            "text": "Constructor. Create a software representation of an e-compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_4", 
            "text": "MicroBitI2C     _i2c  - an instance of i2c, which the compass is accessible from.  MicroBitAccelerometer     _accelerometer  - an instance of the accelerometer, used for tilt compensation.  uint16_t   address  - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example_4", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitCompass compass(i2c, accelerometer, storage);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitaccelerometer-_accelerometer-uint16_t-address-uint16_t-id", 
            "text": "", 
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitAccelerometer  &amp; _accelerometer,  uint16_t address,  uint16_t id)"
        }, 
        {
            "location": "/ubit/compass/#description_5", 
            "text": "Constructor. Create a software representation of an e-compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_5", 
            "text": "MicroBitI2C     _i2c  - an instance of i2c, which the compass is accessible from.  MicroBitAccelerometer     _accelerometer  - an instance of the accelerometer, used for tilt compensation.  uint16_t   address  - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.  uint16_t   id  - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example_5", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitAccelerometer accelerometer(i2c); \n\n MicroBitCompass compass(i2c, accelerometer, storage);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitstorage-_storage", 
            "text": "", 
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitStorage  &amp; _storage)"
        }, 
        {
            "location": "/ubit/compass/#description_6", 
            "text": "Constructor. Create a software representation of an e-compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_6", 
            "text": "MicroBitI2C     _i2c  - an instance of i2c, which the compass is accessible from.  MicroBitStorage     _storage  - an instance of  MicroBitStorage , used to persist calibration data across resets.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example_6", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, storage);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitstorage-_storage-uint16_t-address", 
            "text": "", 
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitStorage  &amp; _storage,  uint16_t address)"
        }, 
        {
            "location": "/ubit/compass/#description_7", 
            "text": "Constructor. Create a software representation of an e-compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_7", 
            "text": "MicroBitI2C     _i2c  - an instance of i2c, which the compass is accessible from.  MicroBitStorage     _storage  - an instance of  MicroBitStorage , used to persist calibration data across resets.  uint16_t   address  - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example_7", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, storage);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-microbiti2c-_i2c-microbitstorage-_storage-uint16_t-address-uint16_t-id", 
            "text": "", 
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  MicroBitStorage  &amp; _storage,  uint16_t address,  uint16_t id)"
        }, 
        {
            "location": "/ubit/compass/#description_8", 
            "text": "Constructor. Create a software representation of an e-compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_8", 
            "text": "MicroBitI2C     _i2c  - an instance of i2c, which the compass is accessible from.  MicroBitStorage     _storage  - an instance of  MicroBitStorage , used to persist calibration data across resets.  uint16_t   address  - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.  uint16_t   id  - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example_8", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitStorage storage; \n\n MicroBitCompass compass(i2c, storage);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-microbiti2c-_i2c", 
            "text": "", 
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c)"
        }, 
        {
            "location": "/ubit/compass/#description_9", 
            "text": "Constructor. Create a software representation of an e-compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_9", 
            "text": "MicroBitI2C     _i2c  - an instance of i2c, which the compass is accessible from.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example_9", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitCompass compass(i2c);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-microbiti2c-_i2c-uint16_t-address", 
            "text": "", 
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  uint16_t address)"
        }, 
        {
            "location": "/ubit/compass/#description_10", 
            "text": "Constructor. Create a software representation of an e-compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_10", 
            "text": "MicroBitI2C     _i2c  - an instance of i2c, which the compass is accessible from.  uint16_t   address  - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example_10", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitCompass compass(i2c);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#microbitcompass-microbiti2c-_i2c-uint16_t-address-uint16_t-id", 
            "text": "", 
            "title": "MicroBitCompass( MicroBitI2C  &amp; _i2c,  uint16_t address,  uint16_t id)"
        }, 
        {
            "location": "/ubit/compass/#description_11", 
            "text": "Constructor. Create a software representation of an e-compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_11", 
            "text": "MicroBitI2C     _i2c  - an instance of i2c, which the compass is accessible from.  uint16_t   address  - the default address for the compass register on the i2c bus. Defaults to MAG3110_DEFAULT_ADDR.  uint16_t   id  - the ID of the new  MicroBitCompass  object. Defaults to MAG3110_DEFAULT_ADDR.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#example_11", 
            "text": "MicroBitI2C i2c(I2C_SDA0, I2C_SCL0); \n\n MicroBitCompass compass(i2c);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#configure", 
            "text": "", 
            "title": "configure"
        }, 
        {
            "location": "/ubit/compass/#int-configure", 
            "text": "", 
            "title": "int configure()"
        }, 
        {
            "location": "/ubit/compass/#description_12", 
            "text": "Configures the compass for the sample rate defined in this object. The nearest values are chosen to those defined that are supported by the hardware. The instance variables are then updated to reflect reality.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns", 
            "text": "MICROBIT_OK or MICROBIT_I2C_ERROR if the magnetometer could not be configured.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#setperiod", 
            "text": "", 
            "title": "setPeriod"
        }, 
        {
            "location": "/ubit/compass/#int-setperiod-int-period", 
            "text": "", 
            "title": "int setPeriod( int period)"
        }, 
        {
            "location": "/ubit/compass/#description_13", 
            "text": "Attempts to set the sample rate of the compass to the specified value (in ms).", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_12", 
            "text": "int   period  - the requested time between samples, in milliseconds.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#returns_1", 
            "text": "MICROBIT_OK or MICROBIT_I2C_ERROR if the magnetometer could not be updated.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_12", 
            "text": "// sample rate is now 20 ms. \n compass.setPeriod(20);    Note  The requested rate may not be possible on the hardware. In this case, the nearest lower rate is chosen.", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#getperiod", 
            "text": "", 
            "title": "getPeriod"
        }, 
        {
            "location": "/ubit/compass/#int-getperiod", 
            "text": "", 
            "title": "int getPeriod()"
        }, 
        {
            "location": "/ubit/compass/#description_14", 
            "text": "Reads the currently configured sample rate of the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_2", 
            "text": "The time between samples, in milliseconds.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#heading", 
            "text": "", 
            "title": "heading"
        }, 
        {
            "location": "/ubit/compass/#int-heading", 
            "text": "", 
            "title": "int heading()"
        }, 
        {
            "location": "/ubit/compass/#description_15", 
            "text": "Gets the current heading of the device, relative to magnetic north.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_3", 
            "text": "the current heading, in degrees. Or MICROBIT_CALIBRATION_IN_PROGRESS if the compass is calibrating.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_13", 
            "text": "compass.heading();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#whoami", 
            "text": "", 
            "title": "whoAmI"
        }, 
        {
            "location": "/ubit/compass/#int-whoami", 
            "text": "", 
            "title": "int whoAmI()"
        }, 
        {
            "location": "/ubit/compass/#description_16", 
            "text": "Attempts to read the 8 bit ID from the magnetometer, this can be used for validation purposes.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_4", 
            "text": "the 8 bit ID returned by the magnetometer, or MICROBIT_I2C_ERROR if the request fails.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_14", 
            "text": "compass.whoAmI();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#getx", 
            "text": "", 
            "title": "getX"
        }, 
        {
            "location": "/ubit/compass/#int-getx", 
            "text": "", 
            "title": "int getX()"
        }, 
        {
            "location": "/ubit/compass/#description_17", 
            "text": "Reads the value of the X axis from the latest update retrieved from the magnetometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_5", 
            "text": "The magnetic force measured in the X axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_15", 
            "text": "compass.getX();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#int-getx-microbitcoordinatesystem-system", 
            "text": "", 
            "title": "int getX( MicroBitCoordinateSystem system)"
        }, 
        {
            "location": "/ubit/compass/#description_18", 
            "text": "Reads the value of the X axis from the latest update retrieved from the magnetometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_13", 
            "text": "MicroBitCoordinateSystem   system  - The coordinate system to use. By default, a simple cartesian system is provided.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#returns_6", 
            "text": "The magnetic force measured in the X axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_16", 
            "text": "compass.getX();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#gety", 
            "text": "", 
            "title": "getY"
        }, 
        {
            "location": "/ubit/compass/#int-gety", 
            "text": "", 
            "title": "int getY()"
        }, 
        {
            "location": "/ubit/compass/#description_19", 
            "text": "Reads the value of the Y axis from the latest update retrieved from the magnetometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_7", 
            "text": "The magnetic force measured in the Y axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_17", 
            "text": "compass.getY();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#int-gety-microbitcoordinatesystem-system", 
            "text": "", 
            "title": "int getY( MicroBitCoordinateSystem system)"
        }, 
        {
            "location": "/ubit/compass/#description_20", 
            "text": "Reads the value of the Y axis from the latest update retrieved from the magnetometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_14", 
            "text": "MicroBitCoordinateSystem   system  - The coordinate system to use. By default, a simple cartesian system is provided.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#returns_8", 
            "text": "The magnetic force measured in the Y axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_18", 
            "text": "compass.getY();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#getz", 
            "text": "", 
            "title": "getZ"
        }, 
        {
            "location": "/ubit/compass/#int-getz", 
            "text": "", 
            "title": "int getZ()"
        }, 
        {
            "location": "/ubit/compass/#description_21", 
            "text": "Reads the value of the Z axis from the latest update retrieved from the magnetometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_9", 
            "text": "The magnetic force measured in the Z axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_19", 
            "text": "compass.getZ();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#int-getz-microbitcoordinatesystem-system", 
            "text": "", 
            "title": "int getZ( MicroBitCoordinateSystem system)"
        }, 
        {
            "location": "/ubit/compass/#description_22", 
            "text": "Reads the value of the Z axis from the latest update retrieved from the magnetometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_15", 
            "text": "MicroBitCoordinateSystem   system  - The coordinate system to use. By default, a simple cartesian system is provided.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#returns_10", 
            "text": "The magnetic force measured in the Z axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_20", 
            "text": "compass.getZ();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#getfieldstrength", 
            "text": "", 
            "title": "getFieldStrength"
        }, 
        {
            "location": "/ubit/compass/#int-getfieldstrength", 
            "text": "", 
            "title": "int getFieldStrength()"
        }, 
        {
            "location": "/ubit/compass/#description_23", 
            "text": "Determines the overall magnetic field strength based on the latest update from the magnetometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_11", 
            "text": "The magnetic force measured across all axis, in nano teslas.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#example_21", 
            "text": "compass.getFieldStrength();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/compass/#readtemperature", 
            "text": "", 
            "title": "readTemperature"
        }, 
        {
            "location": "/ubit/compass/#int-readtemperature", 
            "text": "", 
            "title": "int readTemperature()"
        }, 
        {
            "location": "/ubit/compass/#description_24", 
            "text": "Reads the current die temperature of the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_12", 
            "text": "the temperature in degrees celsius, or MICROBIT_I2C_ERROR if the temperature reading could not be retreived from the accelerometer.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#calibrate", 
            "text": "", 
            "title": "calibrate"
        }, 
        {
            "location": "/ubit/compass/#int-calibrate", 
            "text": "", 
            "title": "int calibrate()"
        }, 
        {
            "location": "/ubit/compass/#description_25", 
            "text": "Perform a calibration of the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_13", 
            "text": "MICROBIT_OK, MICROBIT_I2C_ERROR if the magnetometer could not be accessed, or MICROBIT_CALIBRATION_REQUIRED if the calibration algorithm failed to complete successfully.   Note  THIS MUST BE CALLED TO GAIN RELIABLE VALUES FROM THE COMPASS", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#setcalibration", 
            "text": "", 
            "title": "setCalibration"
        }, 
        {
            "location": "/ubit/compass/#void-setcalibration-compasssample-calibration", 
            "text": "", 
            "title": "void setCalibration( CompassSample calibration)"
        }, 
        {
            "location": "/ubit/compass/#description_26", 
            "text": "Configure the compass to use the calibration data that is supplied to this call.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#parameters_16", 
            "text": "CompassSample   calibration  - A  CompassSample  containing the offsets for the x, y and z axis.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/compass/#getcalibration", 
            "text": "", 
            "title": "getCalibration"
        }, 
        {
            "location": "/ubit/compass/#compasssample-getcalibration", 
            "text": "", 
            "title": "CompassSample getCalibration()"
        }, 
        {
            "location": "/ubit/compass/#description_27", 
            "text": "Provides the calibration data currently in use by the compass.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#returns_14", 
            "text": "calibration A  CompassSample  containing the offsets for the x, y and z axis.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/compass/#updatesample", 
            "text": "", 
            "title": "updateSample"
        }, 
        {
            "location": "/ubit/compass/#int-updatesample", 
            "text": "", 
            "title": "int updateSample()"
        }, 
        {
            "location": "/ubit/compass/#description_28", 
            "text": "Updates the local sample, only if the compass indicates that data is stale.   Note  Can be used to trigger manual updates, if the device is running without a scheduler. Also called internally by all get X,Y,Z  member functions.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#iscalibrated", 
            "text": "", 
            "title": "isCalibrated"
        }, 
        {
            "location": "/ubit/compass/#int-iscalibrated", 
            "text": "", 
            "title": "int isCalibrated()"
        }, 
        {
            "location": "/ubit/compass/#description_29", 
            "text": "Returns 0 or 1. 1 indicates that the compass is calibrated, zero means the compass requires calibration.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#iscalibrating", 
            "text": "", 
            "title": "isCalibrating"
        }, 
        {
            "location": "/ubit/compass/#int-iscalibrating", 
            "text": "", 
            "title": "int isCalibrating()"
        }, 
        {
            "location": "/ubit/compass/#description_30", 
            "text": "Returns 0 or 1. 1 indicates that the compass is calibrating, zero means the compass is not currently calibrating.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#clearcalibration", 
            "text": "", 
            "title": "clearCalibration"
        }, 
        {
            "location": "/ubit/compass/#void-clearcalibration", 
            "text": "", 
            "title": "void clearCalibration()"
        }, 
        {
            "location": "/ubit/compass/#description_31", 
            "text": "Clears the calibration held in persistent storage, and sets the calibrated flag to zero.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/compass/#isidlecallbackneeded", 
            "text": "", 
            "title": "isIdleCallbackNeeded"
        }, 
        {
            "location": "/ubit/compass/#int-isidlecallbackneeded", 
            "text": "", 
            "title": "int isIdleCallbackNeeded()"
        }, 
        {
            "location": "/ubit/compass/#description_32", 
            "text": "Returns 0 or 1. 1 indicates data is waiting to be read, zero means data is not ready to be read.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/", 
            "text": "uBit.thermometer\n\n\nOverview\n\n\nMicroBitThermometer provides access to the surface temperature of the nrf51822.\nThe temperature reading therefore is not representative of the ambient temperature,\nbut rather the temperature relative to the surface temperature of the chip.\n\n\nHowever, we can make it representative of the ambient temperature in software\nthrough \"calibrating\" the thermometer.\n\n\nCalibration is very simple, and is calculated by giving the current temperature\nto the \nsetCalibration()\n member function. From the temperature, an offset is\ncalculated, and is subsequently used to offset future temperature readings.\n\n\nReal time updates\n\n\nWhen using the standard uBit presentation, the thermometer is continuously updated\nin the background using an idle thread (after it is first used), which is executed\nwhenever the micro:bit has no other tasks to perform.\n\n\nIf there is no scheduler running, the values are synchronously read on \ngetTemperature()\n\ncalls. Additionally, if you would like to drive thermometer updates manually \nupdateSample()\n\ncan be used.\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_THERMOMETER\n\n\n28\n\n\n\n\n\n\n\n\nMessage Bus Events\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_THERMOMETER_EVT_UPDATE\n\n\n1\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitThermometer( \nMicroBitStorage  \n _storage)\n\n\nDescription\n\n\nConstructor. Create new  MicroBitThermometer\n\n\nParameters\n\n\n\n\nMicroBitStorage  \n \n_storage\n - an instance of  MicroBitStorage  used to persist temperature offset data\n\n\n\n\nExample\n\n\n MicroBitStorage storage; \n MicroBitThermometer thermometer(storage); \n\n\n\n\n\n\nMicroBitThermometer( \nMicroBitStorage  \n _storage,  \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor. Create new  MicroBitThermometer\n\n\nParameters\n\n\n\n\nMicroBitStorage  \n \n_storage\n - an instance of  MicroBitStorage  used to persist temperature offset data\n\n\nuint16_t\n \nid\n - the unique  EventModel  id of this component. Defaults to MICROBIT_ID_THERMOMETER.\n\n\n\n\nExample\n\n\n MicroBitStorage storage; \n MicroBitThermometer thermometer(storage); \n\n\n\n\n\n\nMicroBitThermometer()\n\n\nDescription\n\n\nConstructor. Create new  MicroBitThermometer\n\n\nExample\n\n\n MicroBitThermometer thermometer; \n\n\n\n\n\n\nMicroBitThermometer( \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor. Create new  MicroBitThermometer\n\n\nParameters\n\n\n\n\nuint16_t\n \nid\n - the unique  EventModel  id of this component. Defaults to MICROBIT_ID_THERMOMETER.\n\n\n\n\nExample\n\n\n MicroBitThermometer thermometer; \n\n\n\n\nsetPeriod\n\n\n\n\nvoid\n setPeriod( \nint\n period)\n\n\nDescription\n\n\nSet the sample rate at which the temperatureis read (in ms).\n\n\nParameters\n\n\n\n\nint\n \nperiod\n - the requested time between samples, in milliseconds.\n\n\n\n\n\n\nNote\n\n\nthe temperature is always read in the background, and is only updated when the processor is idle, or when the temperature is explicitly read. \n\n\n\n\ngetPeriod\n\n\n\n\nint\n getPeriod()\n\n\nDescription\n\n\nReads the currently configured sample rate of the thermometer.\n\n\nReturns\n\n\nThe time between samples, in milliseconds. \n\n\nsetOffset\n\n\n\n\nint\n setOffset( \nint\n offset)\n\n\nDescription\n\n\nSet the value that is used to offset the raw silicon temperature.\n\n\nParameters\n\n\n\n\nint\n \noffset\n - the offset for the silicon temperature\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success \n\n\ngetOffset\n\n\n\n\nint\n getOffset()\n\n\nDescription\n\n\nRetreive the value that is used to offset the raw silicon temperature.\n\n\nReturns\n\n\nthe current offset. \n\n\nsetCalibration\n\n\n\n\nint\n setCalibration( \nint\n calibrationTemp)\n\n\nDescription\n\n\nThis member function fetches the raw silicon temperature, and calculates the value used to offset the raw silicon temperature based on a given temperature.\n\n\nParameters\n\n\n\n\nint\n \ncalibrationTemp\n - the temperature used to calculate the raw silicon temperature offset.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success \n\n\ngetTemperature\n\n\n\n\nint\n getTemperature()\n\n\nDescription\n\n\nGets the current temperature of the microbit.\n\n\nReturns\n\n\nthe current temperature, in degrees celsius.\n\n\nExample\n\n\n thermometer.getTemperature(); \n\n\n\n\nupdateSample\n\n\n\n\nint\n updateSample()\n\n\nDescription\n\n\nUpdates the temperature sample of this instance of  MicroBitThermometer isSampleNeeded()\n\n\nReturns\n\n\nMICROBIT_OK on success. \n\n\nisIdleCallbackNeeded\n\n\n\n\nint\n isIdleCallbackNeeded()\n\n\nDescription\n\n\nIndicates if we'd like some processor time to sense the temperature.\n\n\nReturns\n\n\n1 if we'd like some processor time, 0 otherwise.", 
            "title": "thermometer"
        }, 
        {
            "location": "/ubit/thermometer/#ubitthermometer", 
            "text": "", 
            "title": "uBit.thermometer"
        }, 
        {
            "location": "/ubit/thermometer/#overview", 
            "text": "MicroBitThermometer provides access to the surface temperature of the nrf51822.\nThe temperature reading therefore is not representative of the ambient temperature,\nbut rather the temperature relative to the surface temperature of the chip.  However, we can make it representative of the ambient temperature in software\nthrough \"calibrating\" the thermometer.  Calibration is very simple, and is calculated by giving the current temperature\nto the  setCalibration()  member function. From the temperature, an offset is\ncalculated, and is subsequently used to offset future temperature readings.", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/thermometer/#real-time-updates", 
            "text": "When using the standard uBit presentation, the thermometer is continuously updated\nin the background using an idle thread (after it is first used), which is executed\nwhenever the micro:bit has no other tasks to perform.  If there is no scheduler running, the values are synchronously read on  getTemperature() \ncalls. Additionally, if you would like to drive thermometer updates manually  updateSample() \ncan be used.", 
            "title": "Real time updates"
        }, 
        {
            "location": "/ubit/thermometer/#message-bus-id", 
            "text": "Constant  Value      MICROBIT_ID_THERMOMETER  28", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/thermometer/#message-bus-events", 
            "text": "Constant  Value      MICROBIT_THERMOMETER_EVT_UPDATE  1", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/thermometer/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/thermometer/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/thermometer/#microbitthermometer-microbitstorage-_storage", 
            "text": "", 
            "title": "MicroBitThermometer( MicroBitStorage  &amp; _storage)"
        }, 
        {
            "location": "/ubit/thermometer/#description", 
            "text": "Constructor. Create new  MicroBitThermometer", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#parameters", 
            "text": "MicroBitStorage     _storage  - an instance of  MicroBitStorage  used to persist temperature offset data", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/thermometer/#example", 
            "text": "MicroBitStorage storage; \n MicroBitThermometer thermometer(storage);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/thermometer/#microbitthermometer-microbitstorage-_storage-uint16_t-id", 
            "text": "", 
            "title": "MicroBitThermometer( MicroBitStorage  &amp; _storage,  uint16_t id)"
        }, 
        {
            "location": "/ubit/thermometer/#description_1", 
            "text": "Constructor. Create new  MicroBitThermometer", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#parameters_1", 
            "text": "MicroBitStorage     _storage  - an instance of  MicroBitStorage  used to persist temperature offset data  uint16_t   id  - the unique  EventModel  id of this component. Defaults to MICROBIT_ID_THERMOMETER.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/thermometer/#example_1", 
            "text": "MicroBitStorage storage; \n MicroBitThermometer thermometer(storage);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/thermometer/#microbitthermometer", 
            "text": "", 
            "title": "MicroBitThermometer()"
        }, 
        {
            "location": "/ubit/thermometer/#description_2", 
            "text": "Constructor. Create new  MicroBitThermometer", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#example_2", 
            "text": "MicroBitThermometer thermometer;", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/thermometer/#microbitthermometer-uint16_t-id", 
            "text": "", 
            "title": "MicroBitThermometer( uint16_t id)"
        }, 
        {
            "location": "/ubit/thermometer/#description_3", 
            "text": "Constructor. Create new  MicroBitThermometer", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#parameters_2", 
            "text": "uint16_t   id  - the unique  EventModel  id of this component. Defaults to MICROBIT_ID_THERMOMETER.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/thermometer/#example_3", 
            "text": "MicroBitThermometer thermometer;", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/thermometer/#setperiod", 
            "text": "", 
            "title": "setPeriod"
        }, 
        {
            "location": "/ubit/thermometer/#void-setperiod-int-period", 
            "text": "", 
            "title": "void setPeriod( int period)"
        }, 
        {
            "location": "/ubit/thermometer/#description_4", 
            "text": "Set the sample rate at which the temperatureis read (in ms).", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#parameters_3", 
            "text": "int   period  - the requested time between samples, in milliseconds.    Note  the temperature is always read in the background, and is only updated when the processor is idle, or when the temperature is explicitly read.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/thermometer/#getperiod", 
            "text": "", 
            "title": "getPeriod"
        }, 
        {
            "location": "/ubit/thermometer/#int-getperiod", 
            "text": "", 
            "title": "int getPeriod()"
        }, 
        {
            "location": "/ubit/thermometer/#description_5", 
            "text": "Reads the currently configured sample rate of the thermometer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#returns", 
            "text": "The time between samples, in milliseconds.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/thermometer/#setoffset", 
            "text": "", 
            "title": "setOffset"
        }, 
        {
            "location": "/ubit/thermometer/#int-setoffset-int-offset", 
            "text": "", 
            "title": "int setOffset( int offset)"
        }, 
        {
            "location": "/ubit/thermometer/#description_6", 
            "text": "Set the value that is used to offset the raw silicon temperature.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#parameters_4", 
            "text": "int   offset  - the offset for the silicon temperature", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/thermometer/#returns_1", 
            "text": "MICROBIT_OK on success", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/thermometer/#getoffset", 
            "text": "", 
            "title": "getOffset"
        }, 
        {
            "location": "/ubit/thermometer/#int-getoffset", 
            "text": "", 
            "title": "int getOffset()"
        }, 
        {
            "location": "/ubit/thermometer/#description_7", 
            "text": "Retreive the value that is used to offset the raw silicon temperature.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#returns_2", 
            "text": "the current offset.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/thermometer/#setcalibration", 
            "text": "", 
            "title": "setCalibration"
        }, 
        {
            "location": "/ubit/thermometer/#int-setcalibration-int-calibrationtemp", 
            "text": "", 
            "title": "int setCalibration( int calibrationTemp)"
        }, 
        {
            "location": "/ubit/thermometer/#description_8", 
            "text": "This member function fetches the raw silicon temperature, and calculates the value used to offset the raw silicon temperature based on a given temperature.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#parameters_5", 
            "text": "int   calibrationTemp  - the temperature used to calculate the raw silicon temperature offset.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/thermometer/#returns_3", 
            "text": "MICROBIT_OK on success", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/thermometer/#gettemperature", 
            "text": "", 
            "title": "getTemperature"
        }, 
        {
            "location": "/ubit/thermometer/#int-gettemperature", 
            "text": "", 
            "title": "int getTemperature()"
        }, 
        {
            "location": "/ubit/thermometer/#description_9", 
            "text": "Gets the current temperature of the microbit.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#returns_4", 
            "text": "the current temperature, in degrees celsius.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/thermometer/#example_4", 
            "text": "thermometer.getTemperature();", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/thermometer/#updatesample", 
            "text": "", 
            "title": "updateSample"
        }, 
        {
            "location": "/ubit/thermometer/#int-updatesample", 
            "text": "", 
            "title": "int updateSample()"
        }, 
        {
            "location": "/ubit/thermometer/#description_10", 
            "text": "Updates the temperature sample of this instance of  MicroBitThermometer isSampleNeeded()", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#returns_5", 
            "text": "MICROBIT_OK on success.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/thermometer/#isidlecallbackneeded", 
            "text": "", 
            "title": "isIdleCallbackNeeded"
        }, 
        {
            "location": "/ubit/thermometer/#int-isidlecallbackneeded", 
            "text": "", 
            "title": "int isIdleCallbackNeeded()"
        }, 
        {
            "location": "/ubit/thermometer/#description_11", 
            "text": "Indicates if we'd like some processor time to sense the temperature.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/thermometer/#returns_6", 
            "text": "1 if we'd like some processor time, 0 otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/", 
            "text": "uBit.io\n\n\nOverview\n\n\nuBit.io\n provides a means of accessing the pins exposed on the edge connector,\nenabling Analog and Digital Input/Output operations. Some pins can also perform\nbasic touch sensing through resistance detection.\n\n\nThere are 6 Analog capable pins which can be used to generate Analog wave forms\nand approximate Analog inputs. There is only one Analog to Digital converter on\nthe NRF51822, which prevents concurrent analog to digital conversions.\n\n\nAnalog waveforms are simulated via Pulse Width Modulation generated by software.\nAs such, there is a limit of \n3\n concurrent PWM outputs.\n\n\nThere are two ways of accessing pins on the edge connector:\n\n\n\n\nuBit.io.P0.setDigitalValue(1)\n - Would configure P0 as a digital output, and set that pin HI.\n\n\nuBit.io.pin[1].setDigitalValue(1)\n - Would configure P1 as a digital output, and set that pin HI.\n\n\n\n\nBy design, the operation of the pins on the edge connector are dynamic, and can swap between\nmodes based on the method that as been called.\n\n\nFor example:\n\n\nwhile(1)\n{\n    uBit.io.P0.setDigitalValue(1);\n    uBit.sleep(1000);\n    uBit.io.P0.setServoValue(90);\n    uBit.sleep(1000);\n}\n\n\n\n\nWill transition between Digital and Analog output every second.\n\n\nShared Functionality\n\n\nAs well as being General Purpose Input Output (\nGPIO\n) pins, some pins on the\nmicro:bit have other functionality used internally by the micro:bit.\n\n\nTherefore, some functionality on the micro:bit may have to be disabled in order\nto use some GPIO pins.\n\n\nThis is illustrated by the diagram below:\n\n\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\nCapability\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_IO_P0\n\n\n7\n\n\nAnalog, digital and touch\n\n\n\n\n\n\nMICROBIT_ID_IO_P1\n\n\n8\n\n\nAnalog, digital and touch\n\n\n\n\n\n\nMICROBIT_ID_IO_P2\n\n\n9\n\n\nAnalog, digital and touch\n\n\n\n\n\n\nMICROBIT_ID_IO_P3\n\n\n10\n\n\nAnalog and digital\n\n\n\n\n\n\nMICROBIT_ID_IO_P4\n\n\n11\n\n\nAnalog and digital\n\n\n\n\n\n\nMICROBIT_ID_IO_P5\n\n\n12\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P6\n\n\n13\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P7\n\n\n14\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P8\n\n\n15\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P9\n\n\n16\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P10\n\n\n17\n\n\nAnalog and digital\n\n\n\n\n\n\nMICROBIT_ID_IO_P11\n\n\n18\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P12\n\n\n19\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P13\n\n\n20\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P14\n\n\n21\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P15\n\n\n22\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P16\n\n\n23\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P19\n\n\n24\n\n\nDigital only\n\n\n\n\n\n\nMICROBIT_ID_IO_P20\n\n\n25\n\n\nDigital only\n\n\n\n\n\n\n\n\nMessage Bus Events\n\n\nWhen \nisTouched()\n is called, provided that the selected pin has touch capabilities\n(outlined above), an instance of \nbutton\n will be created. Listeners\ncan therefore be placed using the desired pins' ID, with the exact same events\nproduced by a standard \nbutton\n.\n\n\nuBit.messageBus.listen(MICROBIT_ID_IO_P0, MICROBIT_EVT_ANY, someFunction);\nuBit.io.P0.isTouched();\n\n\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOWN\n\n\n1\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_UP\n\n\n2\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_CLICK\n\n\n3\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_LONG_CLICK\n\n\n4\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_HOLD\n\n\n5\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOUBLE_CLICK\n\n\n6\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitPin( \nint\n id,  \nPinName\n name,  \nPinCapability\n capability)\n\n\nDescription\n\n\nConstructor. Create a  MicroBitPin\n\n\nParameters\n\n\n\n\nint\n \nid\n - the unique  EventModel  id of this component.\n\n\nPinName\n \nname\n - the mbed PinName for this  MicroBitPin  instance.\n\n\nPinCapability\n \ncapability\n - the capabilities this  MicroBitPin  instance should have. (PIN_CAPABILITY_DIGITAL, PIN_CAPABILITY_ANALOG, PIN_CAPABILITY_TOUCH, PIN_CAPABILITY_AD, PIN_CAPABILITY_ALL)\n\n\n\n\nExample\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_ALL); \n\n\n\n\nsetDigitalValue\n\n\n\n\nint\n setDigitalValue( \nint\n value)\n\n\nDescription\n\n\nConfigures this IO pin as a digital output (if necessary) and sets the pin to 'value'.\n\n\nParameters\n\n\n\n\nint\n \nvalue\n - 0 (LO) or 1 (HI)\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have digital capability.\n\n\nExample\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.setDigitalValue(1); // P0 is now HI \n\n\n\n\ngetDigitalValue\n\n\n\n\nint\n getDigitalValue()\n\n\nDescription\n\n\nConfigures this IO pin as a digital input (if necessary) and tests its current value.\n\n\nReturns\n\n\n1 if this input is high, 0 if input is LO, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.\n\n\nExample\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.getDigitalValue(); // P0 is either 0 or 1; \n\n\n\n\nsetAnalogValue\n\n\n\n\nint\n setAnalogValue( \nint\n value)\n\n\nDescription\n\n\nConfigures this IO pin as an analog/pwm output, and change the output value to the given level.\n\n\nParameters\n\n\n\n\nint\n \nvalue\n - the level to set on the output pin, in the range 0 - 1024\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability. \n\n\nsetServoValue\n\n\n\n\nint\n setServoValue( \nint\n value)\n\n\nDescription\n\n\nConfigures this IO pin as an analog/pwm output (if necessary) and configures the period to be 20ms, with a duty cycle between 500 us and 2500 us.\n\n\nParameters\n\n\n\n\nint\n \nvalue\n - the level to set on the output pin, in the range 0 - 180.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability. \n\n\n\nint\n setServoValue( \nint\n value,  \nint\n range)\n\n\nDescription\n\n\nConfigures this IO pin as an analog/pwm output (if necessary) and configures the period to be 20ms, with a duty cycle between 500 us and 2500 us.\n\n\nParameters\n\n\n\n\nint\n \nvalue\n - the level to set on the output pin, in the range 0 - 180.\n\n\nint\n \nrange\n - which gives the span of possible values the i.e. the lower and upper bounds (center +/- range/2). Defaults to MICROBIT_PIN_DEFAULT_SERVO_RANGE.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability. \n\n\n\nint\n setServoValue( \nint\n value,  \nint\n range,  \nint\n center)\n\n\nDescription\n\n\nConfigures this IO pin as an analog/pwm output (if necessary) and configures the period to be 20ms, with a duty cycle between 500 us and 2500 us.\n\n\nParameters\n\n\n\n\nint\n \nvalue\n - the level to set on the output pin, in the range 0 - 180.\n\n\nint\n \nrange\n - which gives the span of possible values the i.e. the lower and upper bounds (center +/- range/2). Defaults to MICROBIT_PIN_DEFAULT_SERVO_RANGE.\n\n\nint\n \ncenter\n - the center point from which to calculate the lower and upper bounds. Defaults to MICROBIT_PIN_DEFAULT_SERVO_CENTER\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability. \n\n\ngetAnalogValue\n\n\n\n\nint\n getAnalogValue()\n\n\nDescription\n\n\nConfigures this IO pin as an analogue input (if necessary), and samples the Pin for its analog value.\n\n\nReturns\n\n\nthe current analogue level on the pin, in the range 0 - 1024, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.\n\n\nExample\n\n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.getAnalogValue(); // P0 is a value in the range of 0 - 1024 \n\n\n\n\nisInput\n\n\n\n\nint\n isInput()\n\n\nDescription\n\n\nDetermines if this IO pin is currently configured as an input.\n\n\nReturns\n\n\n1 if pin is an analog or digital input, 0 otherwise. \n\n\nisOutput\n\n\n\n\nint\n isOutput()\n\n\nDescription\n\n\nDetermines if this IO pin is currently configured as an output.\n\n\nReturns\n\n\n1 if pin is an analog or digital output, 0 otherwise. \n\n\nisDigital\n\n\n\n\nint\n isDigital()\n\n\nDescription\n\n\nDetermines if this IO pin is currently configured for digital use.\n\n\nReturns\n\n\n1 if pin is digital, 0 otherwise. \n\n\nisAnalog\n\n\n\n\nint\n isAnalog()\n\n\nDescription\n\n\nDetermines if this IO pin is currently configured for analog use.\n\n\nReturns\n\n\n1 if pin is analog, 0 otherwise. \n\n\nisTouched\n\n\n\n\nint\n isTouched()\n\n\nDescription\n\n\nConfigures this IO pin as a \"makey makey\" style touch sensor (if necessary) and tests its current debounced state.\n\n\nReturns\n\n\n1 if pin is touched, 0 if not, or MICROBIT_NOT_SUPPORTED if this pin does not support touch capability.\n\n\nExample\n\n\n MicroBitMessageBus bus; \n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_ALL); \n if(P0.isTouched()) \n { \n //do something! \n } \n\n // subscribe to events generated by this pin! \n bus.listen(MICROBIT_ID_IO_P0, MICROBIT_BUTTON_EVT_CLICK, someFunction); \n\n\n\n\nsetServoPulseUs\n\n\n\n\nint\n setServoPulseUs( \nint\n pulseWidth)\n\n\nDescription\n\n\nConfigures this IO pin as an analog/pwm output if it isn't already, configures the period to be 20ms, and sets the pulse width, based on the value it is given.\n\n\nParameters\n\n\n\n\nint\n \npulseWidth\n - the desired pulse width in microseconds.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability. \n\n\nsetAnalogPeriod\n\n\n\n\nint\n setAnalogPeriod( \nint\n period)\n\n\nDescription\n\n\nConfigures the PWM period of the analog output to the given value.\n\n\nParameters\n\n\n\n\nint\n \nperiod\n - The new period for the analog output in milliseconds.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output. \n\n\nsetAnalogPeriodUs\n\n\n\n\nint\n setAnalogPeriodUs( \nint\n period)\n\n\nDescription\n\n\nConfigures the PWM period of the analog output to the given value.\n\n\nParameters\n\n\n\n\nint\n \nperiod\n - The new period for the analog output in microseconds.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output. \n\n\ngetAnalogPeriodUs\n\n\n\n\nint\n getAnalogPeriodUs()\n\n\nDescription\n\n\nObtains the PWM period of the analog output in microseconds.\n\n\nReturns\n\n\nthe period on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output. \n\n\ngetAnalogPeriod\n\n\n\n\nint\n getAnalogPeriod()\n\n\nDescription\n\n\nObtains the PWM period of the analog output in milliseconds.\n\n\nReturns\n\n\nthe period on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.", 
            "title": "io"
        }, 
        {
            "location": "/ubit/io/#ubitio", 
            "text": "", 
            "title": "uBit.io"
        }, 
        {
            "location": "/ubit/io/#overview", 
            "text": "uBit.io  provides a means of accessing the pins exposed on the edge connector,\nenabling Analog and Digital Input/Output operations. Some pins can also perform\nbasic touch sensing through resistance detection.  There are 6 Analog capable pins which can be used to generate Analog wave forms\nand approximate Analog inputs. There is only one Analog to Digital converter on\nthe NRF51822, which prevents concurrent analog to digital conversions.  Analog waveforms are simulated via Pulse Width Modulation generated by software.\nAs such, there is a limit of  3  concurrent PWM outputs.  There are two ways of accessing pins on the edge connector:   uBit.io.P0.setDigitalValue(1)  - Would configure P0 as a digital output, and set that pin HI.  uBit.io.pin[1].setDigitalValue(1)  - Would configure P1 as a digital output, and set that pin HI.   By design, the operation of the pins on the edge connector are dynamic, and can swap between\nmodes based on the method that as been called.  For example:  while(1)\n{\n    uBit.io.P0.setDigitalValue(1);\n    uBit.sleep(1000);\n    uBit.io.P0.setServoValue(90);\n    uBit.sleep(1000);\n}  Will transition between Digital and Analog output every second.", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/io/#shared-functionality", 
            "text": "As well as being General Purpose Input Output ( GPIO ) pins, some pins on the\nmicro:bit have other functionality used internally by the micro:bit.  Therefore, some functionality on the micro:bit may have to be disabled in order\nto use some GPIO pins.  This is illustrated by the diagram below:", 
            "title": "Shared Functionality"
        }, 
        {
            "location": "/ubit/io/#message-bus-id", 
            "text": "Constant  Value  Capability      MICROBIT_ID_IO_P0  7  Analog, digital and touch    MICROBIT_ID_IO_P1  8  Analog, digital and touch    MICROBIT_ID_IO_P2  9  Analog, digital and touch    MICROBIT_ID_IO_P3  10  Analog and digital    MICROBIT_ID_IO_P4  11  Analog and digital    MICROBIT_ID_IO_P5  12  Digital only    MICROBIT_ID_IO_P6  13  Digital only    MICROBIT_ID_IO_P7  14  Digital only    MICROBIT_ID_IO_P8  15  Digital only    MICROBIT_ID_IO_P9  16  Digital only    MICROBIT_ID_IO_P10  17  Analog and digital    MICROBIT_ID_IO_P11  18  Digital only    MICROBIT_ID_IO_P12  19  Digital only    MICROBIT_ID_IO_P13  20  Digital only    MICROBIT_ID_IO_P14  21  Digital only    MICROBIT_ID_IO_P15  22  Digital only    MICROBIT_ID_IO_P16  23  Digital only    MICROBIT_ID_IO_P19  24  Digital only    MICROBIT_ID_IO_P20  25  Digital only", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/io/#message-bus-events", 
            "text": "When  isTouched()  is called, provided that the selected pin has touch capabilities\n(outlined above), an instance of  button  will be created. Listeners\ncan therefore be placed using the desired pins' ID, with the exact same events\nproduced by a standard  button .  uBit.messageBus.listen(MICROBIT_ID_IO_P0, MICROBIT_EVT_ANY, someFunction);\nuBit.io.P0.isTouched();     Constant  Value      MICROBIT_BUTTON_EVT_DOWN  1    MICROBIT_BUTTON_EVT_UP  2    MICROBIT_BUTTON_EVT_CLICK  3    MICROBIT_BUTTON_EVT_LONG_CLICK  4    MICROBIT_BUTTON_EVT_HOLD  5    MICROBIT_BUTTON_EVT_DOUBLE_CLICK  6", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/io/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/io/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/io/#microbitpin-int-id-pinname-name-pincapability-capability", 
            "text": "", 
            "title": "MicroBitPin( int id,  PinName name,  PinCapability capability)"
        }, 
        {
            "location": "/ubit/io/#description", 
            "text": "Constructor. Create a  MicroBitPin", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters", 
            "text": "int   id  - the unique  EventModel  id of this component.  PinName   name  - the mbed PinName for this  MicroBitPin  instance.  PinCapability   capability  - the capabilities this  MicroBitPin  instance should have. (PIN_CAPABILITY_DIGITAL, PIN_CAPABILITY_ANALOG, PIN_CAPABILITY_TOUCH, PIN_CAPABILITY_AD, PIN_CAPABILITY_ALL)", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#example", 
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_ALL);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/io/#setdigitalvalue", 
            "text": "", 
            "title": "setDigitalValue"
        }, 
        {
            "location": "/ubit/io/#int-setdigitalvalue-int-value", 
            "text": "", 
            "title": "int setDigitalValue( int value)"
        }, 
        {
            "location": "/ubit/io/#description_1", 
            "text": "Configures this IO pin as a digital output (if necessary) and sets the pin to 'value'.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_1", 
            "text": "int   value  - 0 (LO) or 1 (HI)", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have digital capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#example_1", 
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.setDigitalValue(1); // P0 is now HI", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/io/#getdigitalvalue", 
            "text": "", 
            "title": "getDigitalValue"
        }, 
        {
            "location": "/ubit/io/#int-getdigitalvalue", 
            "text": "", 
            "title": "int getDigitalValue()"
        }, 
        {
            "location": "/ubit/io/#description_2", 
            "text": "Configures this IO pin as a digital input (if necessary) and tests its current value.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_1", 
            "text": "1 if this input is high, 0 if input is LO, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#example_2", 
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.getDigitalValue(); // P0 is either 0 or 1;", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/io/#setanalogvalue", 
            "text": "", 
            "title": "setAnalogValue"
        }, 
        {
            "location": "/ubit/io/#int-setanalogvalue-int-value", 
            "text": "", 
            "title": "int setAnalogValue( int value)"
        }, 
        {
            "location": "/ubit/io/#description_3", 
            "text": "Configures this IO pin as an analog/pwm output, and change the output value to the given level.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_2", 
            "text": "int   value  - the level to set on the output pin, in the range 0 - 1024", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_2", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#setservovalue", 
            "text": "", 
            "title": "setServoValue"
        }, 
        {
            "location": "/ubit/io/#int-setservovalue-int-value", 
            "text": "", 
            "title": "int setServoValue( int value)"
        }, 
        {
            "location": "/ubit/io/#description_4", 
            "text": "Configures this IO pin as an analog/pwm output (if necessary) and configures the period to be 20ms, with a duty cycle between 500 us and 2500 us.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_3", 
            "text": "int   value  - the level to set on the output pin, in the range 0 - 180.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_3", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#int-setservovalue-int-value-int-range", 
            "text": "", 
            "title": "int setServoValue( int value,  int range)"
        }, 
        {
            "location": "/ubit/io/#description_5", 
            "text": "Configures this IO pin as an analog/pwm output (if necessary) and configures the period to be 20ms, with a duty cycle between 500 us and 2500 us.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_4", 
            "text": "int   value  - the level to set on the output pin, in the range 0 - 180.  int   range  - which gives the span of possible values the i.e. the lower and upper bounds (center +/- range/2). Defaults to MICROBIT_PIN_DEFAULT_SERVO_RANGE.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_4", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#int-setservovalue-int-value-int-range-int-center", 
            "text": "", 
            "title": "int setServoValue( int value,  int range,  int center)"
        }, 
        {
            "location": "/ubit/io/#description_6", 
            "text": "Configures this IO pin as an analog/pwm output (if necessary) and configures the period to be 20ms, with a duty cycle between 500 us and 2500 us.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_5", 
            "text": "int   value  - the level to set on the output pin, in the range 0 - 180.  int   range  - which gives the span of possible values the i.e. the lower and upper bounds (center +/- range/2). Defaults to MICROBIT_PIN_DEFAULT_SERVO_RANGE.  int   center  - the center point from which to calculate the lower and upper bounds. Defaults to MICROBIT_PIN_DEFAULT_SERVO_CENTER", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_5", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#getanalogvalue", 
            "text": "", 
            "title": "getAnalogValue"
        }, 
        {
            "location": "/ubit/io/#int-getanalogvalue", 
            "text": "", 
            "title": "int getAnalogValue()"
        }, 
        {
            "location": "/ubit/io/#description_7", 
            "text": "Configures this IO pin as an analogue input (if necessary), and samples the Pin for its analog value.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_6", 
            "text": "the current analogue level on the pin, in the range 0 - 1024, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#example_3", 
            "text": "MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_BOTH); \n P0.getAnalogValue(); // P0 is a value in the range of 0 - 1024", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/io/#isinput", 
            "text": "", 
            "title": "isInput"
        }, 
        {
            "location": "/ubit/io/#int-isinput", 
            "text": "", 
            "title": "int isInput()"
        }, 
        {
            "location": "/ubit/io/#description_8", 
            "text": "Determines if this IO pin is currently configured as an input.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_7", 
            "text": "1 if pin is an analog or digital input, 0 otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#isoutput", 
            "text": "", 
            "title": "isOutput"
        }, 
        {
            "location": "/ubit/io/#int-isoutput", 
            "text": "", 
            "title": "int isOutput()"
        }, 
        {
            "location": "/ubit/io/#description_9", 
            "text": "Determines if this IO pin is currently configured as an output.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_8", 
            "text": "1 if pin is an analog or digital output, 0 otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#isdigital", 
            "text": "", 
            "title": "isDigital"
        }, 
        {
            "location": "/ubit/io/#int-isdigital", 
            "text": "", 
            "title": "int isDigital()"
        }, 
        {
            "location": "/ubit/io/#description_10", 
            "text": "Determines if this IO pin is currently configured for digital use.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_9", 
            "text": "1 if pin is digital, 0 otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#isanalog", 
            "text": "", 
            "title": "isAnalog"
        }, 
        {
            "location": "/ubit/io/#int-isanalog", 
            "text": "", 
            "title": "int isAnalog()"
        }, 
        {
            "location": "/ubit/io/#description_11", 
            "text": "Determines if this IO pin is currently configured for analog use.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_10", 
            "text": "1 if pin is analog, 0 otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#istouched", 
            "text": "", 
            "title": "isTouched"
        }, 
        {
            "location": "/ubit/io/#int-istouched", 
            "text": "", 
            "title": "int isTouched()"
        }, 
        {
            "location": "/ubit/io/#description_12", 
            "text": "Configures this IO pin as a \"makey makey\" style touch sensor (if necessary) and tests its current debounced state.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_11", 
            "text": "1 if pin is touched, 0 if not, or MICROBIT_NOT_SUPPORTED if this pin does not support touch capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#example_4", 
            "text": "MicroBitMessageBus bus; \n\n MicroBitPin P0(MICROBIT_ID_IO_P0, MICROBIT_PIN_P0, PIN_CAPABILITY_ALL); \n if(P0.isTouched()) \n { \n //do something! \n } \n\n // subscribe to events generated by this pin! \n bus.listen(MICROBIT_ID_IO_P0, MICROBIT_BUTTON_EVT_CLICK, someFunction);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/io/#setservopulseus", 
            "text": "", 
            "title": "setServoPulseUs"
        }, 
        {
            "location": "/ubit/io/#int-setservopulseus-int-pulsewidth", 
            "text": "", 
            "title": "int setServoPulseUs( int pulseWidth)"
        }, 
        {
            "location": "/ubit/io/#description_13", 
            "text": "Configures this IO pin as an analog/pwm output if it isn't already, configures the period to be 20ms, and sets the pulse width, based on the value it is given.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_6", 
            "text": "int   pulseWidth  - the desired pulse width in microseconds.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_12", 
            "text": "MICROBIT_OK on success, MICROBIT_INVALID_PARAMETER if value is out of range, or MICROBIT_NOT_SUPPORTED if the given pin does not have analog capability.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#setanalogperiod", 
            "text": "", 
            "title": "setAnalogPeriod"
        }, 
        {
            "location": "/ubit/io/#int-setanalogperiod-int-period", 
            "text": "", 
            "title": "int setAnalogPeriod( int period)"
        }, 
        {
            "location": "/ubit/io/#description_14", 
            "text": "Configures the PWM period of the analog output to the given value.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_7", 
            "text": "int   period  - The new period for the analog output in milliseconds.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_13", 
            "text": "MICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#setanalogperiodus", 
            "text": "", 
            "title": "setAnalogPeriodUs"
        }, 
        {
            "location": "/ubit/io/#int-setanalogperiodus-int-period", 
            "text": "", 
            "title": "int setAnalogPeriodUs( int period)"
        }, 
        {
            "location": "/ubit/io/#description_15", 
            "text": "Configures the PWM period of the analog output to the given value.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#parameters_8", 
            "text": "int   period  - The new period for the analog output in microseconds.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/io/#returns_14", 
            "text": "MICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#getanalogperiodus", 
            "text": "", 
            "title": "getAnalogPeriodUs"
        }, 
        {
            "location": "/ubit/io/#int-getanalogperiodus", 
            "text": "", 
            "title": "int getAnalogPeriodUs()"
        }, 
        {
            "location": "/ubit/io/#description_16", 
            "text": "Obtains the PWM period of the analog output in microseconds.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_15", 
            "text": "the period on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/io/#getanalogperiod", 
            "text": "", 
            "title": "getAnalogPeriod"
        }, 
        {
            "location": "/ubit/io/#int-getanalogperiod", 
            "text": "", 
            "title": "int getAnalogPeriod()"
        }, 
        {
            "location": "/ubit/io/#description_17", 
            "text": "Obtains the PWM period of the analog output in milliseconds.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/io/#returns_16", 
            "text": "the period on success, or MICROBIT_NOT_SUPPORTED if the given pin is not configured as an analog output.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/ble/", 
            "text": "", 
            "title": "ble"
        }, 
        {
            "location": "/ubit/blemanager/", 
            "text": "", 
            "title": "bleManager"
        }, 
        {
            "location": "/ubit/radio/", 
            "text": "uBit.radio\n\n\nOverview\n\n\nThe central processor unit (CPU) on the micro:bit is a Nordic Semiconductor nrf51822. In addition to being a general purpose\ncomputer processor, this chip also contains a built-in 2.4GHz radio module.  This radio can be configured in a nummber of\nways, and is primarily designed to run the Bluetooth Low Energy (BLE) protocol. However, it can also be placed into a much\nsimpler mode of operation based that allows simple, direct micro:bit to micro:bit communication.\n\n\nThe MicroBitRadio component is made up of three classes - MicroBitRadio, MicroBitRadioEvent and MicroBitRadioDatagram. Together,\nthese provide the ability to send general purpose data packets from one micro:bit to another, and to extend a message bus to span multiple micro:bits...\nso if you raise an event on one micro:bit, you can receive it on another using the normal \nlisten\n mechanism!\n\n\n\n\nNote\n\n\nIt is not currenlty possible to run the MicroBitRadio component and Bluetooth Low Energy (BLE) at the same time. If you want to us the MicroBitRadio functionality, you need to disable the BLE stack on your micro:bit by compiling the runtime with '#define MICROBIT_BLE_ENABLED 0' in your inc/MicroBitConfig.h file.\n\n\n\n\nCapabilities\n\n\nThis component provides a very easy to use, flexible, broadcast radio channel. Anything you send from one micro:bit, can be received by any other micro:bits nearby. \nIt is designed to provide a powerful but simple introduction to the world of wireless communications, and can let you create a whole range of applications from \nbuilding your own friend detectors to creating remote control cars. \n\n\nA key principle of this component is \nprivacy\n, which is built in from the ground up. So, when you send any data, there is nothing inherent in this protocol\nwhich can be used to identify you or your micro:bit. All devices look identical. Therefore, if you want to be able to identify yourself, you need to add this to your own data.\n\n\n\n\n\n\n\n\n\n\nCapability\n\n\nBrief Description\n\n\n\n\n\n\n\n\n\n\nFrequency\n\n\n1MHz narrowband, typically 2.407 GHz. Use configurable in the 2.400 GHz - 2.499 GHz band.\n\n\n\n\n\n\nChannel Rate\n\n\n1Mbps.\n\n\n\n\n\n\nMaximum Transfer Unit\n\n\nTypically 32 bytes, but reconfigurable in code up to 1024 bytes.\n\n\n\n\n\n\nAddressing\n\n\nAll devices share the same address to guarantee user privacy.\n\n\n\n\n\n\nEncryption\n\n\nNone. User level encryption (or BLE) should be considered if secture channels are required.\n\n\n\n\n\n\nMeshing\n\n\nNone. (yet!)\n\n\n\n\n\n\nError Detection\n\n\n16 bit hardware CRC.\n\n\n\n\n\n\nTransmisson Power\n\n\nEight user configurable settings from 0 (-30dbm) to 7 (+4dbm).\n\n\n\n\n\n\nTransmisson Range\n\n\nApprox 20m at 0dbm.\n\n\n\n\n\n\n\n\nUsing MicroBitRadio\n\n\nTo write your radio enabled applicaitons, you will likely want to use either the MicroBiRadioDatagram class, or the MicroBitRadioEvent class.\nBoth of these are created for you as part of the standard uBit object, so this is a choice, not a compromise! :-)\n\n\nMicroBitRadioDatagram\n\n\nThis is the most flexible way to use the radio, and lets you easily send and receive up to 32 bytes of data at a time. \nThis data can be provided as array of bytes, a text string, or PacketBuffer. You can send a packet at any time using the\n'uBit.radio.datagram.send' function. Any other micro:bits in range will detect the transmitted packet, and make the packet available through the\n'uBit.radio.datagram.recv' function. Any micro:bits receiving a pdatagram packt will also raise a MICROBIT_RADIO_EVT_DATAGRAM event to indicate\nthat some data is ready to be read.\n\n\nFor example, imagine you were creating a simple remote control car with one micro:bit acting as a remote controller, and another connected to some servos on the car. \nYou might decide that simply sending a '1' means turn left, and a '2' means turn right, so you may write a program like this for the remote control:\n\n\nint main()\n{\n    uBit.radio.enable();\n\n    while(1)\n    {\n        if (uBit.buttonA.isPressed())\n            uBit.radio.datagram.send(\n1\n);\n\n        else if (uBit.buttonB.isPressed())\n            uBit.radio.datagram.send(\n2\n);\n\n        uBit.sleep(100);\n    } \n}\n\n\n\n\n...and one like this for the remote control car:\n\n\nvoid onData(MicroBitEvent e)\n{\n    ManagedString s = uBit.radio.datagram.recv();\n\n    if (s == \n1\n)\n        uBit.io.P0.setServoValue(0);\n\n    if (s == \n2\n)\n        uBit.io.P0.setServoValue(180);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_RADIO, MICROBIT_RADIO_EVT_DATAGRAM, onData);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}\n\n\n\n\nUsing PacketBuffers\n\n\nIf you prefer to send a raw series of bytes rather than a text string (which is much more common in communication networks), you can use the PacketBuffer type. \nThis gives total freedom over the data being shared. Simply create a PacketBuffer of the size you need, and you can read or write data using standard C\narray syntax. For example, here is an similar program using a PacketBuffers:\n\n\nint main()\n{\n    uBit.radio.enable();\n\n    // Create a packet containing just a single byte.\n    PacketBuffer b(1);\n\n    while(1)\n    {\n        b[0] = 0;\n        if (uBit.buttonA.isPressed())\n            b[0] = 1;\n\n        else if (uBit.buttonB.isPressed())\n            b[0] = 2;\n\n        uBit.radio.datagram.send(b);\n        uBit.sleep(100);\n    } \n}\n\n\n\n\n...and one like this for the remote control car:\n\n\nvoid onData(MicroBitEvent e)\n{\n    PacketBuffer p = uBit.radio.datagram.recv();\n\n    if (p[0] == 1)\n        uBit.io.P0.setServoValue(0);\n\n    if (p[0] == 2)\n        uBit.io.P0.setServoValue(180);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_RADIO, MICROBIT_RADIO_EVT_DATAGRAM, onData);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}\n\n\n\n\nMicroBitRadioEvent\n\n\nIt is also possible to transparently send and receive events over the MicroBitRadio channel. This can provide very simple and easy to integrate\nsupport for event driven applications. Once configured, an event raised on one micro:bit can be detected on another - in the just the same way as\na local event such as a button click.\n\n\nTo use this funcitonality, all that is needed is to register the event codes that you would like to be sent over the radio, then write event handlers\nfor the message bus as with all other events. See the documentation for the \nMicroBitMessageBus\n for details of how to write\nevent handlers. \n\n\nFor example, if you wanted to share an event SOMETHING with another micro:bit whenever ButtonA is pressed, you might write code like this on the sending micro:bit:\n\n\n#define MY_APP_ID           4000\n#define SOMETHING           1\n\nint main()\n{\n    uBit.radio.enable();\n\n    // Ensure the radio os listening out to forward our events\n    uBit.radio.event.listen(MY_APP_ID, MICROBIT_EVT_ANY);\n\n    while(1)\n    {\n        if (uBit.buttonA.isPressed())\n            MicroBitEvent(MY_APP_ID, SOMETHING);\n\n        uBit.sleep(1000);\n    } \n}\n\n\n\n\n...and on the micro:bits wanting to receive the event:\n\n\n#define MY_APP_ID           4000\n#define SOMETHING           1\n\nvoid onSomething(MicroBitEvent e)\n{\n    uBit.display.scrollAsync(\nSomething!\n);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MY_APP_ID, SOMETHING, onSomething);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}\n\n\n\n\nDefining Groups\n\n\nIt is easy to imagine situations where you would like to have different groups of micro:bits communicating independently. For example, consider a classroom where 8 groups of four children are working on different \nprojects - it would not be very useful if packets sent by one group interfered with the other groups! To address this, the MicroBitRadio allows users to define a \ngroup\n to which their micro:bit belongs. micro:bits can\nonly ever be a member of one group at a time, and any packets sent will only be received by  other micro:bits in the same group. Groups are simply numbers, and a micro:bit's group can be set at anytime by the programmer through the setGroup function. If a group is not specified, the default group of 0 will be used. For example:\n\n\n    uBit.radio.setGroup(10);\n\n\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_RADIO\n\n\n29\n\n\n\n\n\n\nMICROBIT_ID_RADIO_DATA_READY\n\n\n30\n\n\n\n\n\n\n\n\nMessage Bus Events\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_RADIO_EVT_DATAGRAM\n\n\n1\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitRadio()\n\n\nDescription\n\n\nConstructor.\n\n\n\n\nNote\n\n\nThis class is demand activated, as a result most resources are only committed if send/recv or event registrations calls are made. \n\n\n\n\n\n\nMicroBitRadio( \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nuint16_t\n \nid\n\n\n\n\n\n\nNote\n\n\nThis class is demand activated, as a result most resources are only committed if send/recv or event registrations calls are made. \n\n\n\n\nsetTransmitPower\n\n\n\n\nint\n setTransmitPower( \nint\n power)\n\n\nDescription\n\n\nChange the output power level of the transmitter to the given value.\n\n\nParameters\n\n\n\n\nint\n \npower\n - a value in the range 0..7, where 0 is the lowest power and 7 is the highest.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the value is out of range. \n\n\nsetFrequencyBand\n\n\n\n\nint\n setFrequencyBand( \nint\n band)\n\n\nDescription\n\n\nChange the transmission and reception band of the radio to the given channel\n\n\nParameters\n\n\n\n\nint\n \nband\n - a frequency band in the range 0 - 100. Each step is 1MHz wide, based at 2400MHz.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the value is out of range, or MICROBIT_NOT_SUPPORTED if the BLE stack is running. \n\n\ngetRxBuf\n\n\n\n\nFrameBuffer\n getRxBuf()\n\n\nDescription\n\n\nRetrieve a pointer to the currently allocated receive buffer. This is the area of memory actively being used by the radio hardware to store incoming data.\n\n\nReturns\n\n\na pointer to the current receive buffer. \n\n\nqueueRxBuf\n\n\n\n\nint\n queueRxBuf()\n\n\nDescription\n\n\nAttempt to queue a buffer received by the radio hardware, if sufficient space is available.\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NO_RESOURCES if a replacement receiver buffer could not be allocated (either by policy or memory exhaustion). \n\n\nsetRSSI\n\n\n\n\nint\n setRSSI( \nuint8_t\n rssi)\n\n\nDescription\n\n\nSets the RSSI for the most recent packet.\n\n\nParameters\n\n\n\n\nuint8_t\n \nrssi\n - the new rssi value.\n\n\n\n\n\n\nNote\n\n\nshould only be called from RADIO_IRQHandler... \n\n\n\n\ngetRSSI\n\n\n\n\nint\n getRSSI()\n\n\nDescription\n\n\nRetrieves the current RSSI for the most recent packet.\n\n\nReturns\n\n\nthe most recent RSSI value or MICROBIT_NOT_SUPPORTED if the BLE stack is running. \n\n\nenable\n\n\n\n\nint\n enable()\n\n\nDescription\n\n\nInitialises the radio for use as a multipoint sender/receiver\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_NOT_SUPPORTED if the BLE stack is running. \n\n\ndisable\n\n\n\n\nint\n disable()\n\n\nDescription\n\n\nDisables the radio for use as a multipoint sender/receiver.\n\n\nReturns\n\n\nMICROBIT_OK on success, MICROBIT_NOT_SUPPORTED if the BLE stack is running. \n\n\nsetGroup\n\n\n\n\nint\n setGroup( \nuint8_t\n group)\n\n\nDescription\n\n\nSets the radio to listen to packets sent with the given group id.\n\n\nParameters\n\n\n\n\nuint8_t\n \ngroup\n - The group to join. A micro:bit can only listen to one group ID at any time.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the BLE stack is running. \n\n\ndataReady\n\n\n\n\nint\n dataReady()\n\n\nDescription\n\n\nDetermines the number of packets ready to be processed.\n\n\nReturns\n\n\nThe number of packets in the receive buffer. \n\n\nrecv\n\n\n\n\nFrameBuffer\n recv()\n\n\nDescription\n\n\nRetrieves the next packet from the receive buffer. If a data packet is available, then it will be returned immediately to the caller. This call will also dequeue the buffer.\n\n\nReturns\n\n\nThe buffer containing the the packet. If no data is available, NULL is returned.\n\n\n\n\nNote\n\n\nOnce  recv()  has been called, it is the callers resposibility to delete the buffer when appropriate. \n\n\n\n\nsend\n\n\n\n\nint\n send( \nFrameBuffer  *\n buffer)\n\n\nDescription\n\n\nTransmits the given buffer onto the broadcast radio. The call will wait until the transmission of the packet has completed before returning.\n\n\nParameters\n\n\n\n\nFrameBuffer  \n \nbuffer*\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the BLE stack is running.", 
            "title": "radio"
        }, 
        {
            "location": "/ubit/radio/#ubitradio", 
            "text": "", 
            "title": "uBit.radio"
        }, 
        {
            "location": "/ubit/radio/#overview", 
            "text": "The central processor unit (CPU) on the micro:bit is a Nordic Semiconductor nrf51822. In addition to being a general purpose\ncomputer processor, this chip also contains a built-in 2.4GHz radio module.  This radio can be configured in a nummber of\nways, and is primarily designed to run the Bluetooth Low Energy (BLE) protocol. However, it can also be placed into a much\nsimpler mode of operation based that allows simple, direct micro:bit to micro:bit communication.  The MicroBitRadio component is made up of three classes - MicroBitRadio, MicroBitRadioEvent and MicroBitRadioDatagram. Together,\nthese provide the ability to send general purpose data packets from one micro:bit to another, and to extend a message bus to span multiple micro:bits...\nso if you raise an event on one micro:bit, you can receive it on another using the normal  listen  mechanism!   Note  It is not currenlty possible to run the MicroBitRadio component and Bluetooth Low Energy (BLE) at the same time. If you want to us the MicroBitRadio functionality, you need to disable the BLE stack on your micro:bit by compiling the runtime with '#define MICROBIT_BLE_ENABLED 0' in your inc/MicroBitConfig.h file.", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/radio/#capabilities", 
            "text": "This component provides a very easy to use, flexible, broadcast radio channel. Anything you send from one micro:bit, can be received by any other micro:bits nearby. \nIt is designed to provide a powerful but simple introduction to the world of wireless communications, and can let you create a whole range of applications from \nbuilding your own friend detectors to creating remote control cars.   A key principle of this component is  privacy , which is built in from the ground up. So, when you send any data, there is nothing inherent in this protocol\nwhich can be used to identify you or your micro:bit. All devices look identical. Therefore, if you want to be able to identify yourself, you need to add this to your own data.      Capability  Brief Description      Frequency  1MHz narrowband, typically 2.407 GHz. Use configurable in the 2.400 GHz - 2.499 GHz band.    Channel Rate  1Mbps.    Maximum Transfer Unit  Typically 32 bytes, but reconfigurable in code up to 1024 bytes.    Addressing  All devices share the same address to guarantee user privacy.    Encryption  None. User level encryption (or BLE) should be considered if secture channels are required.    Meshing  None. (yet!)    Error Detection  16 bit hardware CRC.    Transmisson Power  Eight user configurable settings from 0 (-30dbm) to 7 (+4dbm).    Transmisson Range  Approx 20m at 0dbm.", 
            "title": "Capabilities"
        }, 
        {
            "location": "/ubit/radio/#using-microbitradio", 
            "text": "To write your radio enabled applicaitons, you will likely want to use either the MicroBiRadioDatagram class, or the MicroBitRadioEvent class.\nBoth of these are created for you as part of the standard uBit object, so this is a choice, not a compromise! :-)", 
            "title": "Using MicroBitRadio"
        }, 
        {
            "location": "/ubit/radio/#microbitradiodatagram", 
            "text": "This is the most flexible way to use the radio, and lets you easily send and receive up to 32 bytes of data at a time. \nThis data can be provided as array of bytes, a text string, or PacketBuffer. You can send a packet at any time using the\n'uBit.radio.datagram.send' function. Any other micro:bits in range will detect the transmitted packet, and make the packet available through the\n'uBit.radio.datagram.recv' function. Any micro:bits receiving a pdatagram packt will also raise a MICROBIT_RADIO_EVT_DATAGRAM event to indicate\nthat some data is ready to be read.  For example, imagine you were creating a simple remote control car with one micro:bit acting as a remote controller, and another connected to some servos on the car. \nYou might decide that simply sending a '1' means turn left, and a '2' means turn right, so you may write a program like this for the remote control:  int main()\n{\n    uBit.radio.enable();\n\n    while(1)\n    {\n        if (uBit.buttonA.isPressed())\n            uBit.radio.datagram.send( 1 );\n\n        else if (uBit.buttonB.isPressed())\n            uBit.radio.datagram.send( 2 );\n\n        uBit.sleep(100);\n    } \n}  ...and one like this for the remote control car:  void onData(MicroBitEvent e)\n{\n    ManagedString s = uBit.radio.datagram.recv();\n\n    if (s ==  1 )\n        uBit.io.P0.setServoValue(0);\n\n    if (s ==  2 )\n        uBit.io.P0.setServoValue(180);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_RADIO, MICROBIT_RADIO_EVT_DATAGRAM, onData);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}", 
            "title": "MicroBitRadioDatagram"
        }, 
        {
            "location": "/ubit/radio/#using-packetbuffers", 
            "text": "If you prefer to send a raw series of bytes rather than a text string (which is much more common in communication networks), you can use the PacketBuffer type. \nThis gives total freedom over the data being shared. Simply create a PacketBuffer of the size you need, and you can read or write data using standard C\narray syntax. For example, here is an similar program using a PacketBuffers:  int main()\n{\n    uBit.radio.enable();\n\n    // Create a packet containing just a single byte.\n    PacketBuffer b(1);\n\n    while(1)\n    {\n        b[0] = 0;\n        if (uBit.buttonA.isPressed())\n            b[0] = 1;\n\n        else if (uBit.buttonB.isPressed())\n            b[0] = 2;\n\n        uBit.radio.datagram.send(b);\n        uBit.sleep(100);\n    } \n}  ...and one like this for the remote control car:  void onData(MicroBitEvent e)\n{\n    PacketBuffer p = uBit.radio.datagram.recv();\n\n    if (p[0] == 1)\n        uBit.io.P0.setServoValue(0);\n\n    if (p[0] == 2)\n        uBit.io.P0.setServoValue(180);\n}\n\nint main()\n{\n    uBit.messageBus.listen(MICROBIT_ID_RADIO, MICROBIT_RADIO_EVT_DATAGRAM, onData);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}", 
            "title": "Using PacketBuffers"
        }, 
        {
            "location": "/ubit/radio/#microbitradioevent", 
            "text": "It is also possible to transparently send and receive events over the MicroBitRadio channel. This can provide very simple and easy to integrate\nsupport for event driven applications. Once configured, an event raised on one micro:bit can be detected on another - in the just the same way as\na local event such as a button click.  To use this funcitonality, all that is needed is to register the event codes that you would like to be sent over the radio, then write event handlers\nfor the message bus as with all other events. See the documentation for the  MicroBitMessageBus  for details of how to write\nevent handlers.   For example, if you wanted to share an event SOMETHING with another micro:bit whenever ButtonA is pressed, you might write code like this on the sending micro:bit:  #define MY_APP_ID           4000\n#define SOMETHING           1\n\nint main()\n{\n    uBit.radio.enable();\n\n    // Ensure the radio os listening out to forward our events\n    uBit.radio.event.listen(MY_APP_ID, MICROBIT_EVT_ANY);\n\n    while(1)\n    {\n        if (uBit.buttonA.isPressed())\n            MicroBitEvent(MY_APP_ID, SOMETHING);\n\n        uBit.sleep(1000);\n    } \n}  ...and on the micro:bits wanting to receive the event:  #define MY_APP_ID           4000\n#define SOMETHING           1\n\nvoid onSomething(MicroBitEvent e)\n{\n    uBit.display.scrollAsync( Something! );\n}\n\nint main()\n{\n    uBit.messageBus.listen(MY_APP_ID, SOMETHING, onSomething);\n    uBit.radio.enable();\n\n    while(1)\n        uBit.sleep(1000);\n}", 
            "title": "MicroBitRadioEvent"
        }, 
        {
            "location": "/ubit/radio/#defining-groups", 
            "text": "It is easy to imagine situations where you would like to have different groups of micro:bits communicating independently. For example, consider a classroom where 8 groups of four children are working on different \nprojects - it would not be very useful if packets sent by one group interfered with the other groups! To address this, the MicroBitRadio allows users to define a  group  to which their micro:bit belongs. micro:bits can\nonly ever be a member of one group at a time, and any packets sent will only be received by  other micro:bits in the same group. Groups are simply numbers, and a micro:bit's group can be set at anytime by the programmer through the setGroup function. If a group is not specified, the default group of 0 will be used. For example:      uBit.radio.setGroup(10);", 
            "title": "Defining Groups"
        }, 
        {
            "location": "/ubit/radio/#message-bus-id", 
            "text": "Constant  Value      MICROBIT_ID_RADIO  29    MICROBIT_ID_RADIO_DATA_READY  30", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/radio/#message-bus-events", 
            "text": "Constant  Value      MICROBIT_RADIO_EVT_DATAGRAM  1", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/radio/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/radio/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/radio/#microbitradio", 
            "text": "", 
            "title": "MicroBitRadio()"
        }, 
        {
            "location": "/ubit/radio/#description", 
            "text": "Constructor.   Note  This class is demand activated, as a result most resources are only committed if send/recv or event registrations calls are made.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#microbitradio-uint16_t-id", 
            "text": "", 
            "title": "MicroBitRadio( uint16_t id)"
        }, 
        {
            "location": "/ubit/radio/#description_1", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#parameters", 
            "text": "uint16_t   id    Note  This class is demand activated, as a result most resources are only committed if send/recv or event registrations calls are made.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/radio/#settransmitpower", 
            "text": "", 
            "title": "setTransmitPower"
        }, 
        {
            "location": "/ubit/radio/#int-settransmitpower-int-power", 
            "text": "", 
            "title": "int setTransmitPower( int power)"
        }, 
        {
            "location": "/ubit/radio/#description_2", 
            "text": "Change the output power level of the transmitter to the given value.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#parameters_1", 
            "text": "int   power  - a value in the range 0..7, where 0 is the lowest power and 7 is the highest.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/radio/#returns", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the value is out of range.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#setfrequencyband", 
            "text": "", 
            "title": "setFrequencyBand"
        }, 
        {
            "location": "/ubit/radio/#int-setfrequencyband-int-band", 
            "text": "", 
            "title": "int setFrequencyBand( int band)"
        }, 
        {
            "location": "/ubit/radio/#description_3", 
            "text": "Change the transmission and reception band of the radio to the given channel", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#parameters_2", 
            "text": "int   band  - a frequency band in the range 0 - 100. Each step is 1MHz wide, based at 2400MHz.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/radio/#returns_1", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER if the value is out of range, or MICROBIT_NOT_SUPPORTED if the BLE stack is running.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#getrxbuf", 
            "text": "", 
            "title": "getRxBuf"
        }, 
        {
            "location": "/ubit/radio/#framebuffer-getrxbuf", 
            "text": "", 
            "title": "FrameBuffer getRxBuf()"
        }, 
        {
            "location": "/ubit/radio/#description_4", 
            "text": "Retrieve a pointer to the currently allocated receive buffer. This is the area of memory actively being used by the radio hardware to store incoming data.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_2", 
            "text": "a pointer to the current receive buffer.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#queuerxbuf", 
            "text": "", 
            "title": "queueRxBuf"
        }, 
        {
            "location": "/ubit/radio/#int-queuerxbuf", 
            "text": "", 
            "title": "int queueRxBuf()"
        }, 
        {
            "location": "/ubit/radio/#description_5", 
            "text": "Attempt to queue a buffer received by the radio hardware, if sufficient space is available.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_3", 
            "text": "MICROBIT_OK on success, or MICROBIT_NO_RESOURCES if a replacement receiver buffer could not be allocated (either by policy or memory exhaustion).", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#setrssi", 
            "text": "", 
            "title": "setRSSI"
        }, 
        {
            "location": "/ubit/radio/#int-setrssi-uint8_t-rssi", 
            "text": "", 
            "title": "int setRSSI( uint8_t rssi)"
        }, 
        {
            "location": "/ubit/radio/#description_6", 
            "text": "Sets the RSSI for the most recent packet.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#parameters_3", 
            "text": "uint8_t   rssi  - the new rssi value.    Note  should only be called from RADIO_IRQHandler...", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/radio/#getrssi", 
            "text": "", 
            "title": "getRSSI"
        }, 
        {
            "location": "/ubit/radio/#int-getrssi", 
            "text": "", 
            "title": "int getRSSI()"
        }, 
        {
            "location": "/ubit/radio/#description_7", 
            "text": "Retrieves the current RSSI for the most recent packet.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_4", 
            "text": "the most recent RSSI value or MICROBIT_NOT_SUPPORTED if the BLE stack is running.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#enable", 
            "text": "", 
            "title": "enable"
        }, 
        {
            "location": "/ubit/radio/#int-enable", 
            "text": "", 
            "title": "int enable()"
        }, 
        {
            "location": "/ubit/radio/#description_8", 
            "text": "Initialises the radio for use as a multipoint sender/receiver", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_5", 
            "text": "MICROBIT_OK on success, MICROBIT_NOT_SUPPORTED if the BLE stack is running.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#disable", 
            "text": "", 
            "title": "disable"
        }, 
        {
            "location": "/ubit/radio/#int-disable", 
            "text": "", 
            "title": "int disable()"
        }, 
        {
            "location": "/ubit/radio/#description_9", 
            "text": "Disables the radio for use as a multipoint sender/receiver.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_6", 
            "text": "MICROBIT_OK on success, MICROBIT_NOT_SUPPORTED if the BLE stack is running.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#setgroup", 
            "text": "", 
            "title": "setGroup"
        }, 
        {
            "location": "/ubit/radio/#int-setgroup-uint8_t-group", 
            "text": "", 
            "title": "int setGroup( uint8_t group)"
        }, 
        {
            "location": "/ubit/radio/#description_10", 
            "text": "Sets the radio to listen to packets sent with the given group id.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#parameters_4", 
            "text": "uint8_t   group  - The group to join. A micro:bit can only listen to one group ID at any time.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/radio/#returns_7", 
            "text": "MICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the BLE stack is running.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#dataready", 
            "text": "", 
            "title": "dataReady"
        }, 
        {
            "location": "/ubit/radio/#int-dataready", 
            "text": "", 
            "title": "int dataReady()"
        }, 
        {
            "location": "/ubit/radio/#description_11", 
            "text": "Determines the number of packets ready to be processed.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_8", 
            "text": "The number of packets in the receive buffer.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#recv", 
            "text": "", 
            "title": "recv"
        }, 
        {
            "location": "/ubit/radio/#framebuffer-recv", 
            "text": "", 
            "title": "FrameBuffer recv()"
        }, 
        {
            "location": "/ubit/radio/#description_12", 
            "text": "Retrieves the next packet from the receive buffer. If a data packet is available, then it will be returned immediately to the caller. This call will also dequeue the buffer.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#returns_9", 
            "text": "The buffer containing the the packet. If no data is available, NULL is returned.   Note  Once  recv()  has been called, it is the callers resposibility to delete the buffer when appropriate.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/radio/#send", 
            "text": "", 
            "title": "send"
        }, 
        {
            "location": "/ubit/radio/#int-send-framebuffer-buffer", 
            "text": "", 
            "title": "int send( FrameBuffer  * buffer)"
        }, 
        {
            "location": "/ubit/radio/#description_13", 
            "text": "Transmits the given buffer onto the broadcast radio. The call will wait until the transmission of the packet has completed before returning.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/radio/#parameters_5", 
            "text": "FrameBuffer     buffer*", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/radio/#returns_10", 
            "text": "MICROBIT_OK on success, or MICROBIT_NOT_SUPPORTED if the BLE stack is running.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/", 
            "text": "MicroBitImage\n\n\nOverview\n\n\nMicroBitImage represents a bitmap picture. Images can be of any size, and each pixel on the image has an individual brightness value in the range 0.255.\nOnce created, this class also provides functions to undertake graphical operations on that image, including setting pixels, cleaing the image, pasting one\nimage onto another at a given position, shifting the content of an image and comparing and copying images. It is designed to work with the MicroBitDisplay\nclass to allow the creation of animations and visual effects.\n\n\n\n\nNote\n\n\nThis is a \nmanaged type\n. This means that it will automatically use and release memory as needed. There is no need for you to explicitly free or release memory when your done - the memory will be freed as soon as the last piece of code stops using the data.\n\n\n\n\nCreating Images\n\n\nImages are easy to create - just create them like a variable, but provide the details requested in one of the constructor function shown below. This may sound complex, but is quite simple when you get used to it. For example, to create\na blank, 2x2 image:\n\n\n    MicroBitImage image(2,2);\n\n\n\n\nYou can also create one from a text string that represents the pixel values that you want. This is a really easy way to create icons and emojis in your code.\nThe string takes the form of a series of comma separate values. Each value is the brightness of a pixel, starting at the top left of your image and working\nto the right. Whenever you put a newline character '\\n' in your string, this moves onto a new line of pixels. So to create a 3x3 image that is a picture \nof a cross, you might write:\n\n\n    MicroBitImage cross(\n0,255,0\\n255,255,255\\n0,255,0\\n\n);\n\n\n\n\nManipulating Images\n\n\nOnce you have created an image, you can use any of the functions listed in the API below to change that image. For example, you can use 'setPixelValue' to change an individual pixel. In the example below, you can see how to\nchange the centre pixel in our cross image created earlier. Co-ordinates are indexed from zero, with the origin (0,0) being at the top left of the image.\n\n\n    cross.setPixelValue(1,1,0);\n\n\n\n\nYou can print characters onto an image...\n\n\n    MicroBitImage image(5,5);\n    image.print('J');\n\n\n\n\nYou can paste the content of one image onto another - either at the origin, or somewhere else:\n\n\n    MicroBitImage image(5,5);\n    image.paste(cross);\n\n\n\n\n    MicroBitImage image(5,5);\n    image.paste(cross, 1,1);\n\n\n\n\nand of course, you can display your image on the LEDs using the MicroBitDisplay class:\n\n\n    MicroBitImage image(5,5);\n    image.paste(cross);\n    uBit.display.print(image);\n\n\n\n\nComparing and Assigning Images\n\n\nMicroBitImage is a \nmanaged type\n, so you can pass images as parameters to functions, store then and assign them to other variables without any worry about memory leaks.\nThe type will count the number of times it is used, and will delete itself as soon as your image is not used anymore.\n\n\nYou can assign images just like any other variable. So this is perfectly permitted, and memory safe:\n\n\n    MicroBitImage cross(\n0,255,0\\n255,255,255\\n0,255,0\\n\n);\n    MicroBitImage img;\n\n    img = cross;\n    uBit.display.print(img);\n\n\n\n\nas is this:\n\n\nvoid doSomething(MicroBitImage i)\n{\n    uBit.display.print(img);\n}\n\nint main()\n{\n    MicroBitImage cross(\n0,255,0\\n255,255,255\\n0,255,0\\n\n);\n\n    doSomething(cross);\n}\n\n\n\n\nYou can also compare images:\n\n\n    MicroBitImage cross(\n0,255,0\\n255,255,255\\n0,255,0\\n\n);\n    MicroBitImage img;\n\n    img = cross;\n\n    if (img == cross)\n        uBit.display.scroll(\nSAME!\n);\n}\n\n\n\n\nStoring Images in Flash Memory\n\n\nThe micro:bit is a \nvery\n constrained device in terms of Random Access Memory (RAM). Unlike modern PCs that typically have over 4 Gigabytes of RAM (around four thousand million bytes!), the micro:bit has only 16 Kilobytes (16 thousand bytes!), and if you take a look at the memory map, you will see most of this is already committed to running the Bluetooth stack. By defualt, any MicroBitImage you create will be stored in this precious RAM, so that you have the ability to change it. However, it is not uncommon to have read-only images. in this case, we can store the image in FLASH memory (the same place as your program), of which the micro:bit has 256Kilobytes.  Should you want to create an store a constant image in flash, you can do so using the following constructor. This is a little more complicated, but can save you memory. if you create an image this way, not of the functions to\nchange the content will work on that image (e.g. setPixelValue, paste, etc).\n\n\n\n\nThe array of bytes should always start with 0xff, 0xff - which tell the runtime that this image is stored in FLASH memory.\n\n\nThe next number should be the width in pixels, followed by a zero.\n\n\nThe next number should be the heigth in pixels, followed by a zero.\n\n\nThe following bytes are then individual pixel brightness values, starting at the top left, then working left to right, top to bottom until the bottom right corner is reached.\n\n\n\n\n    const uint8_t heart[] __attribute__ ((aligned (4))) = { 0xff, 0xff, 10, 0, 5, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}; \n\n    MicroBitImage i((ImageData*)heart); \n    uBit.display.animate(i,5);\n}\n\n\n\n\nAPI\n\n\nleakData\n\n\n\n\nImageData\n leakData()\n\n\nDescription\n\n\nGet current ptr, do not decr() it, and set the current instance to empty image.\n\n\ngetBitmap\n\n\n\n\nuint8_t *\n getBitmap()\n\n\nDescription\n\n\nReturn a 2D array representing the bitmap image. \n\n\nConstructor\n\n\n\n\nMicroBitImage( \nImageData  *\n ptr)\n\n\nDescription\n\n\nConstructor. Create an image from a specially prepared constant array, with no copying. Will call ptr-\nincr().\n\n\nParameters\n\n\n\n\nImageData  \n \nptr* - The literal - first two bytes should be 0xff, then width, 0, height, 0, and the bitmap. Width and height are 16 bit. The literal has to be 4-byte aligned.\n\n\n\n\nExample\n\n\n static const uint8_t heart[] __attribute__ ((aligned (4))) = { 0xff, 0xff, 10, 0, 5, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i((ImageData*)(void*)heart); \n\n\n\n\n\n\nMicroBitImage()\n\n\nDescription\n\n\nDefault Constructor. Creates a new reference to the empty  MicroBitImage\n\n\nExample\n\n\n MicroBitImage i(); //an empty image instance \n\n\n\n\n\n\nMicroBitImage( \nconst  MicroBitImage  \n image)\n\n\nDescription\n\n\nCopy Constructor. Add ourselves as a reference to an existing  MicroBitImage\n\n\nParameters\n\n\n\n\nconst  MicroBitImage  \n \nimage\n - The  MicroBitImage  to reference.\n\n\n\n\nExample\n\n\n MicroBitImage i(\n0,1,0,1,0\\n\n); \n MicroBitImage i2(i); //points to i \n\n\n\n\n\n\nMicroBitImage( \nconst char *\n s)\n\n\nDescription\n\n\nConstructor. Create a blank bitmap representation of a given size.\n\n\nParameters\n\n\n\n\nconst char \n \ns* - A text based representation of the image given whitespace delimited numeric values.\n\n\n\n\nExample\n\n\n MicroBitImage i(\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\n); // 5x5 image \n\n\n\n\n\n\nMicroBitImage( \nconst int16_t\n x,  \nconst int16_t\n y)\n\n\nDescription\n\n\nConstructor. Create a blank bitmap representation of a given size.\n\n\nParameters\n\n\n\n\nconst int16_t\n \nx\n - the width of the image.\n\n\nconst int16_t\n \ny\n - the height of the image.\n\n\n\n\n\nMicroBitImage( \nconst int16_t\n x,  \nconst int16_t\n y,  \nconst uint8_t *\n bitmap)\n\n\nDescription\n\n\nConstructor. Create a bitmap representation of a given size, based on a given buffer.\n\n\nParameters\n\n\n\n\nconst int16_t\n \nx\n - the width of the image.\n\n\nconst int16_t\n \ny\n - the height of the image.\n\n\nconst uint8_t \n \nbitmap* - a 2D array representing the image.\n\n\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n\n\n\n\noperator=\n\n\n\n\nMicroBitImage\n operator=( \nconst  MicroBitImage  \n i)\n\n\nDescription\n\n\nCopy assign operation.\n\n\nParameters\n\n\n\n\nconst  MicroBitImage  \n \ni\n\n\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n MicroBitImage i1(); \n i1 = i; // i1 now references i \n\n\n\n\noperator==\n\n\n\n\nbool\n operator==( \nconst  MicroBitImage  \n i)\n\n\nDescription\n\n\nEquality operation.\n\n\nParameters\n\n\n\n\nconst  MicroBitImage  \n \ni\n - The  MicroBitImage  to test ourselves against.\n\n\n\n\nReturns\n\n\ntrue if this  MicroBitImage  is identical to the one supplied, false otherwise.\n\n\nExample\n\n\n MicroBitDisplay display; \n MicroBitImage i(); \n MicroBitImage i1(); \n\n if(i == i1) //will be true \n display.scroll(\ntrue\n); \n\n\n\n\nclear\n\n\n\n\nvoid\n clear()\n\n\nDescription\n\n\nResets all pixels in this image to 0.\n\n\nExample\n\n\n MicroBitImage i(\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\n); // 5x5 image \n i.clear(); \n\n\n\n\nsetPixelValue\n\n\n\n\nint\n setPixelValue( \nint16_t\n x,  \nint16_t\n y,  \nuint8_t\n value)\n\n\nDescription\n\n\nSets the pixel at the given co-ordinates to a given value.\n\n\nParameters\n\n\n\n\nint16_t\n \nx\n - The co-ordinate of the pixel to change.\n\n\nint16_t\n \ny\n - The co-ordinate of the pixel to change.\n\n\nuint8_t\n \nvalue\n - The new value of the pixel (the brightness level 0-255)\n\n\n\n\nReturns\n\n\nMICROBIT_OK, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicroBitImage i(\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\n); // 5x5 image \n i.setPixelValue(0,0,255); \n\n\n\n\n\n\nNote\n\n\nall coordinates originate from the top left of an image. \n\n\n\n\ngetPixelValue\n\n\n\n\nint\n getPixelValue( \nint16_t\n x,  \nint16_t\n y)\n\n\nDescription\n\n\nRetreives the value of a given pixel.\n\n\nParameters\n\n\n\n\nint16_t\n \nx\n - The x co-ordinate of the pixel to read. Must be within the dimensions of the image.\n\n\nint16_t\n \ny\n - The y co-ordinate of the pixel to read. Must be within the dimensions of the image.\n\n\n\n\nReturns\n\n\nThe value assigned to the given pixel location (the brightness level 0-255), or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicroBitImage i(\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n\n); // 5x5 image \n i.getPixelValue(0,0); //should be 0; \n\n\n\n\nprintImage\n\n\n\n\nint\n printImage( \nint16_t\n x,  \nint16_t\n y,  \nconst uint8_t *\n bitmap)\n\n\nDescription\n\n\nReplaces the content of this image with that of a given 2D array representing the image.\n\n\nParameters\n\n\n\n\nint16_t\n \nx\n - the width of the image. Must be within the dimensions of the image.\n\n\nint16_t\n \ny\n - the width of the image. Must be within the dimensions of the image.\n\n\nconst uint8_t \n \nbitmap* - a 2D array representing the image.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(); \n i.printImage(0,0,heart); \n\n\n\n\n\n\nNote\n\n\nall coordinates originate from the top left of an image. \n\n\n\n\npaste\n\n\n\n\nint\n paste( \nconst  MicroBitImage  \n image)\n\n\nDescription\n\n\nPastes a given bitmap at the given co-ordinates.\n\n\nParameters\n\n\n\n\nconst  MicroBitImage  \n \nimage\n - The  MicroBitImage  to paste.\n\n\n\n\nReturns\n\n\nThe number of pixels written.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart \n\n\n\n\n\n\nint\n paste( \nconst  MicroBitImage  \n image,  \nint16_t\n x)\n\n\nDescription\n\n\nPastes a given bitmap at the given co-ordinates.\n\n\nParameters\n\n\n\n\nconst  MicroBitImage  \n \nimage\n - The  MicroBitImage  to paste.\n\n\nint16_t\n \nx\n - The leftmost X co-ordinate in this image where the given image should be pasted. Defaults to 0.\n\n\n\n\nReturns\n\n\nThe number of pixels written.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart \n\n\n\n\n\n\nint\n paste( \nconst  MicroBitImage  \n image,  \nint16_t\n x,  \nint16_t\n y)\n\n\nDescription\n\n\nPastes a given bitmap at the given co-ordinates.\n\n\nParameters\n\n\n\n\nconst  MicroBitImage  \n \nimage\n - The  MicroBitImage  to paste.\n\n\nint16_t\n \nx\n - The leftmost X co-ordinate in this image where the given image should be pasted. Defaults to 0.\n\n\nint16_t\n \ny\n - The uppermost Y co-ordinate in this image where the given image should be pasted. Defaults to 0.\n\n\n\n\nReturns\n\n\nThe number of pixels written.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart \n\n\n\n\n\n\nint\n paste( \nconst  MicroBitImage  \n image,  \nint16_t\n x,  \nint16_t\n y,  \nuint8_t\n alpha)\n\n\nDescription\n\n\nPastes a given bitmap at the given co-ordinates.\n\n\nParameters\n\n\n\n\nconst  MicroBitImage  \n \nimage\n - The  MicroBitImage  to paste.\n\n\nint16_t\n \nx\n - The leftmost X co-ordinate in this image where the given image should be pasted. Defaults to 0.\n\n\nint16_t\n \ny\n - The uppermost Y co-ordinate in this image where the given image should be pasted. Defaults to 0.\n\n\nuint8_t\n \nalpha\n - set to 1 if transparency clear pixels in given image should be treated as transparent. Set to 0 otherwise. Defaults to 0.\n\n\n\n\nReturns\n\n\nThe number of pixels written.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart \n\n\n\n\nprint\n\n\n\n\nint\n print( \nchar\n c)\n\n\nDescription\n\n\nPrints a character to the display at the given location\n\n\nParameters\n\n\n\n\nchar\n \nc\n - The character to display.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicroBitImage i(5,5); \n i.print('a'); \n\n\n\n\n\n\nint\n print( \nchar\n c,  \nint16_t\n x)\n\n\nDescription\n\n\nPrints a character to the display at the given location\n\n\nParameters\n\n\n\n\nchar\n \nc\n - The character to display.\n\n\nint16_t\n \nx\n - The x co-ordinate of on the image to place the top left of the character. Defaults to 0.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicroBitImage i(5,5); \n i.print('a'); \n\n\n\n\n\n\nint\n print( \nchar\n c,  \nint16_t\n x,  \nint16_t\n y)\n\n\nDescription\n\n\nPrints a character to the display at the given location\n\n\nParameters\n\n\n\n\nchar\n \nc\n - The character to display.\n\n\nint16_t\n \nx\n - The x co-ordinate of on the image to place the top left of the character. Defaults to 0.\n\n\nint16_t\n \ny\n - The y co-ordinate of on the image to place the top left of the character. Defaults to 0.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n MicroBitImage i(5,5); \n i.print('a'); \n\n\n\n\nshiftLeft\n\n\n\n\nint\n shiftLeft( \nint16_t\n n)\n\n\nDescription\n\n\nShifts the pixels in this Image a given number of pixels to the left.\n\n\nParameters\n\n\n\n\nint16_t\n \nn\n - The number of pixels to shift.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.shiftLeft(5); // a small heart \n\n\n\n\nshiftRight\n\n\n\n\nint\n shiftRight( \nint16_t\n n)\n\n\nDescription\n\n\nShifts the pixels in this Image a given number of pixels to the right.\n\n\nParameters\n\n\n\n\nint16_t\n \nn\n - The number of pixels to shift.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.shiftLeft(5); // a small heart \n i.shiftRight(5); // a big heart \n\n\n\n\nshiftUp\n\n\n\n\nint\n shiftUp( \nint16_t\n n)\n\n\nDescription\n\n\nShifts the pixels in this Image a given number of pixels to upward.\n\n\nParameters\n\n\n\n\nint16_t\n \nn\n - The number of pixels to shift.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftUp(1); \n\n\n\n\nshiftDown\n\n\n\n\nint\n shiftDown( \nint16_t\n n)\n\n\nDescription\n\n\nShifts the pixels in this Image a given number of pixels to downward.\n\n\nParameters\n\n\n\n\nint16_t\n \nn\n - The number of pixels to shift.\n\n\n\n\nReturns\n\n\nMICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftDown(1); \n\n\n\n\ngetWidth\n\n\n\n\nint\n getWidth()\n\n\nDescription\n\n\nGets the width of this image.\n\n\nReturns\n\n\nThe width of this image.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getWidth(); // equals 10... \n\n\n\n\ngetHeight\n\n\n\n\nint\n getHeight()\n\n\nDescription\n\n\nGets the height of this image.\n\n\nReturns\n\n\nThe height of this image.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getHeight(); // equals 5... \n\n\n\n\ngetSize\n\n\n\n\nint\n getSize()\n\n\nDescription\n\n\nGets number of bytes in the bitmap, ie., width * height.\n\n\nReturns\n\n\nThe size of the bitmap.\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getSize(); // equals 50... \n\n\n\n\ntoString\n\n\n\n\nManagedString\n toString()\n\n\nDescription\n\n\nConverts the bitmap to a csv  ManagedString\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n uBit.serial.printString(i.toString()); // \n0,1,0,1,0,0,0,0,0,0\\n...\n \n\n\n\n\ncrop\n\n\n\n\nMicroBitImage\n crop( \nint\n startx,  \nint\n starty,  \nint\n finx,  \nint\n finy)\n\n\nDescription\n\n\nCrops the image to the given dimensions.\n\n\nParameters\n\n\n\n\nint\n \nstartx\n - the location to start the crop in the x-axis\n\n\nint\n \nstarty\n - the location to start the crop in the y-axis\n\n\nint\n \nfinx\n\n\nint\n \nfiny\n\n\n\n\nExample\n\n\n const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.crop(0,0,2,2).toString() // \n0,1\\n1,1\\n\n \n\n\n\n\nisReadOnly\n\n\n\n\nbool\n isReadOnly()\n\n\nDescription\n\n\nCheck if image is read-only (i.e., residing in flash). \n\n\nclone\n\n\n\n\nMicroBitImage\n clone()\n\n\nDescription\n\n\nCreate a copy of the image bitmap. Used particularly, when  isReadOnly()\n\n\nReturns\n\n\nan instance of  MicroBitImage  which can be modified independently of the current instance", 
            "title": "MicroBitImage"
        }, 
        {
            "location": "/data-types/image/#microbitimage", 
            "text": "", 
            "title": "MicroBitImage"
        }, 
        {
            "location": "/data-types/image/#overview", 
            "text": "MicroBitImage represents a bitmap picture. Images can be of any size, and each pixel on the image has an individual brightness value in the range 0.255.\nOnce created, this class also provides functions to undertake graphical operations on that image, including setting pixels, cleaing the image, pasting one\nimage onto another at a given position, shifting the content of an image and comparing and copying images. It is designed to work with the MicroBitDisplay\nclass to allow the creation of animations and visual effects.   Note  This is a  managed type . This means that it will automatically use and release memory as needed. There is no need for you to explicitly free or release memory when your done - the memory will be freed as soon as the last piece of code stops using the data.", 
            "title": "Overview"
        }, 
        {
            "location": "/data-types/image/#creating-images", 
            "text": "Images are easy to create - just create them like a variable, but provide the details requested in one of the constructor function shown below. This may sound complex, but is quite simple when you get used to it. For example, to create\na blank, 2x2 image:      MicroBitImage image(2,2);  You can also create one from a text string that represents the pixel values that you want. This is a really easy way to create icons and emojis in your code.\nThe string takes the form of a series of comma separate values. Each value is the brightness of a pixel, starting at the top left of your image and working\nto the right. Whenever you put a newline character '\\n' in your string, this moves onto a new line of pixels. So to create a 3x3 image that is a picture \nof a cross, you might write:      MicroBitImage cross( 0,255,0\\n255,255,255\\n0,255,0\\n );", 
            "title": "Creating Images"
        }, 
        {
            "location": "/data-types/image/#manipulating-images", 
            "text": "Once you have created an image, you can use any of the functions listed in the API below to change that image. For example, you can use 'setPixelValue' to change an individual pixel. In the example below, you can see how to\nchange the centre pixel in our cross image created earlier. Co-ordinates are indexed from zero, with the origin (0,0) being at the top left of the image.      cross.setPixelValue(1,1,0);  You can print characters onto an image...      MicroBitImage image(5,5);\n    image.print('J');  You can paste the content of one image onto another - either at the origin, or somewhere else:      MicroBitImage image(5,5);\n    image.paste(cross);      MicroBitImage image(5,5);\n    image.paste(cross, 1,1);  and of course, you can display your image on the LEDs using the MicroBitDisplay class:      MicroBitImage image(5,5);\n    image.paste(cross);\n    uBit.display.print(image);", 
            "title": "Manipulating Images"
        }, 
        {
            "location": "/data-types/image/#comparing-and-assigning-images", 
            "text": "MicroBitImage is a  managed type , so you can pass images as parameters to functions, store then and assign them to other variables without any worry about memory leaks.\nThe type will count the number of times it is used, and will delete itself as soon as your image is not used anymore.  You can assign images just like any other variable. So this is perfectly permitted, and memory safe:      MicroBitImage cross( 0,255,0\\n255,255,255\\n0,255,0\\n );\n    MicroBitImage img;\n\n    img = cross;\n    uBit.display.print(img);  as is this:  void doSomething(MicroBitImage i)\n{\n    uBit.display.print(img);\n}\n\nint main()\n{\n    MicroBitImage cross( 0,255,0\\n255,255,255\\n0,255,0\\n );\n\n    doSomething(cross);\n}  You can also compare images:      MicroBitImage cross( 0,255,0\\n255,255,255\\n0,255,0\\n );\n    MicroBitImage img;\n\n    img = cross;\n\n    if (img == cross)\n        uBit.display.scroll( SAME! );\n}", 
            "title": "Comparing and Assigning Images"
        }, 
        {
            "location": "/data-types/image/#storing-images-in-flash-memory", 
            "text": "The micro:bit is a  very  constrained device in terms of Random Access Memory (RAM). Unlike modern PCs that typically have over 4 Gigabytes of RAM (around four thousand million bytes!), the micro:bit has only 16 Kilobytes (16 thousand bytes!), and if you take a look at the memory map, you will see most of this is already committed to running the Bluetooth stack. By defualt, any MicroBitImage you create will be stored in this precious RAM, so that you have the ability to change it. However, it is not uncommon to have read-only images. in this case, we can store the image in FLASH memory (the same place as your program), of which the micro:bit has 256Kilobytes.  Should you want to create an store a constant image in flash, you can do so using the following constructor. This is a little more complicated, but can save you memory. if you create an image this way, not of the functions to\nchange the content will work on that image (e.g. setPixelValue, paste, etc).   The array of bytes should always start with 0xff, 0xff - which tell the runtime that this image is stored in FLASH memory.  The next number should be the width in pixels, followed by a zero.  The next number should be the heigth in pixels, followed by a zero.  The following bytes are then individual pixel brightness values, starting at the top left, then working left to right, top to bottom until the bottom right corner is reached.       const uint8_t heart[] __attribute__ ((aligned (4))) = { 0xff, 0xff, 10, 0, 5, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0}; \n\n    MicroBitImage i((ImageData*)heart); \n    uBit.display.animate(i,5);\n}", 
            "title": "Storing Images in Flash Memory"
        }, 
        {
            "location": "/data-types/image/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/data-types/image/#leakdata", 
            "text": "", 
            "title": "leakData"
        }, 
        {
            "location": "/data-types/image/#imagedata-leakdata", 
            "text": "", 
            "title": "ImageData leakData()"
        }, 
        {
            "location": "/data-types/image/#description", 
            "text": "Get current ptr, do not decr() it, and set the current instance to empty image.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#getbitmap", 
            "text": "", 
            "title": "getBitmap"
        }, 
        {
            "location": "/data-types/image/#uint8_t-getbitmap", 
            "text": "", 
            "title": "uint8_t * getBitmap()"
        }, 
        {
            "location": "/data-types/image/#description_1", 
            "text": "Return a 2D array representing the bitmap image.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/data-types/image/#microbitimage-imagedata-ptr", 
            "text": "", 
            "title": "MicroBitImage( ImageData  * ptr)"
        }, 
        {
            "location": "/data-types/image/#description_2", 
            "text": "Constructor. Create an image from a specially prepared constant array, with no copying. Will call ptr- incr().", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters", 
            "text": "ImageData     ptr* - The literal - first two bytes should be 0xff, then width, 0, height, 0, and the bitmap. Width and height are 16 bit. The literal has to be 4-byte aligned.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#example", 
            "text": "static const uint8_t heart[] __attribute__ ((aligned (4))) = { 0xff, 0xff, 10, 0, 5, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i((ImageData*)(void*)heart);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#microbitimage_1", 
            "text": "", 
            "title": "MicroBitImage()"
        }, 
        {
            "location": "/data-types/image/#description_3", 
            "text": "Default Constructor. Creates a new reference to the empty  MicroBitImage", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#example_1", 
            "text": "MicroBitImage i(); //an empty image instance", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#microbitimage-const-microbitimage-image", 
            "text": "", 
            "title": "MicroBitImage( const  MicroBitImage  &amp; image)"
        }, 
        {
            "location": "/data-types/image/#description_4", 
            "text": "Copy Constructor. Add ourselves as a reference to an existing  MicroBitImage", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_1", 
            "text": "const  MicroBitImage     image  - The  MicroBitImage  to reference.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#example_2", 
            "text": "MicroBitImage i( 0,1,0,1,0\\n ); \n MicroBitImage i2(i); //points to i", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#microbitimage-const-char-s", 
            "text": "", 
            "title": "MicroBitImage( const char * s)"
        }, 
        {
            "location": "/data-types/image/#description_5", 
            "text": "Constructor. Create a blank bitmap representation of a given size.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_2", 
            "text": "const char    s* - A text based representation of the image given whitespace delimited numeric values.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#example_3", 
            "text": "MicroBitImage i( 0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n ); // 5x5 image", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#microbitimage-const-int16_t-x-const-int16_t-y", 
            "text": "", 
            "title": "MicroBitImage( const int16_t x,  const int16_t y)"
        }, 
        {
            "location": "/data-types/image/#description_6", 
            "text": "Constructor. Create a blank bitmap representation of a given size.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_3", 
            "text": "const int16_t   x  - the width of the image.  const int16_t   y  - the height of the image.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#microbitimage-const-int16_t-x-const-int16_t-y-const-uint8_t-bitmap", 
            "text": "", 
            "title": "MicroBitImage( const int16_t x,  const int16_t y,  const uint8_t * bitmap)"
        }, 
        {
            "location": "/data-types/image/#description_7", 
            "text": "Constructor. Create a bitmap representation of a given size, based on a given buffer.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_4", 
            "text": "const int16_t   x  - the width of the image.  const int16_t   y  - the height of the image.  const uint8_t    bitmap* - a 2D array representing the image.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#example_4", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#operator", 
            "text": "", 
            "title": "operator="
        }, 
        {
            "location": "/data-types/image/#microbitimage-operator-const-microbitimage-i", 
            "text": "", 
            "title": "MicroBitImage operator=( const  MicroBitImage  &amp; i)"
        }, 
        {
            "location": "/data-types/image/#description_8", 
            "text": "Copy assign operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_5", 
            "text": "const  MicroBitImage     i", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#example_5", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n MicroBitImage i1(); \n i1 = i; // i1 now references i", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#operator_1", 
            "text": "", 
            "title": "operator=="
        }, 
        {
            "location": "/data-types/image/#bool-operator-const-microbitimage-i", 
            "text": "", 
            "title": "bool operator==( const  MicroBitImage  &amp; i)"
        }, 
        {
            "location": "/data-types/image/#description_9", 
            "text": "Equality operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_6", 
            "text": "const  MicroBitImage     i  - The  MicroBitImage  to test ourselves against.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns", 
            "text": "true if this  MicroBitImage  is identical to the one supplied, false otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_6", 
            "text": "MicroBitDisplay display; \n MicroBitImage i(); \n MicroBitImage i1(); \n\n if(i == i1) //will be true \n display.scroll( true );", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#clear", 
            "text": "", 
            "title": "clear"
        }, 
        {
            "location": "/data-types/image/#void-clear", 
            "text": "", 
            "title": "void clear()"
        }, 
        {
            "location": "/data-types/image/#description_10", 
            "text": "Resets all pixels in this image to 0.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#example_7", 
            "text": "MicroBitImage i( 0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n ); // 5x5 image \n i.clear();", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#setpixelvalue", 
            "text": "", 
            "title": "setPixelValue"
        }, 
        {
            "location": "/data-types/image/#int-setpixelvalue-int16_t-x-int16_t-y-uint8_t-value", 
            "text": "", 
            "title": "int setPixelValue( int16_t x,  int16_t y,  uint8_t value)"
        }, 
        {
            "location": "/data-types/image/#description_11", 
            "text": "Sets the pixel at the given co-ordinates to a given value.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_7", 
            "text": "int16_t   x  - The co-ordinate of the pixel to change.  int16_t   y  - The co-ordinate of the pixel to change.  uint8_t   value  - The new value of the pixel (the brightness level 0-255)", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_1", 
            "text": "MICROBIT_OK, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_8", 
            "text": "MicroBitImage i( 0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n ); // 5x5 image \n i.setPixelValue(0,0,255);    Note  all coordinates originate from the top left of an image.", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#getpixelvalue", 
            "text": "", 
            "title": "getPixelValue"
        }, 
        {
            "location": "/data-types/image/#int-getpixelvalue-int16_t-x-int16_t-y", 
            "text": "", 
            "title": "int getPixelValue( int16_t x,  int16_t y)"
        }, 
        {
            "location": "/data-types/image/#description_12", 
            "text": "Retreives the value of a given pixel.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_8", 
            "text": "int16_t   x  - The x co-ordinate of the pixel to read. Must be within the dimensions of the image.  int16_t   y  - The y co-ordinate of the pixel to read. Must be within the dimensions of the image.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_2", 
            "text": "The value assigned to the given pixel location (the brightness level 0-255), or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_9", 
            "text": "MicroBitImage i( 0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n1,0,1,0,1\\n0,1,0,1,0\\n ); // 5x5 image \n i.getPixelValue(0,0); //should be 0;", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#printimage", 
            "text": "", 
            "title": "printImage"
        }, 
        {
            "location": "/data-types/image/#int-printimage-int16_t-x-int16_t-y-const-uint8_t-bitmap", 
            "text": "", 
            "title": "int printImage( int16_t x,  int16_t y,  const uint8_t * bitmap)"
        }, 
        {
            "location": "/data-types/image/#description_13", 
            "text": "Replaces the content of this image with that of a given 2D array representing the image.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_9", 
            "text": "int16_t   x  - the width of the image. Must be within the dimensions of the image.  int16_t   y  - the width of the image. Must be within the dimensions of the image.  const uint8_t    bitmap* - a 2D array representing the image.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_3", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_10", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(); \n i.printImage(0,0,heart);    Note  all coordinates originate from the top left of an image.", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#paste", 
            "text": "", 
            "title": "paste"
        }, 
        {
            "location": "/data-types/image/#int-paste-const-microbitimage-image", 
            "text": "", 
            "title": "int paste( const  MicroBitImage  &amp; image)"
        }, 
        {
            "location": "/data-types/image/#description_14", 
            "text": "Pastes a given bitmap at the given co-ordinates.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_10", 
            "text": "const  MicroBitImage     image  - The  MicroBitImage  to paste.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_4", 
            "text": "The number of pixels written.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_11", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#int-paste-const-microbitimage-image-int16_t-x", 
            "text": "", 
            "title": "int paste( const  MicroBitImage  &amp; image,  int16_t x)"
        }, 
        {
            "location": "/data-types/image/#description_15", 
            "text": "Pastes a given bitmap at the given co-ordinates.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_11", 
            "text": "const  MicroBitImage     image  - The  MicroBitImage  to paste.  int16_t   x  - The leftmost X co-ordinate in this image where the given image should be pasted. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_5", 
            "text": "The number of pixels written.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_12", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#int-paste-const-microbitimage-image-int16_t-x-int16_t-y", 
            "text": "", 
            "title": "int paste( const  MicroBitImage  &amp; image,  int16_t x,  int16_t y)"
        }, 
        {
            "location": "/data-types/image/#description_16", 
            "text": "Pastes a given bitmap at the given co-ordinates.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_12", 
            "text": "const  MicroBitImage     image  - The  MicroBitImage  to paste.  int16_t   x  - The leftmost X co-ordinate in this image where the given image should be pasted. Defaults to 0.  int16_t   y  - The uppermost Y co-ordinate in this image where the given image should be pasted. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_6", 
            "text": "The number of pixels written.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_13", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#int-paste-const-microbitimage-image-int16_t-x-int16_t-y-uint8_t-alpha", 
            "text": "", 
            "title": "int paste( const  MicroBitImage  &amp; image,  int16_t x,  int16_t y,  uint8_t alpha)"
        }, 
        {
            "location": "/data-types/image/#description_17", 
            "text": "Pastes a given bitmap at the given co-ordinates.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_13", 
            "text": "const  MicroBitImage     image  - The  MicroBitImage  to paste.  int16_t   x  - The leftmost X co-ordinate in this image where the given image should be pasted. Defaults to 0.  int16_t   y  - The uppermost Y co-ordinate in this image where the given image should be pasted. Defaults to 0.  uint8_t   alpha  - set to 1 if transparency clear pixels in given image should be treated as transparent. Set to 0 otherwise. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_7", 
            "text": "The number of pixels written.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_14", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.paste(i, -5, 0); // a small heart", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#print", 
            "text": "", 
            "title": "print"
        }, 
        {
            "location": "/data-types/image/#int-print-char-c", 
            "text": "", 
            "title": "int print( char c)"
        }, 
        {
            "location": "/data-types/image/#description_18", 
            "text": "Prints a character to the display at the given location", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_14", 
            "text": "char   c  - The character to display.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_8", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_15", 
            "text": "MicroBitImage i(5,5); \n i.print('a');", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#int-print-char-c-int16_t-x", 
            "text": "", 
            "title": "int print( char c,  int16_t x)"
        }, 
        {
            "location": "/data-types/image/#description_19", 
            "text": "Prints a character to the display at the given location", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_15", 
            "text": "char   c  - The character to display.  int16_t   x  - The x co-ordinate of on the image to place the top left of the character. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_9", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_16", 
            "text": "MicroBitImage i(5,5); \n i.print('a');", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#int-print-char-c-int16_t-x-int16_t-y", 
            "text": "", 
            "title": "int print( char c,  int16_t x,  int16_t y)"
        }, 
        {
            "location": "/data-types/image/#description_20", 
            "text": "Prints a character to the display at the given location", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_16", 
            "text": "char   c  - The character to display.  int16_t   x  - The x co-ordinate of on the image to place the top left of the character. Defaults to 0.  int16_t   y  - The y co-ordinate of on the image to place the top left of the character. Defaults to 0.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_10", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_17", 
            "text": "MicroBitImage i(5,5); \n i.print('a');", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#shiftleft", 
            "text": "", 
            "title": "shiftLeft"
        }, 
        {
            "location": "/data-types/image/#int-shiftleft-int16_t-n", 
            "text": "", 
            "title": "int shiftLeft( int16_t n)"
        }, 
        {
            "location": "/data-types/image/#description_21", 
            "text": "Shifts the pixels in this Image a given number of pixels to the left.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_17", 
            "text": "int16_t   n  - The number of pixels to shift.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_11", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_18", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.shiftLeft(5); // a small heart", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#shiftright", 
            "text": "", 
            "title": "shiftRight"
        }, 
        {
            "location": "/data-types/image/#int-shiftright-int16_t-n", 
            "text": "", 
            "title": "int shiftRight( int16_t n)"
        }, 
        {
            "location": "/data-types/image/#description_22", 
            "text": "Shifts the pixels in this Image a given number of pixels to the right.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_18", 
            "text": "int16_t   n  - The number of pixels to shift.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_12", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_19", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); // a big heart \n i.shiftLeft(5); // a small heart \n i.shiftRight(5); // a big heart", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#shiftup", 
            "text": "", 
            "title": "shiftUp"
        }, 
        {
            "location": "/data-types/image/#int-shiftup-int16_t-n", 
            "text": "", 
            "title": "int shiftUp( int16_t n)"
        }, 
        {
            "location": "/data-types/image/#description_23", 
            "text": "Shifts the pixels in this Image a given number of pixels to upward.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_19", 
            "text": "int16_t   n  - The number of pixels to shift.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_13", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_20", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftUp(1);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#shiftdown", 
            "text": "", 
            "title": "shiftDown"
        }, 
        {
            "location": "/data-types/image/#int-shiftdown-int16_t-n", 
            "text": "", 
            "title": "int shiftDown( int16_t n)"
        }, 
        {
            "location": "/data-types/image/#description_24", 
            "text": "Shifts the pixels in this Image a given number of pixels to downward.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_20", 
            "text": "int16_t   n  - The number of pixels to shift.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#returns_14", 
            "text": "MICROBIT_OK on success, or MICROBIT_INVALID_PARAMETER.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_21", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.shiftDown(1);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#getwidth", 
            "text": "", 
            "title": "getWidth"
        }, 
        {
            "location": "/data-types/image/#int-getwidth", 
            "text": "", 
            "title": "int getWidth()"
        }, 
        {
            "location": "/data-types/image/#description_25", 
            "text": "Gets the width of this image.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#returns_15", 
            "text": "The width of this image.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_22", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getWidth(); // equals 10...", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#getheight", 
            "text": "", 
            "title": "getHeight"
        }, 
        {
            "location": "/data-types/image/#int-getheight", 
            "text": "", 
            "title": "int getHeight()"
        }, 
        {
            "location": "/data-types/image/#description_26", 
            "text": "Gets the height of this image.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#returns_16", 
            "text": "The height of this image.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_23", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getHeight(); // equals 5...", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#getsize", 
            "text": "", 
            "title": "getSize"
        }, 
        {
            "location": "/data-types/image/#int-getsize", 
            "text": "", 
            "title": "int getSize()"
        }, 
        {
            "location": "/data-types/image/#description_27", 
            "text": "Gets number of bytes in the bitmap, ie., width * height.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#returns_17", 
            "text": "The size of the bitmap.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/image/#example_24", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.getSize(); // equals 50...", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#tostring", 
            "text": "", 
            "title": "toString"
        }, 
        {
            "location": "/data-types/image/#managedstring-tostring", 
            "text": "", 
            "title": "ManagedString toString()"
        }, 
        {
            "location": "/data-types/image/#description_28", 
            "text": "Converts the bitmap to a csv  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#example_25", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n uBit.serial.printString(i.toString()); //  0,1,0,1,0,0,0,0,0,0\\n...", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#crop", 
            "text": "", 
            "title": "crop"
        }, 
        {
            "location": "/data-types/image/#microbitimage-crop-int-startx-int-starty-int-finx-int-finy", 
            "text": "", 
            "title": "MicroBitImage crop( int startx,  int starty,  int finx,  int finy)"
        }, 
        {
            "location": "/data-types/image/#description_29", 
            "text": "Crops the image to the given dimensions.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#parameters_21", 
            "text": "int   startx  - the location to start the crop in the x-axis  int   starty  - the location to start the crop in the y-axis  int   finx  int   finy", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/image/#example_26", 
            "text": "const uint8_t heart[] = { 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, }; // a cute heart \n MicroBitImage i(10,5,heart); \n i.crop(0,0,2,2).toString() //  0,1\\n1,1\\n", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/image/#isreadonly", 
            "text": "", 
            "title": "isReadOnly"
        }, 
        {
            "location": "/data-types/image/#bool-isreadonly", 
            "text": "", 
            "title": "bool isReadOnly()"
        }, 
        {
            "location": "/data-types/image/#description_30", 
            "text": "Check if image is read-only (i.e., residing in flash).", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#clone", 
            "text": "", 
            "title": "clone"
        }, 
        {
            "location": "/data-types/image/#microbitimage-clone", 
            "text": "", 
            "title": "MicroBitImage clone()"
        }, 
        {
            "location": "/data-types/image/#description_31", 
            "text": "Create a copy of the image bitmap. Used particularly, when  isReadOnly()", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/image/#returns_18", 
            "text": "an instance of  MicroBitImage  which can be modified independently of the current instance", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/event/", 
            "text": "MicroBitEvent\n\n\nOverview\n\n\nComputer programs execute sequentially - one line after another, following the logic of the progrmam you have written.\nSometimes though, we wnt to be able to determine \nwhen\n something has happened, and write some code to decide what should \nhappen in that case. For example, maybe you want to know when a button has been pressed, when your micro:bit has been shaken,\nor when some data has been sent to you over the micro:bit radio. For these sorts of cases, we create a \nMicroBitEvent\n.\n\n\nCreating Events\n\n\nMany componets will raise events when interesting things occur (e.g. MicroBitAccelerometer will raise events to indicate that the\nmicro:bit has be been shaken, or is in freefall. MicroBitButton will send events on a range of button up, down, click and hold events. \nProgrammers are also free to send their own events whenever they feel it would be useful. MicroBitvents are \nvery\n simple, and consist of\nonly two numbers:\n\n\n\n\nA source. A number identifying the component that created the event.\n\n\nA value. A number unqiue to the source that identifies the event.\n\n\n\n\nThe documentation for each component defines its event source, and all the events it may generate, and also gives a name to these\nevent values. For example, take a look at the \nbutton documentation\n to see that the source MICROBIT_ID_BUTTON_A has the value '1',\nand an event MICROBIT_BUTTON_EVT_CLICK with the value '3' is generted when a button is clicked.\n\n\nCreating an event is easy - just create a MicroBitEvent with the source avd value you need, and the runtime takes care of the rest:\n\n\nMicroBitEvent(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK);\n\n\n\n\nFeel free to create your own events lke this too. Just try to avoid using any source ID that is already used by the runtime! :-)\nSee the \nmessageBus\n page for a complete table of the reserved source IDs.\n\n\nDetecting Events\n\n\nThe micro:bit runtime has a component called the MicroBitMessgeBus, and its job is remember which events your program is interested in, and \nto deliver those MicroBitEvents to your program as they occur. To find out when an event happens, you need to create a function in your program,\nthen tell the message bus which event you want to attach this function to. This is known as writing an \nevent handler\n.\n\nYou do this through the MicroBitMessageBus \nlisten\n function.  \n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitEvent( \nuint16_t\n source,  \nuint16_t\n value)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nuint16_t\n \nsource\n\n\nuint16_t\n \nvalue\n - A component specific code indicating the cause of the event.\n\n\n\n\nExample\n\n\n // Create and launch an event using the default configuration \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK); \n\n // Create an event only, do not fire onto an EventModel. \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK,CREATE_AND_FIRE); \n\n\n\n\n\n\nMicroBitEvent( \nuint16_t\n source,  \nuint16_t\n value,  \nMicroBitEventLaunchMode\n mode)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nuint16_t\n \nsource\n\n\nuint16_t\n \nvalue\n - A component specific code indicating the cause of the event.\n\n\nMicroBitEventLaunchMode\n \nmode\n - Optional definition of how the event should be processed after construction (if at all): CREATE_ONLY:  MicroBitEvent  is initialised, and no further processing takes place. CREATE_AND_FIRE:  MicroBitEvent  is initialised, and its event handlers are immediately fired (not suitable for use in interrupts!).\n\n\n\n\nExample\n\n\n // Create and launch an event using the default configuration \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK); \n\n // Create an event only, do not fire onto an EventModel. \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK,CREATE_AND_FIRE); \n\n\n\n\n\n\nMicroBitEvent()\n\n\nDescription\n\n\nDefault constructor - initialises all values, and sets timestamp to the current time. \n\n\nfire\n\n\n\n\nvoid\n fire()\n\n\nDescription\n\n\nFires this  MicroBitEvent EventModel", 
            "title": "MicroBitEvent"
        }, 
        {
            "location": "/data-types/event/#microbitevent", 
            "text": "", 
            "title": "MicroBitEvent"
        }, 
        {
            "location": "/data-types/event/#overview", 
            "text": "Computer programs execute sequentially - one line after another, following the logic of the progrmam you have written.\nSometimes though, we wnt to be able to determine  when  something has happened, and write some code to decide what should \nhappen in that case. For example, maybe you want to know when a button has been pressed, when your micro:bit has been shaken,\nor when some data has been sent to you over the micro:bit radio. For these sorts of cases, we create a  MicroBitEvent .", 
            "title": "Overview"
        }, 
        {
            "location": "/data-types/event/#creating-events", 
            "text": "Many componets will raise events when interesting things occur (e.g. MicroBitAccelerometer will raise events to indicate that the\nmicro:bit has be been shaken, or is in freefall. MicroBitButton will send events on a range of button up, down, click and hold events. \nProgrammers are also free to send their own events whenever they feel it would be useful. MicroBitvents are  very  simple, and consist of\nonly two numbers:   A source. A number identifying the component that created the event.  A value. A number unqiue to the source that identifies the event.   The documentation for each component defines its event source, and all the events it may generate, and also gives a name to these\nevent values. For example, take a look at the  button documentation  to see that the source MICROBIT_ID_BUTTON_A has the value '1',\nand an event MICROBIT_BUTTON_EVT_CLICK with the value '3' is generted when a button is clicked.  Creating an event is easy - just create a MicroBitEvent with the source avd value you need, and the runtime takes care of the rest:  MicroBitEvent(MICROBIT_ID_BUTTON_A, MICROBIT_BUTTON_EVT_CLICK);  Feel free to create your own events lke this too. Just try to avoid using any source ID that is already used by the runtime! :-)\nSee the  messageBus  page for a complete table of the reserved source IDs.", 
            "title": "Creating Events"
        }, 
        {
            "location": "/data-types/event/#detecting-events", 
            "text": "The micro:bit runtime has a component called the MicroBitMessgeBus, and its job is remember which events your program is interested in, and \nto deliver those MicroBitEvents to your program as they occur. To find out when an event happens, you need to create a function in your program,\nthen tell the message bus which event you want to attach this function to. This is known as writing an  event handler . \nYou do this through the MicroBitMessageBus  listen  function.", 
            "title": "Detecting Events"
        }, 
        {
            "location": "/data-types/event/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/data-types/event/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/data-types/event/#microbitevent-uint16_t-source-uint16_t-value", 
            "text": "", 
            "title": "MicroBitEvent( uint16_t source,  uint16_t value)"
        }, 
        {
            "location": "/data-types/event/#description", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/event/#parameters", 
            "text": "uint16_t   source  uint16_t   value  - A component specific code indicating the cause of the event.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/event/#example", 
            "text": "// Create and launch an event using the default configuration \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK); \n\n // Create an event only, do not fire onto an EventModel. \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK,CREATE_AND_FIRE);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/event/#microbitevent-uint16_t-source-uint16_t-value-microbiteventlaunchmode-mode", 
            "text": "", 
            "title": "MicroBitEvent( uint16_t source,  uint16_t value,  MicroBitEventLaunchMode mode)"
        }, 
        {
            "location": "/data-types/event/#description_1", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/event/#parameters_1", 
            "text": "uint16_t   source  uint16_t   value  - A component specific code indicating the cause of the event.  MicroBitEventLaunchMode   mode  - Optional definition of how the event should be processed after construction (if at all): CREATE_ONLY:  MicroBitEvent  is initialised, and no further processing takes place. CREATE_AND_FIRE:  MicroBitEvent  is initialised, and its event handlers are immediately fired (not suitable for use in interrupts!).", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/event/#example_1", 
            "text": "// Create and launch an event using the default configuration \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK); \n\n // Create an event only, do not fire onto an EventModel. \n MicrobitEvent evt(id,MICROBIT_BUTTON_EVT_CLICK,CREATE_AND_FIRE);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/event/#microbitevent_1", 
            "text": "", 
            "title": "MicroBitEvent()"
        }, 
        {
            "location": "/data-types/event/#description_2", 
            "text": "Default constructor - initialises all values, and sets timestamp to the current time.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/event/#fire", 
            "text": "", 
            "title": "fire"
        }, 
        {
            "location": "/data-types/event/#void-fire", 
            "text": "", 
            "title": "void fire()"
        }, 
        {
            "location": "/data-types/event/#description_3", 
            "text": "Fires this  MicroBitEvent EventModel", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/", 
            "text": "ManagedString\n\n\nOverview\n\n\nManagedString represents a text string in the micro:bit runtime. A string is simply a sequency of characters such as 'joe' or 'microbit'. \nIn the C language, and the end of the string is marked by a special character (a NULL character, with the value zero). \nSimple strings are often represented as literal character arrays e.g. \n\n\n    uBit.display.scroll(\nHELLO\n);\n\n\n\n\nis actually almost exactly the same as:\n\n\n    char message[6] = {'H', 'E', 'L', 'L', 'O', 0};\n    uBit.display.scroll(message);\n\n\n\n\nAlthough fantastically simple, strings of this form are well known to lead to memory leaks and be sources of bugs in code (especially when the programmers are still learning!), so most modern\nhigh level languages such as Java, C#, Javascript and TouchDevelop do not use strings of this format. Instead, they provide code that is capable of ensuring strings remain safe. ManagedString \nprovides this equivalent functionality for the micro:bit, as a building block for these hgher level languages. However, it can also makes programming the micro:bit in C easier too!\n\n\n\n\nNote\n\n\nThis is a \nmanaged type\n. This means that it will automatically use and release memory as needed. There is no need for you to explicitly free or release memory when your done - the memory will be freed as soon as the last piece of code stops using the data.\n\n\n\n\nCreating Strings\n\n\nImages are simple to create - just create them like a variable, and provide the text or number you would like to build the string from. For example:\n\n\n    ManagedString hi(\nHELLO\n);\n    ManagedString message(\nmicro:bit\n);\n    ManagedString n(42);\n\n\n\n\nThe runtime will also create a ManagedString for you from a number or quoted literal anytime a function needs a ManagedString. For example, even though the scroll funciton in microBitDisplay expects a ManagedString,\nit is totally fine to pass a literal value in quotes or a number (or in fact, any parameter that is listed in the API secion as a legal constructor will work). For example:\n\n\n    ManagedString hi(\nHELLO\n);\n    ManagedString message(\nmicro:bit\n);\n    ManagedString n(42);\n\n    // All these calls are legal:\n    uBit.display.scroll(hi);\n    uBit.display.scroll(n);\n    uBit.display.scroll(\nTHANKS!\n);\n\n\n\n\nManipulating Strings\n\n\nManagedStrings are \nimmutable\n, meaning that once created, they cannot be changed. However, you can join them, search them, extract characters from them and create other strings! The micro:bur runtime makes use of \noperator overloading\n to keep this easy to use. In other works, we make use of the '=' '+' '\n' '\n' and '==' operators to let you easily assign and compare strings. Although this may sound complex, it is easy once you see how to do it. For example, here is how you would join together more than one string, and assign it to a new one:\n\n\n    ManagedString hi(\nHELLO\n);\n    ManagedString message(\nmicro:bit\n);\n    ManagedString space(\n \n);\n\n    ManagedString s = hi + space + message;\n\n    // This would say \nHELLO micro:bit\n on the LED display.\n    uBit.display.scroll(s);\n\n\n\n\nYou can compare strings (alphabetically) in a similar way:\n\n\n\n    ManagedString hi(\nHELLO\n);\n    ManagedString message(\nmicro:bit\n);\n\n    if (hi == message)\n        uBit.display.scroll(\nSAME\n);\n\n    if (hi \n message)\n        uBit.display.scroll(\nLESS\n);\n\n    if (hi \n message)\n        uBit.display.scroll(\nMORE\n);\n\n\n\n\n\nYou can also determine the length of a string, extract parts of strings, retrieve individual characters at a given index or convert a ManagedString to a C-style character array using the \n'length'\n, \n'substring'\n, \n'charAt'\n and \n'toCharArray'\n functions respectively. See the API docuemntation below for further details.\n\n\nAPI\n\n\nConstructor\n\n\n\n\nManagedString( \nStringData  *\n ptr)\n\n\nDescription\n\n\nConstructor. Create a managed string from a specially prepared string literal.\n\n\nParameters\n\n\n\n\nStringData  \n \nptr* - The literal - first two bytes should be 0xff, then the length in little endian, then the literal. The literal has to be 4-byte aligned.\n\n\n\n\nExample\n\n\n static const char hello[] __attribute__ ((aligned (4))) = \n\\xff\\xff\\x05\\x00\n \nHello\n; \n ManagedString s((StringData*)(void*)hello); \n\n\n\n\nleakData\n\n\n\n\nStringData\n leakData()\n\n\nDescription\n\n\nGet current ptr, do not decr() it, and set the current instance to empty string.\n\n\nConstructor\n\n\n\n\nManagedString( \nconst char *\n str)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nconst char \n \nstr* - The character array on which to base the new  ManagedString .\n\n\n\n\nExample\n\n\n ManagedString s(\nabcdefg\n); \n\n\n\n\n\n\nManagedString( \nconst int\n value)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nconst int\n \nvalue\n - The integer from which to create the  ManagedString .\n\n\n\n\nExample\n\n\n ManagedString s(20); \n\n\n\n\n\n\nManagedString( \nconst char\n value)\n\n\nDescription\n\n\nConstructor. Create a managed string from a given char.\n\n\nParameters\n\n\n\n\nconst char\n \nvalue\n - The character from which to create the  ManagedString .\n\n\n\n\nExample\n\n\n ManagedString s('a'); \n\n\n\n\n\n\nManagedString( \nPacketBuffer\n buffer)\n\n\nDescription\n\n\nConstructor. Create a  ManagedString PacketBuffer PacketBuffer ManagedString\n\n\nParameters\n\n\n\n\nPacketBuffer\n \nbuffer\n - The PacktBuffer from which to create the  ManagedString .\n\n\n\n\nExample\n\n\n ManagedString s = radio.datagram.recv(); \n\n\n\n\n\n\nManagedString( \nconst char *\n str,  \nconst int16_t\n length)\n\n\nDescription\n\n\nConstructor. Create a  ManagedString\n\n\nParameters\n\n\n\n\nconst char \n \nstr* - The character array on which to base the new  ManagedString .\n\n\nconst int16_t\n \nlength\n - The length of the character array\n\n\n\n\nExample\n\n\n ManagedString s(\nabcdefg\n,7); \n\n\n\n\n\n\nManagedString( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nCopy constructor. Makes a new  ManagedString\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to copy.\n\n\n\n\nExample\n\n\n ManagedString s(\nabcdefg\n); \n ManagedString p(s); \n\n\n\n\n\n\nManagedString()\n\n\nDescription\n\n\nDefault constructor.\n\n\nExample\n\n\n ManagedString s(); \n\n\n\n\noperator=\n\n\n\n\nManagedString\n operator=( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nCopy assign operation.\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to copy.\n\n\n\n\nExample\n\n\n ManagedString s(\nabcd\n); \n ManagedString p(\nefgh\n); \n p = s // p now points to s, s' ref is incremented \n\n\n\n\noperator==\n\n\n\n\nbool\n operator==( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nEquality operation.\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to test ourselves against.\n\n\n\n\nReturns\n\n\ntrue if this  ManagedString  is identical to the one supplied, false otherwise.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\nabcd\n); \n ManagedString p(\nefgh\n); \n\n if(p == s) \n display.scroll(\nWe are the same!\n); \n else \n display.scroll(\nWe are different!\n); //p is not equal to s - this will be called \n\n\n\n\noperator\n\n\n\n\nbool\n operator\n( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nInequality operation.\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to test ourselves against.\n\n\n\n\nReturns\n\n\ntrue if this  ManagedString  is alphabetically less than to the one supplied, false otherwise.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\na\n); \n ManagedString p(\nb\n); \n\n if(s \n p) \n display.scroll(\na is before b!\n); //a is before b \n else \n display.scroll(\nb is before a!\n); \n\n\n\n\noperator\n\n\n\n\nbool\n operator\n( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nInequality operation.\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to test ourselves against.\n\n\n\n\nReturns\n\n\ntrue if this  ManagedString  is alphabetically greater than to the one supplied, false otherwise.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\na\n); \n ManagedString p(\nb\n); \n\n if(p\na) \n display.scroll(\nb is after a!\n); //b is after a \n else \n display.scroll(\na is after b!\n); \n\n\n\n\nsubstring\n\n\n\n\nManagedString\n substring( \nint16_t\n start,  \nint16_t\n length)\n\n\nDescription\n\n\nExtracts a  ManagedString\n\n\nParameters\n\n\n\n\nint16_t\n \nstart\n - The index of the first character to extract, indexed from zero.\n\n\nint16_t\n \nlength\n - The number of characters to extract from the start position\n\n\n\n\nReturns\n\n\na  ManagedString  representing the requested substring.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\nabcdefg\n); \n\n display.scroll(s.substring(0,2)) // displays \nab\n \n\n\n\n\noperator+\n\n\n\n\nManagedString\n operator+( \nManagedString  \n s)\n\n\nDescription\n\n\nConcatenates this string with the one provided.\n\n\nParameters\n\n\n\n\nManagedString  \n \ns\n - The  ManagedString  to concatenate.\n\n\n\n\nReturns\n\n\na new  ManagedString  representing the joined strings.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\nabcd\n); \n ManagedString p(\nefgh\n) \n\n display.scroll(s + p) // scrolls \nabcdefgh\n \n\n\n\n\ncharAt\n\n\n\n\nchar\n charAt( \nint16_t\n index)\n\n\nDescription\n\n\nProvides a character value at a given position in the string, indexed from zero.\n\n\nParameters\n\n\n\n\nint16_t\n \nindex\n - The position of the character to return.\n\n\n\n\nReturns\n\n\nthe character at posisiton index, zero if index is invalid.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\nabcd\n); \n\n display.scroll(s.charAt(1)) // scrolls \nb\n \n\n\n\n\ntoCharArray\n\n\n\n\nconst char *\n toCharArray()\n\n\nDescription\n\n\nProvides an immutable 8 bit wide character buffer representing this string.\n\n\nReturns\n\n\na pointer to the character buffer. \n\n\nlength\n\n\n\n\nint16_t\n length()\n\n\nDescription\n\n\nDetermines the length of this  ManagedString\n\n\nReturns\n\n\nthe length of the string in characters.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\nabcd\n); \n\n display.scroll(s.length()) // scrolls \n4", 
            "title": "ManagedString"
        }, 
        {
            "location": "/data-types/string/#managedstring", 
            "text": "", 
            "title": "ManagedString"
        }, 
        {
            "location": "/data-types/string/#overview", 
            "text": "ManagedString represents a text string in the micro:bit runtime. A string is simply a sequency of characters such as 'joe' or 'microbit'. \nIn the C language, and the end of the string is marked by a special character (a NULL character, with the value zero). \nSimple strings are often represented as literal character arrays e.g.       uBit.display.scroll( HELLO );  is actually almost exactly the same as:      char message[6] = {'H', 'E', 'L', 'L', 'O', 0};\n    uBit.display.scroll(message);  Although fantastically simple, strings of this form are well known to lead to memory leaks and be sources of bugs in code (especially when the programmers are still learning!), so most modern\nhigh level languages such as Java, C#, Javascript and TouchDevelop do not use strings of this format. Instead, they provide code that is capable of ensuring strings remain safe. ManagedString \nprovides this equivalent functionality for the micro:bit, as a building block for these hgher level languages. However, it can also makes programming the micro:bit in C easier too!   Note  This is a  managed type . This means that it will automatically use and release memory as needed. There is no need for you to explicitly free or release memory when your done - the memory will be freed as soon as the last piece of code stops using the data.", 
            "title": "Overview"
        }, 
        {
            "location": "/data-types/string/#creating-strings", 
            "text": "Images are simple to create - just create them like a variable, and provide the text or number you would like to build the string from. For example:      ManagedString hi( HELLO );\n    ManagedString message( micro:bit );\n    ManagedString n(42);  The runtime will also create a ManagedString for you from a number or quoted literal anytime a function needs a ManagedString. For example, even though the scroll funciton in microBitDisplay expects a ManagedString,\nit is totally fine to pass a literal value in quotes or a number (or in fact, any parameter that is listed in the API secion as a legal constructor will work). For example:      ManagedString hi( HELLO );\n    ManagedString message( micro:bit );\n    ManagedString n(42);\n\n    // All these calls are legal:\n    uBit.display.scroll(hi);\n    uBit.display.scroll(n);\n    uBit.display.scroll( THANKS! );", 
            "title": "Creating Strings"
        }, 
        {
            "location": "/data-types/string/#manipulating-strings", 
            "text": "ManagedStrings are  immutable , meaning that once created, they cannot be changed. However, you can join them, search them, extract characters from them and create other strings! The micro:bur runtime makes use of  operator overloading  to keep this easy to use. In other works, we make use of the '=' '+' ' ' ' ' and '==' operators to let you easily assign and compare strings. Although this may sound complex, it is easy once you see how to do it. For example, here is how you would join together more than one string, and assign it to a new one:      ManagedString hi( HELLO );\n    ManagedString message( micro:bit );\n    ManagedString space(   );\n\n    ManagedString s = hi + space + message;\n\n    // This would say  HELLO micro:bit  on the LED display.\n    uBit.display.scroll(s);  You can compare strings (alphabetically) in a similar way:  \n    ManagedString hi( HELLO );\n    ManagedString message( micro:bit );\n\n    if (hi == message)\n        uBit.display.scroll( SAME );\n\n    if (hi   message)\n        uBit.display.scroll( LESS );\n\n    if (hi   message)\n        uBit.display.scroll( MORE );  You can also determine the length of a string, extract parts of strings, retrieve individual characters at a given index or convert a ManagedString to a C-style character array using the  'length' ,  'substring' ,  'charAt'  and  'toCharArray'  functions respectively. See the API docuemntation below for further details.", 
            "title": "Manipulating Strings"
        }, 
        {
            "location": "/data-types/string/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/data-types/string/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/data-types/string/#managedstring-stringdata-ptr", 
            "text": "", 
            "title": "ManagedString( StringData  * ptr)"
        }, 
        {
            "location": "/data-types/string/#description", 
            "text": "Constructor. Create a managed string from a specially prepared string literal.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters", 
            "text": "StringData     ptr* - The literal - first two bytes should be 0xff, then the length in little endian, then the literal. The literal has to be 4-byte aligned.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example", 
            "text": "static const char hello[] __attribute__ ((aligned (4))) =  \\xff\\xff\\x05\\x00   Hello ; \n ManagedString s((StringData*)(void*)hello);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#leakdata", 
            "text": "", 
            "title": "leakData"
        }, 
        {
            "location": "/data-types/string/#stringdata-leakdata", 
            "text": "", 
            "title": "StringData leakData()"
        }, 
        {
            "location": "/data-types/string/#description_1", 
            "text": "Get current ptr, do not decr() it, and set the current instance to empty string.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#constructor_1", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/data-types/string/#managedstring-const-char-str", 
            "text": "", 
            "title": "ManagedString( const char * str)"
        }, 
        {
            "location": "/data-types/string/#description_2", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_1", 
            "text": "const char    str* - The character array on which to base the new  ManagedString .", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_1", 
            "text": "ManagedString s( abcdefg );", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#managedstring-const-int-value", 
            "text": "", 
            "title": "ManagedString( const int value)"
        }, 
        {
            "location": "/data-types/string/#description_3", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_2", 
            "text": "const int   value  - The integer from which to create the  ManagedString .", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_2", 
            "text": "ManagedString s(20);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#managedstring-const-char-value", 
            "text": "", 
            "title": "ManagedString( const char value)"
        }, 
        {
            "location": "/data-types/string/#description_4", 
            "text": "Constructor. Create a managed string from a given char.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_3", 
            "text": "const char   value  - The character from which to create the  ManagedString .", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_3", 
            "text": "ManagedString s('a');", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#managedstring-packetbuffer-buffer", 
            "text": "", 
            "title": "ManagedString( PacketBuffer buffer)"
        }, 
        {
            "location": "/data-types/string/#description_5", 
            "text": "Constructor. Create a  ManagedString PacketBuffer PacketBuffer ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_4", 
            "text": "PacketBuffer   buffer  - The PacktBuffer from which to create the  ManagedString .", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_4", 
            "text": "ManagedString s = radio.datagram.recv();", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#managedstring-const-char-str-const-int16_t-length", 
            "text": "", 
            "title": "ManagedString( const char * str,  const int16_t length)"
        }, 
        {
            "location": "/data-types/string/#description_6", 
            "text": "Constructor. Create a  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_5", 
            "text": "const char    str* - The character array on which to base the new  ManagedString .  const int16_t   length  - The length of the character array", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_5", 
            "text": "ManagedString s( abcdefg ,7);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#managedstring-const-managedstring-s", 
            "text": "", 
            "title": "ManagedString( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/string/#description_7", 
            "text": "Copy constructor. Makes a new  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_6", 
            "text": "const  ManagedString     s  - The  ManagedString  to copy.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_6", 
            "text": "ManagedString s( abcdefg ); \n ManagedString p(s);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#managedstring_1", 
            "text": "", 
            "title": "ManagedString()"
        }, 
        {
            "location": "/data-types/string/#description_8", 
            "text": "Default constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#example_7", 
            "text": "ManagedString s();", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#operator", 
            "text": "", 
            "title": "operator="
        }, 
        {
            "location": "/data-types/string/#managedstring-operator-const-managedstring-s", 
            "text": "", 
            "title": "ManagedString operator=( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/string/#description_9", 
            "text": "Copy assign operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_7", 
            "text": "const  ManagedString     s  - The  ManagedString  to copy.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#example_8", 
            "text": "ManagedString s( abcd ); \n ManagedString p( efgh ); \n p = s // p now points to s, s' ref is incremented", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#operator_1", 
            "text": "", 
            "title": "operator=="
        }, 
        {
            "location": "/data-types/string/#bool-operator-const-managedstring-s", 
            "text": "", 
            "title": "bool operator==( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/string/#description_10", 
            "text": "Equality operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_8", 
            "text": "const  ManagedString     s  - The  ManagedString  to test ourselves against.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#returns", 
            "text": "true if this  ManagedString  is identical to the one supplied, false otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_9", 
            "text": "MicroBitDisplay display; \n ManagedString s( abcd ); \n ManagedString p( efgh ); \n\n if(p == s) \n display.scroll( We are the same! ); \n else \n display.scroll( We are different! ); //p is not equal to s - this will be called", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#operator_2", 
            "text": "", 
            "title": "operator&lt;"
        }, 
        {
            "location": "/data-types/string/#bool-operator-const-managedstring-s_1", 
            "text": "", 
            "title": "bool operator&lt;( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/string/#description_11", 
            "text": "Inequality operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_9", 
            "text": "const  ManagedString     s  - The  ManagedString  to test ourselves against.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#returns_1", 
            "text": "true if this  ManagedString  is alphabetically less than to the one supplied, false otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_10", 
            "text": "MicroBitDisplay display; \n ManagedString s( a ); \n ManagedString p( b ); \n\n if(s   p) \n display.scroll( a is before b! ); //a is before b \n else \n display.scroll( b is before a! );", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#operator_3", 
            "text": "", 
            "title": "operator&gt;"
        }, 
        {
            "location": "/data-types/string/#bool-operator-const-managedstring-s_2", 
            "text": "", 
            "title": "bool operator&gt;( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/string/#description_12", 
            "text": "Inequality operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_10", 
            "text": "const  ManagedString     s  - The  ManagedString  to test ourselves against.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#returns_2", 
            "text": "true if this  ManagedString  is alphabetically greater than to the one supplied, false otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_11", 
            "text": "MicroBitDisplay display; \n ManagedString s( a ); \n ManagedString p( b ); \n\n if(p a) \n display.scroll( b is after a! ); //b is after a \n else \n display.scroll( a is after b! );", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#substring", 
            "text": "", 
            "title": "substring"
        }, 
        {
            "location": "/data-types/string/#managedstring-substring-int16_t-start-int16_t-length", 
            "text": "", 
            "title": "ManagedString substring( int16_t start,  int16_t length)"
        }, 
        {
            "location": "/data-types/string/#description_13", 
            "text": "Extracts a  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_11", 
            "text": "int16_t   start  - The index of the first character to extract, indexed from zero.  int16_t   length  - The number of characters to extract from the start position", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#returns_3", 
            "text": "a  ManagedString  representing the requested substring.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_12", 
            "text": "MicroBitDisplay display; \n ManagedString s( abcdefg ); \n\n display.scroll(s.substring(0,2)) // displays  ab", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#operator_4", 
            "text": "", 
            "title": "operator+"
        }, 
        {
            "location": "/data-types/string/#managedstring-operator-managedstring-s", 
            "text": "", 
            "title": "ManagedString operator+( ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/string/#description_14", 
            "text": "Concatenates this string with the one provided.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_12", 
            "text": "ManagedString     s  - The  ManagedString  to concatenate.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#returns_4", 
            "text": "a new  ManagedString  representing the joined strings.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_13", 
            "text": "MicroBitDisplay display; \n ManagedString s( abcd ); \n ManagedString p( efgh ) \n\n display.scroll(s + p) // scrolls  abcdefgh", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#charat", 
            "text": "", 
            "title": "charAt"
        }, 
        {
            "location": "/data-types/string/#char-charat-int16_t-index", 
            "text": "", 
            "title": "char charAt( int16_t index)"
        }, 
        {
            "location": "/data-types/string/#description_15", 
            "text": "Provides a character value at a given position in the string, indexed from zero.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#parameters_13", 
            "text": "int16_t   index  - The position of the character to return.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/string/#returns_5", 
            "text": "the character at posisiton index, zero if index is invalid.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_14", 
            "text": "MicroBitDisplay display; \n ManagedString s( abcd ); \n\n display.scroll(s.charAt(1)) // scrolls  b", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/string/#tochararray", 
            "text": "", 
            "title": "toCharArray"
        }, 
        {
            "location": "/data-types/string/#const-char-tochararray", 
            "text": "", 
            "title": "const char * toCharArray()"
        }, 
        {
            "location": "/data-types/string/#description_16", 
            "text": "Provides an immutable 8 bit wide character buffer representing this string.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#returns_6", 
            "text": "a pointer to the character buffer.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#length", 
            "text": "", 
            "title": "length"
        }, 
        {
            "location": "/data-types/string/#int16_t-length", 
            "text": "", 
            "title": "int16_t length()"
        }, 
        {
            "location": "/data-types/string/#description_17", 
            "text": "Determines the length of this  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/string/#returns_7", 
            "text": "the length of the string in characters.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/string/#example_15", 
            "text": "MicroBitDisplay display; \n ManagedString s( abcd ); \n\n display.scroll(s.length()) // scrolls  4", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/", 
            "text": "PacketBuffer\n\n\nOverview\n\n\nThe \nMicroBitRadio\n classes provided direct micro:bit to micro:bit communication. It is often beneficial in both wired and wireless communication\nprotocols to send and receive data in a raw format, viewed as an ordered sequence of bytes. This class provies a basic set of functions for the creation, manipulation and\naccessing of a managed type for byte arrays used to hold network data packets.\n\n\n\n\nNote\n\n\nThis is a \nmanaged type\n. This means that it will automatically use and release memory as needed. There is no need for you to explicitly free or release memory when your done - the memory will be freed as soon as the last piece of code stops using the data.\n\n\n\n\nCreating PacketBuffers\n\n\nPacketBuffers are simple to create - just create them like a variable, and provide the size (in bytes) of the buffer you want to create.\n\n\n    PacketBuffer b(16);\n\n\n\n\nAlternatively, if you already have an array of bytes allocated, then you can somply refer to that using a slightly different form:\n\n\n    uint8_t data[16];\n    PacketBuffer b(data,16);\n\n\n\n\nManipulating PacketBuffers\n\n\nOnce created, the data inside PacketBuffers can be freely changed at any time. The simplest way to do this is through the array operators '[' and ']'. \nYou can read or write bytes to the buffer by simply dereferencing it with square bracket. e.g. to create, set and send a PacketBuffer on the micro:bit radio:\n\n\n    PacketBuffer b(2);\n    b[0] = 255;\n    b[1] = 10;\n\n    uBit.radio.datagram.send(b);\n\n\n\n\nPacketBuffers can also be assigned a value. For example, all these are legal:\n\n\n    PacketBuffer b;\n    b = uBit.radio.datagram.recv();\n\n\n\n\nIf you need more granualar access, the getBytes function provides direct access to the memory buffer, presented as a byte array:\n\n\n    PacketBuffer b(16);\n    uint8_t *buf = b.getBytes();\n\n    memcpy(buf, \nHI\n, 2);\n\n\n\n\nFinally, it is also possible to extract the received signal strength of a packet from a PakcetBuffer. This can provide both a rough indicaiton of the reliability of the link, and a crude but moderatley effective mechanism to estimate the distance between two micro:bts.\n\n\n    PacketBuffer b;\n    b = uBit.radio.datagram.recv();\n\n    uBit.display.scroll(b.getRSSI());\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nManagedString( \nStringData  *\n ptr)\n\n\nDescription\n\n\nConstructor. Create a managed string from a specially prepared string literal.\n\n\nParameters\n\n\n\n\nStringData  \n \nptr* - The literal - first two bytes should be 0xff, then the length in little endian, then the literal. The literal has to be 4-byte aligned.\n\n\n\n\nExample\n\n\n static const char hello[] __attribute__ ((aligned (4))) = \n\\xff\\xff\\x05\\x00\n \nHello\n; \n ManagedString s((StringData*)(void*)hello); \n\n\n\n\nleakData\n\n\n\n\nStringData\n leakData()\n\n\nDescription\n\n\nGet current ptr, do not decr() it, and set the current instance to empty string.\n\n\nConstructor\n\n\n\n\nManagedString( \nconst char *\n str)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nconst char \n \nstr* - The character array on which to base the new  ManagedString .\n\n\n\n\nExample\n\n\n ManagedString s(\nabcdefg\n); \n\n\n\n\n\n\nManagedString( \nconst int\n value)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nconst int\n \nvalue\n - The integer from which to create the  ManagedString .\n\n\n\n\nExample\n\n\n ManagedString s(20); \n\n\n\n\n\n\nManagedString( \nconst char\n value)\n\n\nDescription\n\n\nConstructor. Create a managed string from a given char.\n\n\nParameters\n\n\n\n\nconst char\n \nvalue\n - The character from which to create the  ManagedString .\n\n\n\n\nExample\n\n\n ManagedString s('a'); \n\n\n\n\n\n\nManagedString( \nPacketBuffer\n buffer)\n\n\nDescription\n\n\nConstructor. Create a  ManagedString PacketBuffer PacketBuffer ManagedString\n\n\nParameters\n\n\n\n\nPacketBuffer\n \nbuffer\n - The PacktBuffer from which to create the  ManagedString .\n\n\n\n\nExample\n\n\n ManagedString s = radio.datagram.recv(); \n\n\n\n\n\n\nManagedString( \nconst char *\n str,  \nconst int16_t\n length)\n\n\nDescription\n\n\nConstructor. Create a  ManagedString\n\n\nParameters\n\n\n\n\nconst char \n \nstr* - The character array on which to base the new  ManagedString .\n\n\nconst int16_t\n \nlength\n - The length of the character array\n\n\n\n\nExample\n\n\n ManagedString s(\nabcdefg\n,7); \n\n\n\n\n\n\nManagedString( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nCopy constructor. Makes a new  ManagedString\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to copy.\n\n\n\n\nExample\n\n\n ManagedString s(\nabcdefg\n); \n ManagedString p(s); \n\n\n\n\n\n\nManagedString()\n\n\nDescription\n\n\nDefault constructor.\n\n\nExample\n\n\n ManagedString s(); \n\n\n\n\noperator=\n\n\n\n\nManagedString\n operator=( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nCopy assign operation.\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to copy.\n\n\n\n\nExample\n\n\n ManagedString s(\nabcd\n); \n ManagedString p(\nefgh\n); \n p = s // p now points to s, s' ref is incremented \n\n\n\n\noperator==\n\n\n\n\nbool\n operator==( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nEquality operation.\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to test ourselves against.\n\n\n\n\nReturns\n\n\ntrue if this  ManagedString  is identical to the one supplied, false otherwise.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\nabcd\n); \n ManagedString p(\nefgh\n); \n\n if(p == s) \n display.scroll(\nWe are the same!\n); \n else \n display.scroll(\nWe are different!\n); //p is not equal to s - this will be called \n\n\n\n\noperator\n\n\n\n\nbool\n operator\n( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nInequality operation.\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to test ourselves against.\n\n\n\n\nReturns\n\n\ntrue if this  ManagedString  is alphabetically less than to the one supplied, false otherwise.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\na\n); \n ManagedString p(\nb\n); \n\n if(s \n p) \n display.scroll(\na is before b!\n); //a is before b \n else \n display.scroll(\nb is before a!\n); \n\n\n\n\noperator\n\n\n\n\nbool\n operator\n( \nconst  ManagedString  \n s)\n\n\nDescription\n\n\nInequality operation.\n\n\nParameters\n\n\n\n\nconst  ManagedString  \n \ns\n - The  ManagedString  to test ourselves against.\n\n\n\n\nReturns\n\n\ntrue if this  ManagedString  is alphabetically greater than to the one supplied, false otherwise.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\na\n); \n ManagedString p(\nb\n); \n\n if(p\na) \n display.scroll(\nb is after a!\n); //b is after a \n else \n display.scroll(\na is after b!\n); \n\n\n\n\nsubstring\n\n\n\n\nManagedString\n substring( \nint16_t\n start,  \nint16_t\n length)\n\n\nDescription\n\n\nExtracts a  ManagedString\n\n\nParameters\n\n\n\n\nint16_t\n \nstart\n - The index of the first character to extract, indexed from zero.\n\n\nint16_t\n \nlength\n - The number of characters to extract from the start position\n\n\n\n\nReturns\n\n\na  ManagedString  representing the requested substring.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\nabcdefg\n); \n\n display.scroll(s.substring(0,2)) // displays \nab\n \n\n\n\n\noperator+\n\n\n\n\nManagedString\n operator+( \nManagedString  \n s)\n\n\nDescription\n\n\nConcatenates this string with the one provided.\n\n\nParameters\n\n\n\n\nManagedString  \n \ns\n - The  ManagedString  to concatenate.\n\n\n\n\nReturns\n\n\na new  ManagedString  representing the joined strings.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\nabcd\n); \n ManagedString p(\nefgh\n) \n\n display.scroll(s + p) // scrolls \nabcdefgh\n \n\n\n\n\ncharAt\n\n\n\n\nchar\n charAt( \nint16_t\n index)\n\n\nDescription\n\n\nProvides a character value at a given position in the string, indexed from zero.\n\n\nParameters\n\n\n\n\nint16_t\n \nindex\n - The position of the character to return.\n\n\n\n\nReturns\n\n\nthe character at posisiton index, zero if index is invalid.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\nabcd\n); \n\n display.scroll(s.charAt(1)) // scrolls \nb\n \n\n\n\n\ntoCharArray\n\n\n\n\nconst char *\n toCharArray()\n\n\nDescription\n\n\nProvides an immutable 8 bit wide character buffer representing this string.\n\n\nReturns\n\n\na pointer to the character buffer. \n\n\nlength\n\n\n\n\nint16_t\n length()\n\n\nDescription\n\n\nDetermines the length of this  ManagedString\n\n\nReturns\n\n\nthe length of the string in characters.\n\n\nExample\n\n\n MicroBitDisplay display; \n ManagedString s(\nabcd\n); \n\n display.scroll(s.length()) // scrolls \n4", 
            "title": "PacketBuffer"
        }, 
        {
            "location": "/data-types/packetbuffer/#packetbuffer", 
            "text": "", 
            "title": "PacketBuffer"
        }, 
        {
            "location": "/data-types/packetbuffer/#overview", 
            "text": "The  MicroBitRadio  classes provided direct micro:bit to micro:bit communication. It is often beneficial in both wired and wireless communication\nprotocols to send and receive data in a raw format, viewed as an ordered sequence of bytes. This class provies a basic set of functions for the creation, manipulation and\naccessing of a managed type for byte arrays used to hold network data packets.   Note  This is a  managed type . This means that it will automatically use and release memory as needed. There is no need for you to explicitly free or release memory when your done - the memory will be freed as soon as the last piece of code stops using the data.", 
            "title": "Overview"
        }, 
        {
            "location": "/data-types/packetbuffer/#creating-packetbuffers", 
            "text": "PacketBuffers are simple to create - just create them like a variable, and provide the size (in bytes) of the buffer you want to create.      PacketBuffer b(16);  Alternatively, if you already have an array of bytes allocated, then you can somply refer to that using a slightly different form:      uint8_t data[16];\n    PacketBuffer b(data,16);", 
            "title": "Creating PacketBuffers"
        }, 
        {
            "location": "/data-types/packetbuffer/#manipulating-packetbuffers", 
            "text": "Once created, the data inside PacketBuffers can be freely changed at any time. The simplest way to do this is through the array operators '[' and ']'. \nYou can read or write bytes to the buffer by simply dereferencing it with square bracket. e.g. to create, set and send a PacketBuffer on the micro:bit radio:      PacketBuffer b(2);\n    b[0] = 255;\n    b[1] = 10;\n\n    uBit.radio.datagram.send(b);  PacketBuffers can also be assigned a value. For example, all these are legal:      PacketBuffer b;\n    b = uBit.radio.datagram.recv();  If you need more granualar access, the getBytes function provides direct access to the memory buffer, presented as a byte array:      PacketBuffer b(16);\n    uint8_t *buf = b.getBytes();\n\n    memcpy(buf,  HI , 2);  Finally, it is also possible to extract the received signal strength of a packet from a PakcetBuffer. This can provide both a rough indicaiton of the reliability of the link, and a crude but moderatley effective mechanism to estimate the distance between two micro:bts.      PacketBuffer b;\n    b = uBit.radio.datagram.recv();\n\n    uBit.display.scroll(b.getRSSI());", 
            "title": "Manipulating PacketBuffers"
        }, 
        {
            "location": "/data-types/packetbuffer/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/data-types/packetbuffer/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/data-types/packetbuffer/#managedstring-stringdata-ptr", 
            "text": "", 
            "title": "ManagedString( StringData  * ptr)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description", 
            "text": "Constructor. Create a managed string from a specially prepared string literal.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters", 
            "text": "StringData     ptr* - The literal - first two bytes should be 0xff, then the length in little endian, then the literal. The literal has to be 4-byte aligned.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#example", 
            "text": "static const char hello[] __attribute__ ((aligned (4))) =  \\xff\\xff\\x05\\x00   Hello ; \n ManagedString s((StringData*)(void*)hello);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#leakdata", 
            "text": "", 
            "title": "leakData"
        }, 
        {
            "location": "/data-types/packetbuffer/#stringdata-leakdata", 
            "text": "", 
            "title": "StringData leakData()"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_1", 
            "text": "Get current ptr, do not decr() it, and set the current instance to empty string.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#constructor_1", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/data-types/packetbuffer/#managedstring-const-char-str", 
            "text": "", 
            "title": "ManagedString( const char * str)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_2", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_1", 
            "text": "const char    str* - The character array on which to base the new  ManagedString .", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_1", 
            "text": "ManagedString s( abcdefg );", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#managedstring-const-int-value", 
            "text": "", 
            "title": "ManagedString( const int value)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_3", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_2", 
            "text": "const int   value  - The integer from which to create the  ManagedString .", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_2", 
            "text": "ManagedString s(20);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#managedstring-const-char-value", 
            "text": "", 
            "title": "ManagedString( const char value)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_4", 
            "text": "Constructor. Create a managed string from a given char.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_3", 
            "text": "const char   value  - The character from which to create the  ManagedString .", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_3", 
            "text": "ManagedString s('a');", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#managedstring-packetbuffer-buffer", 
            "text": "", 
            "title": "ManagedString( PacketBuffer buffer)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_5", 
            "text": "Constructor. Create a  ManagedString PacketBuffer PacketBuffer ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_4", 
            "text": "PacketBuffer   buffer  - The PacktBuffer from which to create the  ManagedString .", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_4", 
            "text": "ManagedString s = radio.datagram.recv();", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#managedstring-const-char-str-const-int16_t-length", 
            "text": "", 
            "title": "ManagedString( const char * str,  const int16_t length)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_6", 
            "text": "Constructor. Create a  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_5", 
            "text": "const char    str* - The character array on which to base the new  ManagedString .  const int16_t   length  - The length of the character array", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_5", 
            "text": "ManagedString s( abcdefg ,7);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#managedstring-const-managedstring-s", 
            "text": "", 
            "title": "ManagedString( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_7", 
            "text": "Copy constructor. Makes a new  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_6", 
            "text": "const  ManagedString     s  - The  ManagedString  to copy.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_6", 
            "text": "ManagedString s( abcdefg ); \n ManagedString p(s);", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#managedstring", 
            "text": "", 
            "title": "ManagedString()"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_8", 
            "text": "Default constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_7", 
            "text": "ManagedString s();", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#operator", 
            "text": "", 
            "title": "operator="
        }, 
        {
            "location": "/data-types/packetbuffer/#managedstring-operator-const-managedstring-s", 
            "text": "", 
            "title": "ManagedString operator=( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_9", 
            "text": "Copy assign operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_7", 
            "text": "const  ManagedString     s  - The  ManagedString  to copy.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_8", 
            "text": "ManagedString s( abcd ); \n ManagedString p( efgh ); \n p = s // p now points to s, s' ref is incremented", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#operator_1", 
            "text": "", 
            "title": "operator=="
        }, 
        {
            "location": "/data-types/packetbuffer/#bool-operator-const-managedstring-s", 
            "text": "", 
            "title": "bool operator==( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_10", 
            "text": "Equality operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_8", 
            "text": "const  ManagedString     s  - The  ManagedString  to test ourselves against.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#returns", 
            "text": "true if this  ManagedString  is identical to the one supplied, false otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_9", 
            "text": "MicroBitDisplay display; \n ManagedString s( abcd ); \n ManagedString p( efgh ); \n\n if(p == s) \n display.scroll( We are the same! ); \n else \n display.scroll( We are different! ); //p is not equal to s - this will be called", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#operator_2", 
            "text": "", 
            "title": "operator&lt;"
        }, 
        {
            "location": "/data-types/packetbuffer/#bool-operator-const-managedstring-s_1", 
            "text": "", 
            "title": "bool operator&lt;( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_11", 
            "text": "Inequality operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_9", 
            "text": "const  ManagedString     s  - The  ManagedString  to test ourselves against.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#returns_1", 
            "text": "true if this  ManagedString  is alphabetically less than to the one supplied, false otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_10", 
            "text": "MicroBitDisplay display; \n ManagedString s( a ); \n ManagedString p( b ); \n\n if(s   p) \n display.scroll( a is before b! ); //a is before b \n else \n display.scroll( b is before a! );", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#operator_3", 
            "text": "", 
            "title": "operator&gt;"
        }, 
        {
            "location": "/data-types/packetbuffer/#bool-operator-const-managedstring-s_2", 
            "text": "", 
            "title": "bool operator&gt;( const  ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_12", 
            "text": "Inequality operation.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_10", 
            "text": "const  ManagedString     s  - The  ManagedString  to test ourselves against.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#returns_2", 
            "text": "true if this  ManagedString  is alphabetically greater than to the one supplied, false otherwise.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_11", 
            "text": "MicroBitDisplay display; \n ManagedString s( a ); \n ManagedString p( b ); \n\n if(p a) \n display.scroll( b is after a! ); //b is after a \n else \n display.scroll( a is after b! );", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#substring", 
            "text": "", 
            "title": "substring"
        }, 
        {
            "location": "/data-types/packetbuffer/#managedstring-substring-int16_t-start-int16_t-length", 
            "text": "", 
            "title": "ManagedString substring( int16_t start,  int16_t length)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_13", 
            "text": "Extracts a  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_11", 
            "text": "int16_t   start  - The index of the first character to extract, indexed from zero.  int16_t   length  - The number of characters to extract from the start position", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#returns_3", 
            "text": "a  ManagedString  representing the requested substring.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_12", 
            "text": "MicroBitDisplay display; \n ManagedString s( abcdefg ); \n\n display.scroll(s.substring(0,2)) // displays  ab", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#operator_4", 
            "text": "", 
            "title": "operator+"
        }, 
        {
            "location": "/data-types/packetbuffer/#managedstring-operator-managedstring-s", 
            "text": "", 
            "title": "ManagedString operator+( ManagedString  &amp; s)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_14", 
            "text": "Concatenates this string with the one provided.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_12", 
            "text": "ManagedString     s  - The  ManagedString  to concatenate.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#returns_4", 
            "text": "a new  ManagedString  representing the joined strings.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_13", 
            "text": "MicroBitDisplay display; \n ManagedString s( abcd ); \n ManagedString p( efgh ) \n\n display.scroll(s + p) // scrolls  abcdefgh", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#charat", 
            "text": "", 
            "title": "charAt"
        }, 
        {
            "location": "/data-types/packetbuffer/#char-charat-int16_t-index", 
            "text": "", 
            "title": "char charAt( int16_t index)"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_15", 
            "text": "Provides a character value at a given position in the string, indexed from zero.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#parameters_13", 
            "text": "int16_t   index  - The position of the character to return.", 
            "title": "Parameters"
        }, 
        {
            "location": "/data-types/packetbuffer/#returns_5", 
            "text": "the character at posisiton index, zero if index is invalid.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_14", 
            "text": "MicroBitDisplay display; \n ManagedString s( abcd ); \n\n display.scroll(s.charAt(1)) // scrolls  b", 
            "title": "Example"
        }, 
        {
            "location": "/data-types/packetbuffer/#tochararray", 
            "text": "", 
            "title": "toCharArray"
        }, 
        {
            "location": "/data-types/packetbuffer/#const-char-tochararray", 
            "text": "", 
            "title": "const char * toCharArray()"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_16", 
            "text": "Provides an immutable 8 bit wide character buffer representing this string.", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#returns_6", 
            "text": "a pointer to the character buffer.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/packetbuffer/#length", 
            "text": "", 
            "title": "length"
        }, 
        {
            "location": "/data-types/packetbuffer/#int16_t-length", 
            "text": "", 
            "title": "int16_t length()"
        }, 
        {
            "location": "/data-types/packetbuffer/#description_17", 
            "text": "Determines the length of this  ManagedString", 
            "title": "Description"
        }, 
        {
            "location": "/data-types/packetbuffer/#returns_7", 
            "text": "the length of the string in characters.", 
            "title": "Returns"
        }, 
        {
            "location": "/data-types/packetbuffer/#example_15", 
            "text": "MicroBitDisplay display; \n ManagedString s( abcd ); \n\n display.scroll(s.length()) // scrolls  4", 
            "title": "Example"
        }, 
        {
            "location": "/ble/profile/", 
            "text": "BBC micro:bit Bluetooth Profile\n\n\nIntroduction\n\n\nThe BBC micro:bit will ship with a default Bluetooth Low Energy Profile flashed to it. This profile, in the terminology in use by the BBC is to be used with the \"tethered device\".\n\n\nThe profile consists of various \"services\" and \"characteristics\" designed to give easy access to the micro:bit's hardware so that initial exploration of the device's capabilities may take place using a corresponding, standard smart phone application.\n\n\nGiven the nature of micro:bit and the tools which will be available to developers, it will be possible for the profile to be partly or completely changed and replaced with a profile of the developer's own design. The latter case is out of scope for this document which focuses on the standard, default profilefor the tethered device scenario only.\n\n\nProfile Design\n\n\nThe profile was designed using Bluetooth Developer Studio and is presented in the form of two associated PDF documents depicting the profile at different levels of detail, which should be consulted alongside this supplement.\n\n\nStatus of the Design\n\n\nA version of the profile design was signed off on 28th May 2015. It was anticipated however that minor changes would be required and that these will be identified and applied iteratively during the implementation of the profile. For example data types may need optimising. Any further changes will mostly require the profile designer, Martin Woolley of the Bluetooth SIG to work with Joe Finney of Lancaster University.\n\n\nThe design should now be considered to be under change control.\n\n\nAssumptions\n\n\nThis initial profile design is based on discussions with other members of the team and various assumptions. As far as possible, assumptions have been documented here for reference purposes.\n\n\nmicro:bit Hardware Specification\n\n\nBluetooth Low Energy\n\n\nNordic Semiconductor nRF51822 with S110 soft device capable of both central and peripheral mode\n\n\nBluetooth 4.1 compliant\n\n\nSensors\n\n\nAccelerometer\n\n\nMagnetometer\n\n\nUser Interface\n\n\n2 buttons\n\n\n25 LED matrix (red)\n\n\n1 x System LED (yellow)\n\n\nI/O\n\n\n18 pins which may be used as either analogue or digital pins according to explicit configuration. The device firmware will automatically configure the input/output mode of a pin according to I/O operations addressed to it.\n\n\nPower\n\n\n1 x cell battery\n\n\nGeneral Design Assumptions\n\n\nmicro:bit will act as a GAP peripheral and advertise so that GAP central devices such as a smart phone can discover and connect to it.\n\n\nStandard Bluetooth SIG \"adopted\" services will be used where appropriate in conjunction with custom services designed specifically for micro:bit. As such the micro:bit will be shipped with a custom Bluetooth profile. At the time of writing, the Generic Access Service and Device Information Service have been identified as useful adopted services and included in the profile.\n\n\nThe micro:bit \"tethered\" profile is based around the capabilities and features of the micro:bit device itself. It is not tightly coupled to any particular application of the device such as video control or telephony. It is however able to indicate actions it wishes a connected client device to perform or signal events that have occurred and which the client is expected to act upon in some way.\n\n\nAll services are \"primary services\" and so may be discovered and enumerated by a client wishing to determine the capabilities of the device.\n\n\nEase of use has been considered to be more important than having absolute configurability of all aspects of the hardware (e.g. sensors) in the default profile.\n\n\nGATT Services\n\n\n\n\n\n\n\n\nService\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nGeneric Access Service\n\n\nAdopted\n\n\nProvides generic information about the device. Mandatory in GATT profiles.\n\n\n\n\n\n\nGeneric Attribute Service\n\n\nAdopted\n\n\nCan inform clients of changes in the attribute table such as reassigned handle values.Mandatory in GATT profiles.\n\n\n\n\n\n\nDevice Information Service\n\n\nAdopted\n\n\nProvides more comprehensive details about the device and its manufacturer\n\n\n\n\n\n\nAccelerometer Service\n\n\nCustom\n\n\nProvides access to the accelerometer sensor state and configuration of the frequency with which readings are reported.\n\n\n\n\n\n\nMagnetometer Service\n\n\nCustom\n\n\nProvides access to the magnetometer sensor state and configuration of the frequency with which readings are reported. Provides access to a \"current bearing\" value in degrees.\n\n\n\n\n\n\nTemperature Service\n\n\nCustom\n\n\nProvides access to a simplified, integer temperature measurement in celsius, derived from several sensors in the micro:bit.\n\n\n\n\n\n\nButton Service\n\n\nCustom\n\n\nAllow button state changes to be notified to the client\n\n\n\n\n\n\nLED Service\n\n\nCustom\n\n\nAllows access to both the LED \"display\" grid and the system status LED\n\n\n\n\n\n\nIO Pin Service\n\n\nCustom\n\n\nAllows access to and configuration of IO pins on the edge connector.\n\n\n\n\n\n\nEvent Service\n\n\nCustom\n\n\nAllows the micro:bit to inform the connected client of the types of event it wants to be informed about. Allows the client to inform the micro:bit of relevant events. Allows micro:bit to inform the client of events originating on the micro:bit.Event data includes both a type and a reason or origin.\n\n\n\n\n\n\n\n\nThe following sections elaborate on the description of a service and/or its characteristics where this seemed worthwhile.\n\n\nAbout the Device Information Service\n\n\nThis is an adopted service which defines 9 characteristics, all of which are optional members of of the service. For micro:bit we chose to include 5 of those characteristics only.\n\n\nSee \nhttps://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.device_information.xml\n\n\nAbout the Accelerometer Service\n\n\nCharacteristics\n\n\nAccelerometer Data\n : Contains accelerometer measurements for X, Y and Z axes as 3 unsigned 16 bit values in that order and in little endian format. Data can be read on demand or notified periodically. Values are in the range +/-1000 and in milli-newtons.\n\n\nAccelerometer Period:\n Determines the frequency with which accelerometer data is reported in milliseconds.\n\n\nAbout the Magnetometer Service\n\n\nCharacteristics\n\n\nMagnetometer Data\n : Contains magnetometer measurements for X, Y and Z axes as 3 unsigned 16 bit values in that order and in little endian format. Data can be read on demand or notified periodically.\n\n\nMagnetometer Period\n : Determines the frequency with which magnetometer data is reported in milliseconds.\n\n\nMagnetometer Bearing\n : Compass bearing in degrees from North.\n\n\nAbout the Temperature Service\n\n\nCharacteristics\n\n\nTemperature\n : Signed integer 8 bit value in celsius.\n\n\nAbout the Button Service\n\n\nThe Button Service exposes the two buttons on the micro:bit and allows their state to be read on demand by a connected client or the client to subscribe to notifications of state change. 3 button states are defined and represented by a simple numeric enumeration:  0 = not pressed, 1 = pressed, 2 = long press.\n\n\nAbout the LED Service\n\n\nThe service provides the client with direct control of each individual LED in the display grid. The client may also work at a higher level of abstraction and send strings of text to be displayed one character at a time on the LED display, with configurable scrolling transitions from one character to the next.\n\n\nA single characteristic containing a 32 bit mask (7 bits are unused) represents all 25 LEDs with a 0 bit indicating LED OFF and a 1 indicating LED ON. The characteristic may be written or read in a single GATT operation allowing efficient manipulation of all LEDs in the grid.\n\n\nOther characteristics allow a text string to be written to it by the client for display and the scrolling speed may be set.\n\n\nCharacteristics\n\n\nLED Matrix State\n : Allows the state of any|all LEDs in the 5x5 grid to be set to on or off with a single GATT operation. Consists of a 32 bit field with bits 0 - 24 representing the off (0) or on (1) state of the corresponding LED.\n\n\nLED Text\n : A UTF-8 string to be shown on the LED display.\n\n\nScrolling Speed\n : Specifies a millisecond delay to wait for in between showing each character on the display.\n\n\nAbout the IO Pin Service\n\n\nCharacteristics\n\n\nPin Data\n : Contains data relating to zero or more pins. Structured as a variable length array of up to 19 Pin Number / Value pairs. Pin Number and Value are each uint8 fields. Note however that the micro:bit has a 10 bit ADC and so values are compressed to 8 bits with a loss of resolution.\n\n\nWRITE: Clients may write values to one or more pins in a single GATT write operation. A pin to which a value is to be written must have been configured for output using the Pin IO Configuration characteristic. Any attempt to write to a pin which is configured for input will be ignored.\n\n\nNOTIFY: Notifications will deliver Pin Number / Value pairs for those pins defined as input pins by the Pin IO Configuration characteristic and whose value when read differs from the last read of the pin.\n\n\nREAD: A client reading this characteristic will receive Pin Number / Value pairs for \nall\n those pins defined as input pins by the Pin IO Configuration characteristic.\n\n\nThe associated Pin AD Configuration characteristic allows the client to indicate how each pin is to be used, as either an analogue or a digital pin.\n\n\nPin IO Configuration\n : A bit mask which allows each pin to be configured for input or output use. Bit n corresponds to pin n where 0 \n= n \n 19. A value of 0 means configured for output and 1 means configured for input.\n\n\nPin AD Configuration\n : A bit mask which allows each pin to be configured for analogue or digital use. Bit n corresponds to pin n where 0 \n= n \n 19. A value of 0 means digital and 1 means analogue.\n\n\nAbout the Event Service\n\n\nThe Event Service allows events or commands to be notified to the micro:bit by a connected client and it allows micro:bit to notify the connected client of events or commands originating from with the micro:bit. The micro:bit can inform the client of the types of event it is interested in being informed about (e.g. an incoming call) and the client can inform the micro:bit of types of event it wants to be notified about.  The term \"event\" will be used here for both event and command types of data.\n\n\nEvents may have an associated value.\n\n\nNote that specific event ID values including any special values such as those which may represent wild cards are not defined here. The micro:bit run time documentation should be consulted for this information.\n\n\nMultiple events of different types may be notified to the client or micro:bit at the same time.\n\n\nEvent data is encoded as an array of structs each encoding an event of a given type together with an associated value. Event Type and Event Value are both defined as uint16 and therefore the length of this array will always be a multiple of 4.\n\n\n\n\n\n\n\n\nstruct event {  uint16 event_type;  uint16 event_value;};\n\n\n\n\n\n\n\n\n\n\nThe Event Service has four characteristics in total:\n\n\nmicro:bit Requirements\n is a variable length list of event data structures which indicates the types of client event, potentially with a specific value which the micro:bit wishes to be informed of when they occur. The client should read this characteristic when it first connects to the micro:bit. It may also subscribe to notifications to that it can be informed if the value of this characteristic is changed by the micro:bit firmware.\n\n\nClient Requirements\n is a variable length list of event data structures which indicates the types of micro:bit event, potentially with a specific value which the client wishes to be informed of when they occur. The client should write to this characteristic when it first connects to the micro:bit.\n\n\nmicro:bit Event\n contains one or more event structures which should be notified to the client. It supports notifications and as such the client should subscribe to notifications from this characteristic.\n\n\nClient Event\n is a writable characteristic which the client may write one or more event structures to, to inform the micro:bit of events which have occurred on the client. These should be of types indicated in the micro:bit Requirements characteristic bit mask.\n\n\nAbout the DFU Control Service\n\n\nAllows clients to initiate the micro:bit pairing and over the air firmware update procedures. Firmware updates are actually handled by the Nordic Semiconductor DFU service which is not part of this profile, after the micro:bit enters an alternate bootloader.\n\n\nCharacteristics\n\n\nDFU Control\n : Writing 0x01 initiates rebooting the micro:bit into the Nordic Semiconductor bootloader if the DFU Flash Code characteristic has been written to with the correct secret key. Writing 0x02 to this charactertistic  means \"request flash code\".\n\n\nDFU Flash Code\n : Allows a client to indicate that it \"knows\" the flash code produced when pairing. Notifications are used to deliver the flash code to a client during the initial pairing process.\n\n\nOpen Issues\n\n\nIn no particular order:\n\n\n\n\n\n\nDevice will require listing on the Bluetooth SIG site. BBC are aware of the need and process.\n\n\n\n\n\n\nThe full list of event IDs needs to be defined and documented elsewhere. These are just tables of numeric identifiers with an associated meaning.\n\n\n\n\n\n\nAppendix A \u2013 Example Sequence Diagrams\n\n\n\n\nFigure 1 - Button Notifications\n\n\n\n\nFigure 2 - LED control\n\n\n\n\nFigure 3 - Accelerometer config and data notifications\n\n\nNB: Figure 3 shows accelerometer data as an example. The same pattern applies to the Magnetometer Service.\n\n\n\n\nFigure 4 - Client determining micro:bit notification requirements and then sending relevant events as they arise\n\n\n\n\nFigure 5 - micro:bit sending events / commands to the client\n\n\n\n\nFigure 6 - Client Event Requirements  and Notifications", 
            "title": "Profile"
        }, 
        {
            "location": "/ble/profile/#bbc-microbit-bluetooth-profile", 
            "text": "", 
            "title": "BBC micro:bit Bluetooth Profile"
        }, 
        {
            "location": "/ble/profile/#introduction", 
            "text": "The BBC micro:bit will ship with a default Bluetooth Low Energy Profile flashed to it. This profile, in the terminology in use by the BBC is to be used with the \"tethered device\".  The profile consists of various \"services\" and \"characteristics\" designed to give easy access to the micro:bit's hardware so that initial exploration of the device's capabilities may take place using a corresponding, standard smart phone application.  Given the nature of micro:bit and the tools which will be available to developers, it will be possible for the profile to be partly or completely changed and replaced with a profile of the developer's own design. The latter case is out of scope for this document which focuses on the standard, default profilefor the tethered device scenario only.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ble/profile/#profile-design", 
            "text": "The profile was designed using Bluetooth Developer Studio and is presented in the form of two associated PDF documents depicting the profile at different levels of detail, which should be consulted alongside this supplement.", 
            "title": "Profile Design"
        }, 
        {
            "location": "/ble/profile/#status-of-the-design", 
            "text": "A version of the profile design was signed off on 28th May 2015. It was anticipated however that minor changes would be required and that these will be identified and applied iteratively during the implementation of the profile. For example data types may need optimising. Any further changes will mostly require the profile designer, Martin Woolley of the Bluetooth SIG to work with Joe Finney of Lancaster University.  The design should now be considered to be under change control.", 
            "title": "Status of the Design"
        }, 
        {
            "location": "/ble/profile/#assumptions", 
            "text": "This initial profile design is based on discussions with other members of the team and various assumptions. As far as possible, assumptions have been documented here for reference purposes.", 
            "title": "Assumptions"
        }, 
        {
            "location": "/ble/profile/#microbit-hardware-specification", 
            "text": "Bluetooth Low Energy  Nordic Semiconductor nRF51822 with S110 soft device capable of both central and peripheral mode  Bluetooth 4.1 compliant  Sensors  Accelerometer  Magnetometer  User Interface  2 buttons  25 LED matrix (red)  1 x System LED (yellow)  I/O  18 pins which may be used as either analogue or digital pins according to explicit configuration. The device firmware will automatically configure the input/output mode of a pin according to I/O operations addressed to it.  Power  1 x cell battery", 
            "title": "micro:bit Hardware Specification"
        }, 
        {
            "location": "/ble/profile/#general-design-assumptions", 
            "text": "micro:bit will act as a GAP peripheral and advertise so that GAP central devices such as a smart phone can discover and connect to it.  Standard Bluetooth SIG \"adopted\" services will be used where appropriate in conjunction with custom services designed specifically for micro:bit. As such the micro:bit will be shipped with a custom Bluetooth profile. At the time of writing, the Generic Access Service and Device Information Service have been identified as useful adopted services and included in the profile.  The micro:bit \"tethered\" profile is based around the capabilities and features of the micro:bit device itself. It is not tightly coupled to any particular application of the device such as video control or telephony. It is however able to indicate actions it wishes a connected client device to perform or signal events that have occurred and which the client is expected to act upon in some way.  All services are \"primary services\" and so may be discovered and enumerated by a client wishing to determine the capabilities of the device.  Ease of use has been considered to be more important than having absolute configurability of all aspects of the hardware (e.g. sensors) in the default profile.", 
            "title": "General Design Assumptions"
        }, 
        {
            "location": "/ble/profile/#gatt-services", 
            "text": "Service  Type  Description      Generic Access Service  Adopted  Provides generic information about the device. Mandatory in GATT profiles.    Generic Attribute Service  Adopted  Can inform clients of changes in the attribute table such as reassigned handle values.Mandatory in GATT profiles.    Device Information Service  Adopted  Provides more comprehensive details about the device and its manufacturer    Accelerometer Service  Custom  Provides access to the accelerometer sensor state and configuration of the frequency with which readings are reported.    Magnetometer Service  Custom  Provides access to the magnetometer sensor state and configuration of the frequency with which readings are reported. Provides access to a \"current bearing\" value in degrees.    Temperature Service  Custom  Provides access to a simplified, integer temperature measurement in celsius, derived from several sensors in the micro:bit.    Button Service  Custom  Allow button state changes to be notified to the client    LED Service  Custom  Allows access to both the LED \"display\" grid and the system status LED    IO Pin Service  Custom  Allows access to and configuration of IO pins on the edge connector.    Event Service  Custom  Allows the micro:bit to inform the connected client of the types of event it wants to be informed about. Allows the client to inform the micro:bit of relevant events. Allows micro:bit to inform the client of events originating on the micro:bit.Event data includes both a type and a reason or origin.     The following sections elaborate on the description of a service and/or its characteristics where this seemed worthwhile.", 
            "title": "GATT Services"
        }, 
        {
            "location": "/ble/profile/#about-the-device-information-service", 
            "text": "This is an adopted service which defines 9 characteristics, all of which are optional members of of the service. For micro:bit we chose to include 5 of those characteristics only.  See  https://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.device_information.xml", 
            "title": "About the Device Information Service"
        }, 
        {
            "location": "/ble/profile/#about-the-accelerometer-service", 
            "text": "", 
            "title": "About the Accelerometer Service"
        }, 
        {
            "location": "/ble/profile/#characteristics", 
            "text": "Accelerometer Data  : Contains accelerometer measurements for X, Y and Z axes as 3 unsigned 16 bit values in that order and in little endian format. Data can be read on demand or notified periodically. Values are in the range +/-1000 and in milli-newtons.  Accelerometer Period:  Determines the frequency with which accelerometer data is reported in milliseconds.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/ble/profile/#about-the-magnetometer-service", 
            "text": "", 
            "title": "About the Magnetometer Service"
        }, 
        {
            "location": "/ble/profile/#characteristics_1", 
            "text": "Magnetometer Data  : Contains magnetometer measurements for X, Y and Z axes as 3 unsigned 16 bit values in that order and in little endian format. Data can be read on demand or notified periodically.  Magnetometer Period  : Determines the frequency with which magnetometer data is reported in milliseconds.  Magnetometer Bearing  : Compass bearing in degrees from North.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/ble/profile/#about-the-temperature-service", 
            "text": "", 
            "title": "About the Temperature Service"
        }, 
        {
            "location": "/ble/profile/#characteristics_2", 
            "text": "Temperature  : Signed integer 8 bit value in celsius.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/ble/profile/#about-the-button-service", 
            "text": "The Button Service exposes the two buttons on the micro:bit and allows their state to be read on demand by a connected client or the client to subscribe to notifications of state change. 3 button states are defined and represented by a simple numeric enumeration:  0 = not pressed, 1 = pressed, 2 = long press.", 
            "title": "About the Button Service"
        }, 
        {
            "location": "/ble/profile/#about-the-led-service", 
            "text": "The service provides the client with direct control of each individual LED in the display grid. The client may also work at a higher level of abstraction and send strings of text to be displayed one character at a time on the LED display, with configurable scrolling transitions from one character to the next.  A single characteristic containing a 32 bit mask (7 bits are unused) represents all 25 LEDs with a 0 bit indicating LED OFF and a 1 indicating LED ON. The characteristic may be written or read in a single GATT operation allowing efficient manipulation of all LEDs in the grid.  Other characteristics allow a text string to be written to it by the client for display and the scrolling speed may be set.", 
            "title": "About the LED Service"
        }, 
        {
            "location": "/ble/profile/#characteristics_3", 
            "text": "LED Matrix State  : Allows the state of any|all LEDs in the 5x5 grid to be set to on or off with a single GATT operation. Consists of a 32 bit field with bits 0 - 24 representing the off (0) or on (1) state of the corresponding LED.  LED Text  : A UTF-8 string to be shown on the LED display.  Scrolling Speed  : Specifies a millisecond delay to wait for in between showing each character on the display.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/ble/profile/#about-the-io-pin-service", 
            "text": "", 
            "title": "About the IO Pin Service"
        }, 
        {
            "location": "/ble/profile/#characteristics_4", 
            "text": "Pin Data  : Contains data relating to zero or more pins. Structured as a variable length array of up to 19 Pin Number / Value pairs. Pin Number and Value are each uint8 fields. Note however that the micro:bit has a 10 bit ADC and so values are compressed to 8 bits with a loss of resolution.  WRITE: Clients may write values to one or more pins in a single GATT write operation. A pin to which a value is to be written must have been configured for output using the Pin IO Configuration characteristic. Any attempt to write to a pin which is configured for input will be ignored.  NOTIFY: Notifications will deliver Pin Number / Value pairs for those pins defined as input pins by the Pin IO Configuration characteristic and whose value when read differs from the last read of the pin.  READ: A client reading this characteristic will receive Pin Number / Value pairs for  all  those pins defined as input pins by the Pin IO Configuration characteristic.  The associated Pin AD Configuration characteristic allows the client to indicate how each pin is to be used, as either an analogue or a digital pin.  Pin IO Configuration  : A bit mask which allows each pin to be configured for input or output use. Bit n corresponds to pin n where 0  = n   19. A value of 0 means configured for output and 1 means configured for input.  Pin AD Configuration  : A bit mask which allows each pin to be configured for analogue or digital use. Bit n corresponds to pin n where 0  = n   19. A value of 0 means digital and 1 means analogue.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/ble/profile/#about-the-event-service", 
            "text": "The Event Service allows events or commands to be notified to the micro:bit by a connected client and it allows micro:bit to notify the connected client of events or commands originating from with the micro:bit. The micro:bit can inform the client of the types of event it is interested in being informed about (e.g. an incoming call) and the client can inform the micro:bit of types of event it wants to be notified about.  The term \"event\" will be used here for both event and command types of data.  Events may have an associated value.  Note that specific event ID values including any special values such as those which may represent wild cards are not defined here. The micro:bit run time documentation should be consulted for this information.  Multiple events of different types may be notified to the client or micro:bit at the same time.  Event data is encoded as an array of structs each encoding an event of a given type together with an associated value. Event Type and Event Value are both defined as uint16 and therefore the length of this array will always be a multiple of 4.     struct event {  uint16 event_type;  uint16 event_value;};      The Event Service has four characteristics in total:  micro:bit Requirements  is a variable length list of event data structures which indicates the types of client event, potentially with a specific value which the micro:bit wishes to be informed of when they occur. The client should read this characteristic when it first connects to the micro:bit. It may also subscribe to notifications to that it can be informed if the value of this characteristic is changed by the micro:bit firmware.  Client Requirements  is a variable length list of event data structures which indicates the types of micro:bit event, potentially with a specific value which the client wishes to be informed of when they occur. The client should write to this characteristic when it first connects to the micro:bit.  micro:bit Event  contains one or more event structures which should be notified to the client. It supports notifications and as such the client should subscribe to notifications from this characteristic.  Client Event  is a writable characteristic which the client may write one or more event structures to, to inform the micro:bit of events which have occurred on the client. These should be of types indicated in the micro:bit Requirements characteristic bit mask.", 
            "title": "About the Event Service"
        }, 
        {
            "location": "/ble/profile/#about-the-dfu-control-service", 
            "text": "Allows clients to initiate the micro:bit pairing and over the air firmware update procedures. Firmware updates are actually handled by the Nordic Semiconductor DFU service which is not part of this profile, after the micro:bit enters an alternate bootloader.", 
            "title": "About the DFU Control Service"
        }, 
        {
            "location": "/ble/profile/#characteristics_5", 
            "text": "DFU Control  : Writing 0x01 initiates rebooting the micro:bit into the Nordic Semiconductor bootloader if the DFU Flash Code characteristic has been written to with the correct secret key. Writing 0x02 to this charactertistic  means \"request flash code\".  DFU Flash Code  : Allows a client to indicate that it \"knows\" the flash code produced when pairing. Notifications are used to deliver the flash code to a client during the initial pairing process.", 
            "title": "Characteristics"
        }, 
        {
            "location": "/ble/profile/#open-issues", 
            "text": "In no particular order:    Device will require listing on the Bluetooth SIG site. BBC are aware of the need and process.    The full list of event IDs needs to be defined and documented elsewhere. These are just tables of numeric identifiers with an associated meaning.", 
            "title": "Open Issues"
        }, 
        {
            "location": "/ble/profile/#appendix-a-example-sequence-diagrams", 
            "text": "Figure 1 - Button Notifications   Figure 2 - LED control   Figure 3 - Accelerometer config and data notifications  NB: Figure 3 shows accelerometer data as an example. The same pattern applies to the Magnetometer Service.   Figure 4 - Client determining micro:bit notification requirements and then sending relevant events as they arise   Figure 5 - micro:bit sending events / commands to the client   Figure 6 - Client Event Requirements  and Notifications", 
            "title": "Appendix A \u2013 Example Sequence Diagrams"
        }, 
        {
            "location": "/ble/accelerometer-service/", 
            "text": "Bluetooth Accelerometer Service\n\n\nIntroduction\n\n\nThis Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. It provides live accelerometer data to any attached BLE master device. You do not need to explicity address and API on the service to acheive this.\n\n\nEnabling the Service\n\n\nThis service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:\n\n\n    new MicroBitAccelerometerService(*uBit.ble, uBit.accelerometer);\n\n\n\n\n\n\nNote\n\n\nUsing BLE services is memory hungry. By default, some of the memory normally used by Nordic's BLE protocol stack (knwon as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more BLE services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your BLE applicaiton cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBLE Service Specification\n\n\nPlease see the \nmicro:bit BLE profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n\n\nCOMING SOON", 
            "title": "AccelerometerService"
        }, 
        {
            "location": "/ble/accelerometer-service/#bluetooth-accelerometer-service", 
            "text": "", 
            "title": "Bluetooth Accelerometer Service"
        }, 
        {
            "location": "/ble/accelerometer-service/#introduction", 
            "text": "This Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. It provides live accelerometer data to any attached BLE master device. You do not need to explicity address and API on the service to acheive this.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ble/accelerometer-service/#enabling-the-service", 
            "text": "This service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:      new MicroBitAccelerometerService(*uBit.ble, uBit.accelerometer);   Note  Using BLE services is memory hungry. By default, some of the memory normally used by Nordic's BLE protocol stack (knwon as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more BLE services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your BLE applicaiton cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.", 
            "title": "Enabling the Service"
        }, 
        {
            "location": "/ble/accelerometer-service/#ble-service-specification", 
            "text": "Please see the  micro:bit BLE profile specification .", 
            "title": "BLE Service Specification"
        }, 
        {
            "location": "/ble/accelerometer-service/#example-applications-for-androidiosandroid", 
            "text": "COMING SOON", 
            "title": "Example Applications for Android/IOS/Android"
        }, 
        {
            "location": "/ble/button-service/", 
            "text": "Bluetooth Button Service\n\n\nIntroduction\n\n\nThis Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. It provides live updates of the state of the physical buttons on the device to an BLE master device. You do not need to explicity address and API on the service to acheive this.\n\n\nEnabling the Service\n\n\nThis service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:\n\n\n    new MicroBitButtonService(*uBit.ble);\n\n\n\n\n\n\nNote\n\n\nUsing BLE services is memory hungry. By default, some of the memory normally used by Nordic's BLE protocol stack (knwon as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more BLE services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your BLE applicaiton cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBLE Service Specification\n\n\nPlease see the \nmicro:bit BLE profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n\n\nCOMING SOON", 
            "title": "ButtonService"
        }, 
        {
            "location": "/ble/button-service/#bluetooth-button-service", 
            "text": "", 
            "title": "Bluetooth Button Service"
        }, 
        {
            "location": "/ble/button-service/#introduction", 
            "text": "This Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. It provides live updates of the state of the physical buttons on the device to an BLE master device. You do not need to explicity address and API on the service to acheive this.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ble/button-service/#enabling-the-service", 
            "text": "This service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:      new MicroBitButtonService(*uBit.ble);   Note  Using BLE services is memory hungry. By default, some of the memory normally used by Nordic's BLE protocol stack (knwon as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more BLE services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your BLE applicaiton cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.", 
            "title": "Enabling the Service"
        }, 
        {
            "location": "/ble/button-service/#ble-service-specification", 
            "text": "Please see the  micro:bit BLE profile specification .", 
            "title": "BLE Service Specification"
        }, 
        {
            "location": "/ble/button-service/#example-applications-for-androidiosandroid", 
            "text": "COMING SOON", 
            "title": "Example Applications for Android/IOS/Android"
        }, 
        {
            "location": "/ble/dfu-service/", 
            "text": "Bluetooth Device Firmware Update Service\n\n\nIntroduction\n\n\nThis Bluetooth Low Energy (BLE) service is a standard part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. This sevrice provides a well defined mechanism through which an attached BLE master device can request the micro:bit enter the Nordic\nFirmware Over The Air (FOTA) bootloader. It provides this data to any attached BLE master device. You do not need to explicity address and API on the service to acheive this.\n\n\nEnabling the Service\n\n\nThis service is enabled by default. \n\n\nBLE Service Specification\n\n\nPlease see the \nmicro:bit BLE profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n\n\nCOMING SOON", 
            "title": "DFUService"
        }, 
        {
            "location": "/ble/dfu-service/#bluetooth-device-firmware-update-service", 
            "text": "", 
            "title": "Bluetooth Device Firmware Update Service"
        }, 
        {
            "location": "/ble/dfu-service/#introduction", 
            "text": "This Bluetooth Low Energy (BLE) service is a standard part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. This sevrice provides a well defined mechanism through which an attached BLE master device can request the micro:bit enter the Nordic\nFirmware Over The Air (FOTA) bootloader. It provides this data to any attached BLE master device. You do not need to explicity address and API on the service to acheive this.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ble/dfu-service/#enabling-the-service", 
            "text": "This service is enabled by default.", 
            "title": "Enabling the Service"
        }, 
        {
            "location": "/ble/dfu-service/#ble-service-specification", 
            "text": "Please see the  micro:bit BLE profile specification .", 
            "title": "BLE Service Specification"
        }, 
        {
            "location": "/ble/dfu-service/#example-applications-for-androidiosandroid", 
            "text": "COMING SOON", 
            "title": "Example Applications for Android/IOS/Android"
        }, 
        {
            "location": "/ble/event-service/", 
            "text": "Bluetooth Event Service\n\n\nIntroduction\n\n\nThis Bluetooth Low Energy (BLE) service is a standard part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. This sevrice extends the microBitMessageBus over BLE, so that standard MicroBitEvents raised on the device can be transmitted transparently over\nBLE and received and processed by an attached BLE device.  It provides this data to any attached BLE master device. You do not need to explicity address and API on the service to acheive this.\n\n\nEnabling the Service\n\n\nThis service is enabled by default. \n\n\nBLE Service Specification\n\n\nPlease see the \nmicro:bit BLE profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n\n\nCOMING SOON", 
            "title": "EventService"
        }, 
        {
            "location": "/ble/event-service/#bluetooth-event-service", 
            "text": "", 
            "title": "Bluetooth Event Service"
        }, 
        {
            "location": "/ble/event-service/#introduction", 
            "text": "This Bluetooth Low Energy (BLE) service is a standard part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. This sevrice extends the microBitMessageBus over BLE, so that standard MicroBitEvents raised on the device can be transmitted transparently over\nBLE and received and processed by an attached BLE device.  It provides this data to any attached BLE master device. You do not need to explicity address and API on the service to acheive this.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ble/event-service/#enabling-the-service", 
            "text": "This service is enabled by default.", 
            "title": "Enabling the Service"
        }, 
        {
            "location": "/ble/event-service/#ble-service-specification", 
            "text": "Please see the  micro:bit BLE profile specification .", 
            "title": "BLE Service Specification"
        }, 
        {
            "location": "/ble/event-service/#example-applications-for-androidiosandroid", 
            "text": "COMING SOON", 
            "title": "Example Applications for Android/IOS/Android"
        }, 
        {
            "location": "/ble/iopin-service/", 
            "text": "Bluetooth IO Pin Service\n\n\nIntroduction\n\n\nThis Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. It provides the ability to read and write digital and analog values onto any of the pins exposed on the micro:bit edge connector, including the 3 main ring ports.\nThis data can be transparently read and written from any attached BLE master device. You do not need to explicity address and API on the service to acheive this.\n\n\nEnabling the Service\n\n\nThis service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:\n\n\n    new MicroBitIOPinService(*uBit.ble, uBit.io);\n\n\n\n\n\n\nNote\n\n\nUsing BLE services is memory hungry. By default, some of the memory normally used by Nordic's BLE protocol stack (knwon as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more BLE services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your BLE applicaiton cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBLE Service Specification\n\n\nPlease see the \nmicro:bit BLE profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n\n\nCOMING SOON", 
            "title": "IOPinService"
        }, 
        {
            "location": "/ble/iopin-service/#bluetooth-io-pin-service", 
            "text": "", 
            "title": "Bluetooth IO Pin Service"
        }, 
        {
            "location": "/ble/iopin-service/#introduction", 
            "text": "This Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. It provides the ability to read and write digital and analog values onto any of the pins exposed on the micro:bit edge connector, including the 3 main ring ports.\nThis data can be transparently read and written from any attached BLE master device. You do not need to explicity address and API on the service to acheive this.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ble/iopin-service/#enabling-the-service", 
            "text": "This service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:      new MicroBitIOPinService(*uBit.ble, uBit.io);   Note  Using BLE services is memory hungry. By default, some of the memory normally used by Nordic's BLE protocol stack (knwon as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more BLE services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your BLE applicaiton cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.", 
            "title": "Enabling the Service"
        }, 
        {
            "location": "/ble/iopin-service/#ble-service-specification", 
            "text": "Please see the  micro:bit BLE profile specification .", 
            "title": "BLE Service Specification"
        }, 
        {
            "location": "/ble/iopin-service/#example-applications-for-androidiosandroid", 
            "text": "COMING SOON", 
            "title": "Example Applications for Android/IOS/Android"
        }, 
        {
            "location": "/ble/led-service/", 
            "text": "Bluetooth LED Service\n\n\nIntroduction\n\n\nThis Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. It allows any attached BLE master device to read and write the status of the LEDs on the display. This includes reading and writing \nnitmap values to the display, and activating simple animations such as scrolling text messages.\n\n\nlive accelerometer data to any attached BLE master device. You do not need to explicity address and API on the service to acheive this.\n\n\nEnabling the Service\n\n\nThis service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:\n\n\n    new MicroBitLEDService(*uBit.ble, uBit.display);\n\n\n\n\n\n\nNote\n\n\nUsing BLE services is memory hungry. By default, some of the memory normally used by Nordic's BLE protocol stack (knwon as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more BLE services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your BLE applicaiton cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBLE Service Specification\n\n\nPlease see the \nmicro:bit BLE profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n\n\nCOMING SOON", 
            "title": "LEDService"
        }, 
        {
            "location": "/ble/led-service/#bluetooth-led-service", 
            "text": "", 
            "title": "Bluetooth LED Service"
        }, 
        {
            "location": "/ble/led-service/#introduction", 
            "text": "This Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. It allows any attached BLE master device to read and write the status of the LEDs on the display. This includes reading and writing \nnitmap values to the display, and activating simple animations such as scrolling text messages.  live accelerometer data to any attached BLE master device. You do not need to explicity address and API on the service to acheive this.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ble/led-service/#enabling-the-service", 
            "text": "This service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:      new MicroBitLEDService(*uBit.ble, uBit.display);   Note  Using BLE services is memory hungry. By default, some of the memory normally used by Nordic's BLE protocol stack (knwon as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more BLE services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your BLE applicaiton cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.", 
            "title": "Enabling the Service"
        }, 
        {
            "location": "/ble/led-service/#ble-service-specification", 
            "text": "Please see the  micro:bit BLE profile specification .", 
            "title": "BLE Service Specification"
        }, 
        {
            "location": "/ble/led-service/#example-applications-for-androidiosandroid", 
            "text": "COMING SOON", 
            "title": "Example Applications for Android/IOS/Android"
        }, 
        {
            "location": "/ble/magnetometer-service/", 
            "text": "Bluetooth Magnetometer Service\n\n\nIntroduction\n\n\nThis Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. It provides live electronic compass / magnetometer data to any attached BLE master device. You do not need to explicity address and API on the service to acheive this.\n\n\nEnabling the Service\n\n\nThis service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:\n\n\n    new MicroBitMagnetometerService(*uBit.ble, uBit.compass);    \n\n\n\n\n\n\nNote\n\n\nUsing BLE services is memory hungry. By default, some of the memory normally used by Nordic's BLE protocol stack (knwon as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more BLE services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your BLE applicaiton cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBLE Service Specification\n\n\nPlease see the \nmicro:bit BLE profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n\n\nCOMING SOON", 
            "title": "MagnetometerService"
        }, 
        {
            "location": "/ble/magnetometer-service/#bluetooth-magnetometer-service", 
            "text": "", 
            "title": "Bluetooth Magnetometer Service"
        }, 
        {
            "location": "/ble/magnetometer-service/#introduction", 
            "text": "This Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. It provides live electronic compass / magnetometer data to any attached BLE master device. You do not need to explicity address and API on the service to acheive this.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ble/magnetometer-service/#enabling-the-service", 
            "text": "This service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:      new MicroBitMagnetometerService(*uBit.ble, uBit.compass);       Note  Using BLE services is memory hungry. By default, some of the memory normally used by Nordic's BLE protocol stack (knwon as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more BLE services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your BLE applicaiton cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.", 
            "title": "Enabling the Service"
        }, 
        {
            "location": "/ble/magnetometer-service/#ble-service-specification", 
            "text": "Please see the  micro:bit BLE profile specification .", 
            "title": "BLE Service Specification"
        }, 
        {
            "location": "/ble/magnetometer-service/#example-applications-for-androidiosandroid", 
            "text": "COMING SOON", 
            "title": "Example Applications for Android/IOS/Android"
        }, 
        {
            "location": "/ble/temperature-service/", 
            "text": "Bluetooth Temperature Service\n\n\nIntroduction\n\n\nThis Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. It provides live temperature data to any attached BLE master device. You do not need to explicity address and API on the service to acheive this.\nPlease note that the temperature data is inferred from the die temperature of the Nordic nrf51822 CPU. Whilst this sensor has a high precision, it is not calibrated, so will exhibit\na linear shift (although changes in temperature will be accurate). See \nMicroBitThermometer\n for informaiton on the API to allow calibration.\n\n\nEnabling the Service\n\n\nThis service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:\n\n\n    new MicroBitTemperatureService(*uBit.ble, uBit.thermometer);\n\n\n\n\n\n\nNote\n\n\nUsing BLE services is memory hungry. By default, some of the memory normally used by Nordic's BLE protocol stack (knwon as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more BLE services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your BLE applicaiton cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.\n\n\n\n\nBLE Service Specification\n\n\nPlease see the \nmicro:bit BLE profile specification\n.\n\n\nExample Applications for Android/IOS/Android\n\n\nCOMING SOON", 
            "title": "TemperatureService"
        }, 
        {
            "location": "/ble/temperature-service/#bluetooth-temperature-service", 
            "text": "", 
            "title": "Bluetooth Temperature Service"
        }, 
        {
            "location": "/ble/temperature-service/#introduction", 
            "text": "This Bluetooth Low Energy (BLE) service is an optional part of the standard bluetooth profile for the micro:bit. It is a passive service, that can operate transparently in the \nbackground as your main program is running. It provides live temperature data to any attached BLE master device. You do not need to explicity address and API on the service to acheive this.\nPlease note that the temperature data is inferred from the die temperature of the Nordic nrf51822 CPU. Whilst this sensor has a high precision, it is not calibrated, so will exhibit\na linear shift (although changes in temperature will be accurate). See  MicroBitThermometer  for informaiton on the API to allow calibration.", 
            "title": "Introduction"
        }, 
        {
            "location": "/ble/temperature-service/#enabling-the-service", 
            "text": "This service is disabled by default. To enable the service, simply create an instance of this class in your program, at any time after the uBit object has been initialised:      new MicroBitTemperatureService(*uBit.ble, uBit.thermometer);   Note  Using BLE services is memory hungry. By default, some of the memory normally used by Nordic's BLE protocol stack (knwon as a SoftDevice), is reclaimed by the micro:bit runtime as general purpose memory for your applications. if you enable more BLE services, then you may need to provide more memory back to Soft Device to ensure proper operation. If after enabling this service your BLE applicaiton cannot access the service reliably, you should consider increasing the value of MICROBIT_SD_GATT_TABLE_SIZE in your inc/MicroBitConfig.h. The more service you add, the larger this will need to be, up to the limit defined in MicroBitConfig.h.", 
            "title": "Enabling the Service"
        }, 
        {
            "location": "/ble/temperature-service/#ble-service-specification", 
            "text": "Please see the  micro:bit BLE profile specification .", 
            "title": "BLE Service Specification"
        }, 
        {
            "location": "/ble/temperature-service/#example-applications-for-androidiosandroid", 
            "text": "COMING SOON", 
            "title": "Example Applications for Android/IOS/Android"
        }, 
        {
            "location": "/extras/light-sensing/", 
            "text": "MicroBitLightSensor\n\n\nOperation\n\n\nSensing Pins\n\n\nIf the current is inverted on an LED, it becomes sensitive to light. In particular\nit is sensitive to the \nsame colour\n of light it emits.\n\n\nYou will find that the Light Sensor on the micro:bit is more reactive to red light\nthan any other colour because that is the colour of light the display emits.\n\n\nThe display is architected with 3 rows, each with 9 columns. This is illustrated\nbelow:\n\n\n\n\nWhere the format is: \nROW\n.\nCOLUMN\n\n\nOn the micro:bit we have 6 analog pins, 3 are applicable to the display and reside\non columns 1, 2 and 3.\n\n\nThis means that we have 9 pins in total that we can sense light on if we are\nfast enough to transition between emitting and sensing light.\n\n\nThe 9 sense pins are illustrated below:\n\n\n\n\n _____________________________\n| 1.1 |     | 1.2 |     | 1.3 |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n| 2.2 |     | 2.3 |     | 2.1 |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n| 3.3 |     | 3.1 |     | 3.2 |\n|_____|_____|_____|_____|_____|\n\n\n\n\n\n\nThe ADC takes around 4ms to settle and give accurate values with minimal current.\nThis places restrictions on our sensing window.\n\n\nInterleaving\n\n\nIn the current implementation, the display and the Light sensor can operate in an\ninterleaving manner. This interleaving is enabled due to a special display mode on the \ndisplay\n\nwhich is automatically activated when \nreadLightLevel\n is called by the user.\n\n\nThis special mode (\nDISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE\n), increases the rate of the \nsystemTick\n callback to 5ms, and the\n\ndisplay\n is thusly configured to drop the 4th frame for user processing,\nwhich in this case, is entirely consumed by the light sensor. This reduces the display\nrefresh rate from 55Hz to around 50Hz.\n\n\nTo signify the window for user processing, the display will fire an event:\n\n\n\n\nID\n: \nMICROBIT_ID_DISPLAY\n\n\nValue\n: \nMICROBIT_DISPLAY_EVT_LIGHT_SENSE\n\n\n\n\nThis will trigger an event handler in the \nMicroBitLightSensor\n class.\n\n\nSensing Life Cycle\n\n\nIn the previous section we discussed how the \ndisplay\n and the Light\nSensor interleave. This section will cover the actual operation of the sensor during\nthe \nMICROBIT_DISPLAY_EVT_LIGHT_SENSE\n event.\n\n\n\n\n\n\nNote\n\n\nIf you would like to manually trigger the Light Sensor, a few steps must be taken:\n\n1) Disable the display so that the column pins are under the users' control.\n\n2) Construct an instance of \nMicroBitLightSensor\n\n3) Trigger the Light Sensor by firing a \nMicroBitEvent\n with the ID \nMICROBIT_ID_DISPLAY\n and the value \nMICROBIT_DISPLAY_EVT_LIGHT_SENSE\n.\n\n\n\n\nThe Concept of Channels\n\n\nAs we previously discussed there are 9 pins we can sense light on. However, we face the problem\nof interference from the state of other Columns.\n\n\nWe found that the best combination was to treat each of the three analog enabled Columns as a channel.\nThis leads our picture to look something more like this:\n\n\n\n\n _____________________________\n|  1  |     |  2  |     |  3  |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n|  2  |     |  3  |     |  1  |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n|  3  |     |  1  |     |  2  |\n|_____|_____|_____|_____|_____|\n\n\n\n\n\n\nWhere each number represents a different column, now named a channel as it is a collection of 3 rows\n\n\nThis reduces the resolution of our light sensing capabilities as we can\nnow no longer can use 9 pins to sense light, purely due to the unfortunate fact\nthat we obtain interference from other pins that cannot be mitigated.\n\n\nHowever, we do gain an accurate picture of the overall brightness detected by the display.\n\n\nWe expose a mean representation of the light level from the 3 channels on the display.\n\n\nThe Algorithm\n\n\nUpon receiving an event:\n\n\n\n\nSet all rows to be a DigitalOut, with a value of 0.\n\n\nFor the current channel:\n\n\nSet the current channel pin HI.\n\n\nImmediately transition the current channel to be an AnalogIn\n\n\n\n\n\n\nAttach an interrupt to occur 4ms into the future. (This allows our AnalogIn instance\nto settle correctly)\n\n\n\n\nUpon interrupt:\n\n\n\n\nObtain our analog value.\n\n\nRelease the pin from GPIOTE control. (\nIf we do not do these, this column will not\nbe useable in the display driver\n)\n\n\nMove onto the next channel.\n\n\n\n\nAfter these two phases have occurred, the display will now once again be available\nfor regular usage until the next interleave is signaled by the display.\n\n\nMessage Bus ID\n\n\nMessage Bus Events\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitLightSensor( \nconst  MatrixMap  \n map)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nconst  MatrixMap  \n \nmap\n - The mapping information that relates pin inputs/outputs to physical screen coordinates. Defaults to microbitMatrixMap, defined in  MicroBitMatrixMaps.h . \n\n\n\n\nread\n\n\n\n\nint\n read()\n\n\nDescription\n\n\nThis method returns a summed average of the three sections of the display.\n\n\nReturns\n\n\nreturns a value in the range 0 - 255 where 0 is dark, and 255 is very bright \n\n\nstartSensing\n\n\n\n\nvoid\n startSensing( \nMicroBitEvent\n )\n\n\nDescription\n\n\nThe method that is invoked by sending MICROBIT_DISPLAY_EVT_LIGHT_SENSE using the id MICROBIT_ID_DISPLAY.\n\n\nParameters\n\n\n\n\nMicroBitEvent\n **\n\n\n\n\n\n\nNote\n\n\nthis can be manually driven by calling this member function, with a  MicroBitEvent  using the CREATE_ONLY option of the  MicroBitEvent  constructor.", 
            "title": "MicroBitLightSensor"
        }, 
        {
            "location": "/extras/light-sensing/#microbitlightsensor", 
            "text": "", 
            "title": "MicroBitLightSensor"
        }, 
        {
            "location": "/extras/light-sensing/#operation", 
            "text": "", 
            "title": "Operation"
        }, 
        {
            "location": "/extras/light-sensing/#sensing-pins", 
            "text": "If the current is inverted on an LED, it becomes sensitive to light. In particular\nit is sensitive to the  same colour  of light it emits.  You will find that the Light Sensor on the micro:bit is more reactive to red light\nthan any other colour because that is the colour of light the display emits.  The display is architected with 3 rows, each with 9 columns. This is illustrated\nbelow:   Where the format is:  ROW . COLUMN  On the micro:bit we have 6 analog pins, 3 are applicable to the display and reside\non columns 1, 2 and 3.  This means that we have 9 pins in total that we can sense light on if we are\nfast enough to transition between emitting and sensing light.  The 9 sense pins are illustrated below:    _____________________________\n| 1.1 |     | 1.2 |     | 1.3 |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n| 2.2 |     | 2.3 |     | 2.1 |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n| 3.3 |     | 3.1 |     | 3.2 |\n|_____|_____|_____|_____|_____|   The ADC takes around 4ms to settle and give accurate values with minimal current.\nThis places restrictions on our sensing window.", 
            "title": "Sensing Pins"
        }, 
        {
            "location": "/extras/light-sensing/#interleaving", 
            "text": "In the current implementation, the display and the Light sensor can operate in an\ninterleaving manner. This interleaving is enabled due to a special display mode on the  display \nwhich is automatically activated when  readLightLevel  is called by the user.  This special mode ( DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE ), increases the rate of the  systemTick  callback to 5ms, and the display  is thusly configured to drop the 4th frame for user processing,\nwhich in this case, is entirely consumed by the light sensor. This reduces the display\nrefresh rate from 55Hz to around 50Hz.  To signify the window for user processing, the display will fire an event:   ID :  MICROBIT_ID_DISPLAY  Value :  MICROBIT_DISPLAY_EVT_LIGHT_SENSE   This will trigger an event handler in the  MicroBitLightSensor  class.", 
            "title": "Interleaving"
        }, 
        {
            "location": "/extras/light-sensing/#sensing-life-cycle", 
            "text": "In the previous section we discussed how the  display  and the Light\nSensor interleave. This section will cover the actual operation of the sensor during\nthe  MICROBIT_DISPLAY_EVT_LIGHT_SENSE  event.    Note  If you would like to manually trigger the Light Sensor, a few steps must be taken: \n1) Disable the display so that the column pins are under the users' control. \n2) Construct an instance of  MicroBitLightSensor \n3) Trigger the Light Sensor by firing a  MicroBitEvent  with the ID  MICROBIT_ID_DISPLAY  and the value  MICROBIT_DISPLAY_EVT_LIGHT_SENSE .", 
            "title": "Sensing Life Cycle"
        }, 
        {
            "location": "/extras/light-sensing/#the-concept-of-channels", 
            "text": "As we previously discussed there are 9 pins we can sense light on. However, we face the problem\nof interference from the state of other Columns.  We found that the best combination was to treat each of the three analog enabled Columns as a channel.\nThis leads our picture to look something more like this:    _____________________________\n|  1  |     |  2  |     |  3  |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n|  2  |     |  3  |     |  1  |\n|_____|_____|_____|_____|_____|\n|     |     |     |     |     |\n|_____|_____|_____|_____|_____|\n|  3  |     |  1  |     |  2  |\n|_____|_____|_____|_____|_____|   Where each number represents a different column, now named a channel as it is a collection of 3 rows  This reduces the resolution of our light sensing capabilities as we can\nnow no longer can use 9 pins to sense light, purely due to the unfortunate fact\nthat we obtain interference from other pins that cannot be mitigated.  However, we do gain an accurate picture of the overall brightness detected by the display.  We expose a mean representation of the light level from the 3 channels on the display.", 
            "title": "The Concept of Channels"
        }, 
        {
            "location": "/extras/light-sensing/#the-algorithm", 
            "text": "Upon receiving an event:   Set all rows to be a DigitalOut, with a value of 0.  For the current channel:  Set the current channel pin HI.  Immediately transition the current channel to be an AnalogIn    Attach an interrupt to occur 4ms into the future. (This allows our AnalogIn instance\nto settle correctly)   Upon interrupt:   Obtain our analog value.  Release the pin from GPIOTE control. ( If we do not do these, this column will not\nbe useable in the display driver )  Move onto the next channel.   After these two phases have occurred, the display will now once again be available\nfor regular usage until the next interleave is signaled by the display.", 
            "title": "The Algorithm"
        }, 
        {
            "location": "/extras/light-sensing/#message-bus-id", 
            "text": "", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/extras/light-sensing/#message-bus-events", 
            "text": "", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/extras/light-sensing/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/extras/light-sensing/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/extras/light-sensing/#microbitlightsensor-const-matrixmap-map", 
            "text": "", 
            "title": "MicroBitLightSensor( const  MatrixMap  &amp; map)"
        }, 
        {
            "location": "/extras/light-sensing/#description", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/extras/light-sensing/#parameters", 
            "text": "const  MatrixMap     map  - The mapping information that relates pin inputs/outputs to physical screen coordinates. Defaults to microbitMatrixMap, defined in  MicroBitMatrixMaps.h .", 
            "title": "Parameters"
        }, 
        {
            "location": "/extras/light-sensing/#read", 
            "text": "", 
            "title": "read"
        }, 
        {
            "location": "/extras/light-sensing/#int-read", 
            "text": "", 
            "title": "int read()"
        }, 
        {
            "location": "/extras/light-sensing/#description_1", 
            "text": "This method returns a summed average of the three sections of the display.", 
            "title": "Description"
        }, 
        {
            "location": "/extras/light-sensing/#returns", 
            "text": "returns a value in the range 0 - 255 where 0 is dark, and 255 is very bright", 
            "title": "Returns"
        }, 
        {
            "location": "/extras/light-sensing/#startsensing", 
            "text": "", 
            "title": "startSensing"
        }, 
        {
            "location": "/extras/light-sensing/#void-startsensing-microbitevent", 
            "text": "", 
            "title": "void startSensing( MicroBitEvent )"
        }, 
        {
            "location": "/extras/light-sensing/#description_2", 
            "text": "The method that is invoked by sending MICROBIT_DISPLAY_EVT_LIGHT_SENSE using the id MICROBIT_ID_DISPLAY.", 
            "title": "Description"
        }, 
        {
            "location": "/extras/light-sensing/#parameters_1", 
            "text": "MicroBitEvent  **    Note  this can be manually driven by calling this member function, with a  MicroBitEvent  using the CREATE_ONLY option of the  MicroBitEvent  constructor.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/blemanager/", 
            "text": "", 
            "title": "_blemanager"
        }, 
        {
            "location": "/ubit/multibutton/", 
            "text": "uBit.buttonAB\n\n\nOverview\n\n\nA \nMicroBitMultiButton\n mirrors the state of two \nMicroBitButton\ns\nusing the message bus eventing mechanism. It provides a similar API and emits\nthe same events as as a \nMicroBitButton\n.\n\n\nMessage Bus ID\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_ID_BUTTON_AB\n\n\n26\n\n\n\n\n\n\n\n\nMessage Bus Events\n\n\n\n\n\n\n\n\nConstant\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOWN\n\n\n1\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_UP\n\n\n2\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_CLICK\n\n\n3\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_LONG_CLICK\n\n\n4\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_HOLD\n\n\n5\n\n\n\n\n\n\nMICROBIT_BUTTON_EVT_DOUBLE_CLICK\n\n\n6\n\n\n\n\n\n\n\n\nAPI\n\n\nConstructor\n\n\n\n\nMicroBitMultiButton( \nuint16_t\n button1,  \nuint16_t\n button2,  \nuint16_t\n id)\n\n\nDescription\n\n\nConstructor.\n\n\nParameters\n\n\n\n\nuint16_t\n \nbutton1\n - the unique ID of the first button to watch.\n\n\nuint16_t\n \nbutton2\n - the unique ID of the second button to watch.\n\n\nuint16_t\n \nid\n - the unique  EventModel  id of this  MicroBitMultiButton  instance.\n\n\n\n\nExample\n\n\n multiButton(MICROBIT_ID_BUTTON_A, MICROBIT_ID_BUTTON_B, MICROBIT_ID_BUTTON_AB); \n\n\n\n\nisPressed\n\n\n\n\nint\n isPressed()\n\n\nDescription\n\n\nTests if this  MicroBitMultiButton\n\n\nReturns\n\n\n1 if both physical buttons are pressed simultaneously.\n\n\nExample\n\n\n if(buttonAB.isPressed()) \n display.scroll(\nPressed!\n); \n\n\n\n\nsetEventConfiguration\n\n\n\n\nvoid\n setEventConfiguration( \nMicroBitButtonEventConfiguration\n config)\n\n\nDescription\n\n\nChanges the event configuration of this button to the given MicroBitButtonEventConfiguration. All subsequent events generated by this button will then be informed by this configuraiton.\n\n\nParameters\n\n\n\n\nMicroBitButtonEventConfiguration\n \nconfig\n - The new configuration for this button. Legal values are MICROBIT_BUTTON_ALL_EVENTS or MICROBIT_BUTTON_SIMPLE_EVENTS.\n\n\n\n\nExample\n\n\n // Configure a button to generate all possible events. \n buttonAB.setEventConfiguration(MICROBIT_BUTTON_ALL_EVENTS); \n\n // Configure a button to suppress MICROBIT_BUTTON_EVT_CLICK and MICROBIT_BUTTON_EVT_LONG_CLICK events. \n buttonAB.setEventConfiguration(MICROBIT_BUTTON_SIMPLE_EVENTS);", 
            "title": "_buttonAB"
        }, 
        {
            "location": "/ubit/multibutton/#ubitbuttonab", 
            "text": "", 
            "title": "uBit.buttonAB"
        }, 
        {
            "location": "/ubit/multibutton/#overview", 
            "text": "A  MicroBitMultiButton  mirrors the state of two  MicroBitButton s\nusing the message bus eventing mechanism. It provides a similar API and emits\nthe same events as as a  MicroBitButton .", 
            "title": "Overview"
        }, 
        {
            "location": "/ubit/multibutton/#message-bus-id", 
            "text": "Constant  Value      MICROBIT_ID_BUTTON_AB  26", 
            "title": "Message Bus ID"
        }, 
        {
            "location": "/ubit/multibutton/#message-bus-events", 
            "text": "Constant  Value      MICROBIT_BUTTON_EVT_DOWN  1    MICROBIT_BUTTON_EVT_UP  2    MICROBIT_BUTTON_EVT_CLICK  3    MICROBIT_BUTTON_EVT_LONG_CLICK  4    MICROBIT_BUTTON_EVT_HOLD  5    MICROBIT_BUTTON_EVT_DOUBLE_CLICK  6", 
            "title": "Message Bus Events"
        }, 
        {
            "location": "/ubit/multibutton/#api", 
            "text": "", 
            "title": "API"
        }, 
        {
            "location": "/ubit/multibutton/#constructor", 
            "text": "", 
            "title": "Constructor"
        }, 
        {
            "location": "/ubit/multibutton/#microbitmultibutton-uint16_t-button1-uint16_t-button2-uint16_t-id", 
            "text": "", 
            "title": "MicroBitMultiButton( uint16_t button1,  uint16_t button2,  uint16_t id)"
        }, 
        {
            "location": "/ubit/multibutton/#description", 
            "text": "Constructor.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/multibutton/#parameters", 
            "text": "uint16_t   button1  - the unique ID of the first button to watch.  uint16_t   button2  - the unique ID of the second button to watch.  uint16_t   id  - the unique  EventModel  id of this  MicroBitMultiButton  instance.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/multibutton/#example", 
            "text": "multiButton(MICROBIT_ID_BUTTON_A, MICROBIT_ID_BUTTON_B, MICROBIT_ID_BUTTON_AB);", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/multibutton/#ispressed", 
            "text": "", 
            "title": "isPressed"
        }, 
        {
            "location": "/ubit/multibutton/#int-ispressed", 
            "text": "", 
            "title": "int isPressed()"
        }, 
        {
            "location": "/ubit/multibutton/#description_1", 
            "text": "Tests if this  MicroBitMultiButton", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/multibutton/#returns", 
            "text": "1 if both physical buttons are pressed simultaneously.", 
            "title": "Returns"
        }, 
        {
            "location": "/ubit/multibutton/#example_1", 
            "text": "if(buttonAB.isPressed()) \n display.scroll( Pressed! );", 
            "title": "Example"
        }, 
        {
            "location": "/ubit/multibutton/#seteventconfiguration", 
            "text": "", 
            "title": "setEventConfiguration"
        }, 
        {
            "location": "/ubit/multibutton/#void-seteventconfiguration-microbitbuttoneventconfiguration-config", 
            "text": "", 
            "title": "void setEventConfiguration( MicroBitButtonEventConfiguration config)"
        }, 
        {
            "location": "/ubit/multibutton/#description_2", 
            "text": "Changes the event configuration of this button to the given MicroBitButtonEventConfiguration. All subsequent events generated by this button will then be informed by this configuraiton.", 
            "title": "Description"
        }, 
        {
            "location": "/ubit/multibutton/#parameters_1", 
            "text": "MicroBitButtonEventConfiguration   config  - The new configuration for this button. Legal values are MICROBIT_BUTTON_ALL_EVENTS or MICROBIT_BUTTON_SIMPLE_EVENTS.", 
            "title": "Parameters"
        }, 
        {
            "location": "/ubit/multibutton/#example_2", 
            "text": "// Configure a button to generate all possible events. \n buttonAB.setEventConfiguration(MICROBIT_BUTTON_ALL_EVENTS); \n\n // Configure a button to suppress MICROBIT_BUTTON_EVT_CLICK and MICROBIT_BUTTON_EVT_LONG_CLICK events. \n buttonAB.setEventConfiguration(MICROBIT_BUTTON_SIMPLE_EVENTS);", 
            "title": "Example"
        }
    ]
}